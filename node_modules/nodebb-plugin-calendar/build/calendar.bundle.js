webpackJsonp([2],{

/***/ 265:
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(fetch) {'use strict';

__webpack_require__(267);

var convertToFC = function convertToFC(event) {
  var ev = {
    id: event.pid,
    title: event.name,
    allDay: event.allday,
    start: event.startDate,
    end: event.endDate,
    className: ['plugin-calendar-cal-event-category-' + event.cid]
  };

  return ev;
}; /* global socket, $, config, app, RELATIVE_PATH, fetch, ajaxify */

var calendarOptions = {
  editable: false,
  header: {
    left: 'prev,next today',
    center: 'title',
    right: 'month,agendaWeek,agendaDay'
  },
  lang: config.userLang || config.defaultLang,
  events: function events(start, end, timezone, callback) {
    socket.emit('plugins.calendar.getEventsByDate', {
      startDate: start.valueOf(),
      endDate: end.valueOf()
    }, function (err, events) {
      if (err) {
        app.alertError(err);
        return;
      }
      callback(events.map(convertToFC));
    });
  },
  eventClick: function eventClick(event) {
    var pid = event.id;
    fetch(RELATIVE_PATH + '/api/post/' + pid).then(function (response) {
      return response.json();
    }).then(function (path) {
      return fetch(RELATIVE_PATH + '/api' + path);
    }).then(function (response) {
      return response.json();
    }).then(function (topic) {
      return topic.posts.find(function (post) {
        return parseInt(post.pid, 10) === pid;
      }).content;
    }).then(function (content) {
      var $c = $(content);
      var div = $c.filter('.plugin-calendar-event');
      if (!div.length) {
        div = $c.find('.plugin-calendar-event');
      }
      return div;
    }).then(function (div) {
      var modal = $('#plugin-calendar-cal-event-display');
      modal.find('.modal-body').empty().append(div);
      modal.find('.modal-footer a.btn-primary').attr('href', RELATIVE_PATH + '/post/' + pid);
      // modal
      //   .find('.modal-body .plugin-calendar-event-responses-lists .panel-heading a')
      //   .on('click', toggle);
      modal.find('.plugin-calendar-event-responses-lists .panel-body').addClass('topic').find('ul').addClass('posts');
      $(window).trigger('action:calendar.event.display', { pid: pid, modal: modal });
      modal.attr('data-pid', pid).modal({
        backdrop: false
      });
    });
  },
  timezone: 'local'
};

var openEvent = function openEvent() {
  // TODO: automatically go to an open event when pid is in hash of url
};

var init = function init() {
  $('#calendar').fullCalendar(calendarOptions);
  openEvent();
};

$(document).ready(init);
$(window).on('action:ajaxify.end', function () {
  if (ajaxify.data.template.calendar) {
    init();
  }
});
//# sourceMappingURL=data:application/json;base64,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LElBQU8sR0FBTTtBQUNqQixJQUFFLFdBQUYsRUFBZSxZQUFmLENBQTRCLGVBQTVCO0FBQ0E7QUFDRCxDQUhEOztBQUtBLEVBQUUsUUFBRixFQUFZLEtBQVosQ0FBa0IsSUFBbEI7QUFDQSxFQUFFLE1BQUYsRUFBVSxFQUFWLENBQWEsb0JBQWIsRUFBbUMsWUFBTTtBQUN2QyxNQUFJLFFBQVEsSUFBUixDQUFhLFFBQWIsQ0FBc0IsUUFBMUIsRUFBb0M7QUFDbEM7QUFDRDtBQUNGLENBSkQiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiL2hvbWUvcGV0ZXIvd2ViZGV2L25vZGViYi1wbHVnaW4tY2FsZW5kYXIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgc29ja2V0LCAkLCBjb25maWcsIGFwcCwgUkVMQVRJVkVfUEFUSCwgZmV0Y2gsIGFqYXhpZnkgKi9cblxuaW1wb3J0ICcuL3ZlbmRvci9mdWxsY2FsZW5kYXInO1xuXG5jb25zdCBjb252ZXJ0VG9GQyA9IGV2ZW50ID0+IHtcbiAgY29uc3QgZXYgPSB7XG4gICAgaWQ6IGV2ZW50LnBpZCxcbiAgICB0aXRsZTogZXZlbnQubmFtZSxcbiAgICBhbGxEYXk6IGV2ZW50LmFsbGRheSxcbiAgICBzdGFydDogZXZlbnQuc3RhcnREYXRlLFxuICAgIGVuZDogZXZlbnQuZW5kRGF0ZSxcbiAgICBjbGFzc05hbWU6IFtgcGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC1jYXRlZ29yeS0ke2V2ZW50LmNpZH1gXSxcbiAgfTtcblxuICByZXR1cm4gZXY7XG59O1xuXG5jb25zdCBjYWxlbmRhck9wdGlvbnMgPSB7XG4gIGVkaXRhYmxlOiBmYWxzZSxcbiAgaGVhZGVyOiB7XG4gICAgbGVmdDogJ3ByZXYsbmV4dCB0b2RheScsXG4gICAgY2VudGVyOiAndGl0bGUnLFxuICAgIHJpZ2h0OiAnbW9udGgsYWdlbmRhV2VlayxhZ2VuZGFEYXknLFxuICB9LFxuICBsYW5nOiBjb25maWcudXNlckxhbmcgfHwgY29uZmlnLmRlZmF1bHRMYW5nLFxuICBldmVudHM6IChzdGFydCwgZW5kLCB0aW1lem9uZSwgY2FsbGJhY2spID0+IHtcbiAgICBzb2NrZXQuZW1pdCgncGx1Z2lucy5jYWxlbmRhci5nZXRFdmVudHNCeURhdGUnLCB7XG4gICAgICBzdGFydERhdGU6IHN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgIGVuZERhdGU6IGVuZC52YWx1ZU9mKCksXG4gICAgfSwgKGVyciwgZXZlbnRzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGFwcC5hbGVydEVycm9yKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGV2ZW50cy5tYXAoY29udmVydFRvRkMpKTtcbiAgICB9KTtcbiAgfSxcbiAgZXZlbnRDbGljazogZXZlbnQgPT4ge1xuICAgIGNvbnN0IHBpZCA9IGV2ZW50LmlkO1xuICAgIGZldGNoKGAke1JFTEFUSVZFX1BBVEh9L2FwaS9wb3N0LyR7cGlkfWApXG4gICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgIC50aGVuKHBhdGggPT4gZmV0Y2goYCR7UkVMQVRJVkVfUEFUSH0vYXBpJHtwYXRofWApKVxuICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAudGhlbih0b3BpYyA9PiB0b3BpYy5wb3N0cy5maW5kKHBvc3QgPT4gcGFyc2VJbnQocG9zdC5waWQsIDEwKSA9PT0gcGlkKS5jb250ZW50KVxuICAgIC50aGVuKGNvbnRlbnQgPT4ge1xuICAgICAgY29uc3QgJGMgPSAkKGNvbnRlbnQpO1xuICAgICAgbGV0IGRpdiA9ICRjLmZpbHRlcignLnBsdWdpbi1jYWxlbmRhci1ldmVudCcpO1xuICAgICAgaWYgKCFkaXYubGVuZ3RoKSB7XG4gICAgICAgIGRpdiA9ICRjLmZpbmQoJy5wbHVnaW4tY2FsZW5kYXItZXZlbnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXY7XG4gICAgfSlcbiAgICAudGhlbihkaXYgPT4ge1xuICAgICAgY29uc3QgbW9kYWwgPSAkKCcjcGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC1kaXNwbGF5Jyk7XG4gICAgICBtb2RhbFxuICAgICAgICAuZmluZCgnLm1vZGFsLWJvZHknKVxuICAgICAgICAuZW1wdHkoKVxuICAgICAgICAuYXBwZW5kKGRpdik7XG4gICAgICBtb2RhbFxuICAgICAgICAuZmluZCgnLm1vZGFsLWZvb3RlciBhLmJ0bi1wcmltYXJ5JylcbiAgICAgICAgLmF0dHIoJ2hyZWYnLCBgJHtSRUxBVElWRV9QQVRIfS9wb3N0LyR7cGlkfWApO1xuICAgICAgLy8gbW9kYWxcbiAgICAgIC8vICAgLmZpbmQoJy5tb2RhbC1ib2R5IC5wbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVzcG9uc2VzLWxpc3RzIC5wYW5lbC1oZWFkaW5nIGEnKVxuICAgICAgLy8gICAub24oJ2NsaWNrJywgdG9nZ2xlKTtcbiAgICAgIG1vZGFsXG4gICAgICAgIC5maW5kKCcucGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlcy1saXN0cyAucGFuZWwtYm9keScpXG4gICAgICAgIC5hZGRDbGFzcygndG9waWMnKVxuICAgICAgICAuZmluZCgndWwnKVxuICAgICAgICAuYWRkQ2xhc3MoJ3Bvc3RzJyk7XG4gICAgICAkKHdpbmRvdykudHJpZ2dlcignYWN0aW9uOmNhbGVuZGFyLmV2ZW50LmRpc3BsYXknLCB7IHBpZCwgbW9kYWwgfSk7XG4gICAgICBtb2RhbFxuICAgICAgICAuYXR0cignZGF0YS1waWQnLCBwaWQpXG4gICAgICAgIC5tb2RhbCh7XG4gICAgICAgICAgYmFja2Ryb3A6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgdGltZXpvbmU6ICdsb2NhbCcsXG59O1xuXG5jb25zdCBvcGVuRXZlbnQgPSAoKSA9PiB7XG4gIC8vIFRPRE86IGF1dG9tYXRpY2FsbHkgZ28gdG8gYW4gb3BlbiBldmVudCB3aGVuIHBpZCBpcyBpbiBoYXNoIG9mIHVybFxufTtcblxuY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgJCgnI2NhbGVuZGFyJykuZnVsbENhbGVuZGFyKGNhbGVuZGFyT3B0aW9ucyk7XG4gIG9wZW5FdmVudCgpO1xufTtcblxuJChkb2N1bWVudCkucmVhZHkoaW5pdCk7XG4kKHdpbmRvdykub24oJ2FjdGlvbjphamF4aWZ5LmVuZCcsICgpID0+IHtcbiAgaWYgKGFqYXhpZnkuZGF0YS50ZW1wbGF0ZS5jYWxlbmRhcikge1xuICAgIGluaXQoKTtcbiAgfVxufSk7XG4iXX0=
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(507)))

/***/ },

/***/ 267:
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';var _typeof2=__webpack_require__(225);var _typeof3=_interopRequireDefault(_typeof2);var _moment=__webpack_require__(1);var _moment2=_interopRequireDefault(_moment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}(function(factory){factory(window.jQuery,_moment2.default);})(function($,moment){;;var FC=$.fullCalendar={version:"2.9.0",internalApiVersion:4};var fcViews=FC.views={};$.fn.fullCalendar=function(options){var args=Array.prototype.slice.call(arguments,1);// for a possible method call
var res=this;// what this function will return (this jQuery object by default)
this.each(function(i,_element){// loop each DOM element involved
var element=$(_element);var calendar=element.data('fullCalendar');// get the existing calendar object (if any)
var singleRes;// the returned value of this single method call
// a method call
if(typeof options==='string'){if(calendar&&$.isFunction(calendar[options])){singleRes=calendar[options].apply(calendar,args);if(!i){res=singleRes;// record the first method call result
}if(options==='destroy'){// for the destroy method, must remove Calendar object data
element.removeData('fullCalendar');}}}// a new calendar initialization
else if(!calendar){// don't initialize twice
calendar=new Calendar(element,options);element.data('fullCalendar',calendar);calendar.render();}});return res;};var complexOptions=[// names of options that are objects whose properties should be combined
'header','buttonText','buttonIcons','themeButtonIcons'];// Merges an array of option objects into a single object
function mergeOptions(optionObjs){return mergeProps(optionObjs,complexOptions);}// Given options specified for the calendar's constructor, massages any legacy options into a non-legacy form.
// Converts View-Option-Hashes into the View-Specific-Options format.
function massageOverrides(input){var overrides={views:input.views||{}};// the output. ensure a `views` hash
var subObj;// iterate through all option override properties (except `views`)
$.each(input,function(name,val){if(name!='views'){// could the value be a legacy View-Option-Hash?
if($.isPlainObject(val)&&!/(time|duration|interval)$/i.test(name)&&// exclude duration options. might be given as objects
$.inArray(name,complexOptions)==-1// complex options aren't allowed to be View-Option-Hashes
){subObj=null;// iterate through the properties of this possible View-Option-Hash value
$.each(val,function(subName,subVal){// is the property targeting a view?
if(/^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(subName)){if(!overrides.views[subName]){// ensure the view-target entry exists
overrides.views[subName]={};}overrides.views[subName][name]=subVal;// record the value in the `views` object
}else{// a non-View-Option-Hash property
if(!subObj){subObj={};}subObj[subName]=subVal;// accumulate these unrelated values for later
}});if(subObj){// non-View-Option-Hash properties? transfer them as-is
overrides[name]=subObj;}}else{overrides[name]=val;// transfer normal options as-is
}}});return overrides;};;// exports
FC.intersectRanges=intersectRanges;FC.applyAll=applyAll;FC.debounce=debounce;FC.isInt=isInt;FC.htmlEscape=htmlEscape;FC.cssToStr=cssToStr;FC.proxy=proxy;FC.capitaliseFirstLetter=capitaliseFirstLetter;/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls,scrollbarWidths){if(scrollbarWidths.left){rowEls.css({'border-left-width':1,'margin-left':scrollbarWidths.left-1});}if(scrollbarWidths.right){rowEls.css({'border-right-width':1,'margin-right':scrollbarWidths.right-1});}}// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls){rowEls.css({'margin-left':'','margin-right':'','border-left-width':'','border-right-width':''});}// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor(){$('body').addClass('fc-not-allowed');}// Returns the mouse cursor to its original look
function enableCursor(){$('body').removeClass('fc-not-allowed');}// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function distributeHeight(els,availableHeight,shouldRedistribute){// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
var minOffset1=Math.floor(availableHeight/els.length);// for non-last element
var minOffset2=Math.floor(availableHeight-minOffset1*(els.length-1));// for last element *FLOORING NOTE*
var flexEls=[];// elements that are allowed to expand. array of DOM nodes
var flexOffsets=[];// amount of vertical space it takes up
var flexHeights=[];// actual css height
var usedHeight=0;undistributeHeight(els);// give all elements their natural height
// find elements that are below the recommended height (expandable).
// important to query for heights in a single first pass (to avoid reflow oscillation).
els.each(function(i,el){var minOffset=i===els.length-1?minOffset2:minOffset1;var naturalOffset=$(el).outerHeight(true);if(naturalOffset<minOffset){flexEls.push(el);flexOffsets.push(naturalOffset);flexHeights.push($(el).height());}else{// this element stretches past recommended height (non-expandable). mark the space as occupied.
usedHeight+=naturalOffset;}});// readjust the recommended height to only consider the height available to non-maxed-out rows.
if(shouldRedistribute){availableHeight-=usedHeight;minOffset1=Math.floor(availableHeight/flexEls.length);minOffset2=Math.floor(availableHeight-minOffset1*(flexEls.length-1));// *FLOORING NOTE*
}// assign heights to all expandable elements
$(flexEls).each(function(i,el){var minOffset=i===flexEls.length-1?minOffset2:minOffset1;var naturalOffset=flexOffsets[i];var naturalHeight=flexHeights[i];var newHeight=minOffset-(naturalOffset-naturalHeight);// subtract the margin/padding
if(naturalOffset<minOffset){// we check this again because redistribution might have changed things
$(el).height(newHeight);}});}// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els){els.height('');}// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els){var maxInnerWidth=0;els.find('> span').each(function(i,innerEl){var innerWidth=$(innerEl).outerWidth();if(innerWidth>maxInnerWidth){maxInnerWidth=innerWidth;}});maxInnerWidth++;// sometimes not accurate of width the text needs to stay on one line. insurance
els.width(maxInnerWidth);return maxInnerWidth;}// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl,innerEl){var both=outerEl.add(innerEl);var diff;// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
both.css({position:'relative',// cause a reflow, which will force fresh dimension recalculation
left:-1// ensure reflow in case the el was already relative. negative is less likely to cause new scroll
});diff=outerEl.outerHeight()-innerEl.outerHeight();// grab the dimensions
both.css({position:'',left:''});// undo hack
return diff;}/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/FC.getOuterRect=getOuterRect;FC.getClientRect=getClientRect;FC.getContentRect=getContentRect;FC.getScrollbarWidths=_getScrollbarWidths;// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el){var position=el.css('position'),scrollParent=el.parents().filter(function(){var parent=$(this);return (/(auto|scroll)/.test(parent.css('overflow')+parent.css('overflow-y')+parent.css('overflow-x')));}).eq(0);return position==='fixed'||!scrollParent.length?$(el[0].ownerDocument||document):scrollParent;}// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el,origin){var offset=el.offset();var left=offset.left-(origin?origin.left:0);var top=offset.top-(origin?origin.top:0);return{left:left,right:left+el.outerWidth(),top:top,bottom:top+el.outerHeight()};}// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el,origin){var offset=el.offset();var scrollbarWidths=_getScrollbarWidths(el);var left=offset.left+getCssFloat(el,'border-left-width')+scrollbarWidths.left-(origin?origin.left:0);var top=offset.top+getCssFloat(el,'border-top-width')+scrollbarWidths.top-(origin?origin.top:0);return{left:left,right:left+el[0].clientWidth,// clientWidth includes padding but NOT scrollbars
top:top,bottom:top+el[0].clientHeight// clientHeight includes padding but NOT scrollbars
};}// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el,origin){var offset=el.offset();// just outside of border, margin not included
var left=offset.left+getCssFloat(el,'border-left-width')+getCssFloat(el,'padding-left')-(origin?origin.left:0);var top=offset.top+getCssFloat(el,'border-top-width')+getCssFloat(el,'padding-top')-(origin?origin.top:0);return{left:left,right:left+el.width(),top:top,bottom:top+el.height()};}// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function _getScrollbarWidths(el){var leftRightWidth=el.innerWidth()-el[0].clientWidth;// the paddings cancel out, leaving the scrollbars
var widths={left:0,right:0,top:0,bottom:el.innerHeight()-el[0].clientHeight// the paddings cancel out, leaving the bottom scrollbar
};if(getIsLeftRtlScrollbars()&&el.css('direction')=='rtl'){// is the scrollbar on the left side?
widths.left=leftRightWidth;}else{widths.right=leftRightWidth;}return widths;}// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
var _isLeftRtlScrollbars=null;function getIsLeftRtlScrollbars(){// responsible for caching the computation
if(_isLeftRtlScrollbars===null){_isLeftRtlScrollbars=computeIsLeftRtlScrollbars();}return _isLeftRtlScrollbars;}function computeIsLeftRtlScrollbars(){// creates an offscreen test element, then removes it
var el=$('<div><div/></div>').css({position:'absolute',top:-1000,left:0,border:0,padding:0,overflow:'scroll',direction:'rtl'}).appendTo('body');var innerEl=el.children();var res=innerEl.offset().left>el.offset().left;// is the inner div shifted to accommodate a left scrollbar?
el.remove();return res;}// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el,prop){return parseFloat(el.css(prop))||0;}/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/FC.preventDefault=preventDefault;// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev){return ev.which==1&&!ev.ctrlKey;}function getEvX(ev){if(ev.pageX!==undefined){return ev.pageX;}var touches=ev.originalEvent.touches;if(touches){return touches[0].pageX;}}function getEvY(ev){if(ev.pageY!==undefined){return ev.pageY;}var touches=ev.originalEvent.touches;if(touches){return touches[0].pageY;}}function getEvIsTouch(ev){return (/^touch/.test(ev.type));}function preventSelection(el){el.addClass('fc-unselectable').on('selectstart',preventDefault);}// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev){ev.preventDefault();}// attach a handler to get called when ANY scroll action happens on the page.
// this was impossible to do with normal on/off because 'scroll' doesn't bubble.
// http://stackoverflow.com/a/32954565/96342
// returns `true` on success.
function bindAnyScroll(handler){if(window.addEventListener){window.addEventListener('scroll',handler,true);// useCapture=true
return true;}return false;}// undoes bindAnyScroll. must pass in the original function.
// returns `true` on success.
function unbindAnyScroll(handler){if(window.removeEventListener){window.removeEventListener('scroll',handler,true);// useCapture=true
return true;}return false;}/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/FC.intersectRects=intersectRects;// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1,rect2){var res={left:Math.max(rect1.left,rect2.left),right:Math.min(rect1.right,rect2.right),top:Math.max(rect1.top,rect2.top),bottom:Math.min(rect1.bottom,rect2.bottom)};if(res.left<res.right&&res.top<res.bottom){return res;}return false;}// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point,rect){return{left:Math.min(Math.max(point.left,rect.left),rect.right),top:Math.min(Math.max(point.top,rect.top),rect.bottom)};}// Returns a point that is the center of the given rectangle
function getRectCenter(rect){return{left:(rect.left+rect.right)/2,top:(rect.top+rect.bottom)/2};}// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1,point2){return{left:point1.left-point2.left,top:point1.top-point2.top};}/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/FC.parseFieldSpecs=parseFieldSpecs;FC.compareByFieldSpecs=compareByFieldSpecs;FC.compareByFieldSpec=compareByFieldSpec;FC.flexibleCompare=flexibleCompare;function parseFieldSpecs(input){var specs=[];var tokens=[];var i,token;if(typeof input==='string'){tokens=input.split(/\s*,\s*/);}else if(typeof input==='function'){tokens=[input];}else if($.isArray(input)){tokens=input;}for(i=0;i<tokens.length;i++){token=tokens[i];if(typeof token==='string'){specs.push(token.charAt(0)=='-'?{field:token.substring(1),order:-1}:{field:token,order:1});}else if(typeof token==='function'){specs.push({func:token});}}return specs;}function compareByFieldSpecs(obj1,obj2,fieldSpecs){var i;var cmp;for(i=0;i<fieldSpecs.length;i++){cmp=compareByFieldSpec(obj1,obj2,fieldSpecs[i]);if(cmp){return cmp;}}return 0;}function compareByFieldSpec(obj1,obj2,fieldSpec){if(fieldSpec.func){return fieldSpec.func(obj1,obj2);}return flexibleCompare(obj1[fieldSpec.field],obj2[fieldSpec.field])*(fieldSpec.order||1);}function flexibleCompare(a,b){if(!a&&!b){return 0;}if(b==null){return-1;}if(a==null){return 1;}if($.type(a)==='string'||$.type(b)==='string'){return String(a).localeCompare(String(b));}return a-b;}/* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/// Computes the intersection of the two ranges. Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
function intersectRanges(subjectRange,constraintRange){var subjectStart=subjectRange.start;var subjectEnd=subjectRange.end;var constraintStart=constraintRange.start;var constraintEnd=constraintRange.end;var segStart,segEnd;var isStart,isEnd;if(subjectEnd>constraintStart&&subjectStart<constraintEnd){// in bounds at all?
if(subjectStart>=constraintStart){segStart=subjectStart.clone();isStart=true;}else{segStart=constraintStart.clone();isStart=false;}if(subjectEnd<=constraintEnd){segEnd=subjectEnd.clone();isEnd=true;}else{segEnd=constraintEnd.clone();isEnd=false;}return{start:segStart,end:segEnd,isStart:isStart,isEnd:isEnd};}}/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/FC.computeIntervalUnit=computeIntervalUnit;FC.divideRangeByDuration=divideRangeByDuration;FC.divideDurationByDuration=divideDurationByDuration;FC.multiplyDuration=multiplyDuration;FC.durationHasTime=durationHasTime;var dayIDs=['sun','mon','tue','wed','thu','fri','sat'];var intervalUnits=['year','month','week','day','hour','minute','second','millisecond'];// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a,b){return moment.duration({days:a.clone().stripTime().diff(b.clone().stripTime(),'days'),ms:a.time()-b.time()// time-of-day from day start. disregards timezone
});}// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a,b){return moment.duration({days:a.clone().stripTime().diff(b.clone().stripTime(),'days')});}// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a,b,unit){return moment.duration(Math.round(a.diff(b,unit,true)),// returnFloat=true
unit);}// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeIntervalUnit(start,end){var i,unit;var val;for(i=0;i<intervalUnits.length;i++){unit=intervalUnits[i];val=computeRangeAs(unit,start,end);if(val>=1&&isInt(val)){break;}}return unit;// will be "milliseconds" if nothing else matches
}// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit,start,end){if(end!=null){// given start, end
return end.diff(start,unit,true);}else if(moment.isDuration(start)){// given duration
return start.as(unit);}else{// given { start, end } range object
return start.end.diff(start.start,unit,true);}}// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start,end,dur){var months;if(durationHasTime(dur)){return(end-start)/dur;}months=dur.asMonths();if(Math.abs(months)>=1&&isInt(months)){return end.diff(start,'months',true)/months;}return end.diff(start,'days',true)/dur.asDays();}// Intelligently divides one duration by another
function divideDurationByDuration(dur1,dur2){var months1,months2;if(durationHasTime(dur1)||durationHasTime(dur2)){return dur1/dur2;}months1=dur1.asMonths();months2=dur2.asMonths();if(Math.abs(months1)>=1&&isInt(months1)&&Math.abs(months2)>=1&&isInt(months2)){return months1/months2;}return dur1.asDays()/dur2.asDays();}// Intelligently multiplies a duration by a number
function multiplyDuration(dur,n){var months;if(durationHasTime(dur)){return moment.duration(dur*n);}months=dur.asMonths();if(Math.abs(months)>=1&&isInt(months)){return moment.duration({months:months*n});}return moment.duration({days:dur.asDays()*n});}// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur){return Boolean(dur.hours()||dur.minutes()||dur.seconds()||dur.milliseconds());}function isNativeDate(input){return Object.prototype.toString.call(input)==='[object Date]'||input instanceof Date;}// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str){return (/^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str));}/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/FC.log=function(){var console=window.console;if(console&&console.log){return console.log.apply(console,arguments);}};FC.warn=function(){var console=window.console;if(console&&console.warn){return console.warn.apply(console,arguments);}else{return FC.log.apply(FC,arguments);}};/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/var hasOwnPropMethod={}.hasOwnProperty;// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs,complexProps){var dest={};var i,name;var complexObjs;var j,val;var props;if(complexProps){for(i=0;i<complexProps.length;i++){name=complexProps[i];complexObjs=[];// collect the trailing object values, stopping when a non-object is discovered
for(j=propObjs.length-1;j>=0;j--){val=propObjs[j][name];if((typeof val==='undefined'?'undefined':(0,_typeof3.default)(val))==='object'){complexObjs.unshift(val);}else if(val!==undefined){dest[name]=val;// if there were no objects, this value will be used
break;}}// if the trailing values were objects, use the merged value
if(complexObjs.length){dest[name]=mergeProps(complexObjs);}}}// copy values into the destination, going from last to first
for(i=propObjs.length-1;i>=0;i--){props=propObjs[i];for(name in props){if(!(name in dest)){// if already assigned by previous props or complex props, don't reassign
dest[name]=props[name];}}}return dest;}// Create an object that has the given prototype. Just like Object.create
function createObject(proto){var f=function f(){};f.prototype=proto;return new f();}function copyOwnProps(src,dest){for(var name in src){if(hasOwnProp(src,name)){dest[name]=src[name];}}}// Copies over certain methods with the same names as Object.prototype methods. Overcomes an IE<=8 bug:
// https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
function copyNativeMethods(src,dest){var names=['constructor','toString','valueOf'];var i,name;for(i=0;i<names.length;i++){name=names[i];if(src[name]!==Object.prototype[name]){dest[name]=src[name];}}}function hasOwnProp(obj,name){return hasOwnPropMethod.call(obj,name);}// Is the given value a non-object non-function value?
function isAtomic(val){return (/undefined|null|boolean|number|string/.test($.type(val)));}function applyAll(functions,thisObj,args){if($.isFunction(functions)){functions=[functions];}if(functions){var i;var ret;for(i=0;i<functions.length;i++){ret=functions[i].apply(thisObj,args)||ret;}return ret;}}function firstDefined(){for(var i=0;i<arguments.length;i++){if(arguments[i]!==undefined){return arguments[i];}}}function htmlEscape(s){return(s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/'/g,'&#039;').replace(/"/g,'&quot;').replace(/\n/g,'<br />');}function stripHtmlEntities(text){return text.replace(/&.*?;/g,'');}// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps){var statements=[];$.each(cssProps,function(name,val){if(val!=null){statements.push(name+':'+val);}});return statements.join(';');}function capitaliseFirstLetter(str){return str.charAt(0).toUpperCase()+str.slice(1);}function compareNumbers(a,b){// for .sort()
return a-b;}function isInt(n){return n%1===0;}// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj,methodName){var method=obj[methodName];return function(){return method.apply(obj,arguments);};}// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func,wait,immediate){var timeout,args,context,timestamp,result;var later=function later(){var last=+new Date()-timestamp;if(last<wait){timeout=setTimeout(later,wait-last);}else{timeout=null;if(!immediate){result=func.apply(context,args);context=args=null;}}};return function(){context=this;args=arguments;timestamp=+new Date();var callNow=immediate&&!timeout;if(!timeout){timeout=setTimeout(later,wait);}if(callNow){result=func.apply(context,args);context=args=null;}return result;};}// HACK around jQuery's now A+ promises: execute callback synchronously if already resolved.
// thenFunc shouldn't accept args.
// similar to whenResources in Scheduler plugin.
function syncThen(promise,thenFunc){// not a promise, or an already-resolved promise?
if(!promise||!promise.then||promise.state()==='resolved'){return $.when(thenFunc());// resolve immediately
}else if(thenFunc){return promise.then(thenFunc);}};;var ambigDateOfMonthRegex=/^\s*\d{4}-\d\d$/;var ambigTimeOrZoneRegex=/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;var newMomentProto=moment.fn;// where we will attach our new methods
var oldMomentProto=$.extend({},newMomentProto);// copy of original moment methods
var allowValueOptimization;var setUTCValues;// function defined below
var setLocalValues;// function defined below
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
FC.moment=function(){return makeMoment(arguments);};// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
FC.moment.utc=function(){var mom=makeMoment(arguments,true);// Force it into UTC because makeMoment doesn't guarantee it
// (if given a pre-existing moment for example)
if(mom.hasTime()){// don't give ambiguously-timed moments a UTC zone
mom.utc();}return mom;};// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
FC.moment.parseZone=function(){return makeMoment(arguments,true,true);};// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args,parseAsUTC,parseZone){var input=args[0];var isSingleString=args.length==1&&typeof input==='string';var isAmbigTime;var isAmbigZone;var ambigMatch;var mom;if(moment.isMoment(input)){mom=moment.apply(null,args);// clone it
transferAmbigs(input,mom);// the ambig flags weren't transfered with the clone
}else if(isNativeDate(input)||input===undefined){mom=moment.apply(null,args);// will be local
}else{// "parsing" is required
isAmbigTime=false;isAmbigZone=false;if(isSingleString){if(ambigDateOfMonthRegex.test(input)){// accept strings like '2014-05', but convert to the first of the month
input+='-01';args=[input];// for when we pass it on to moment's constructor
isAmbigTime=true;isAmbigZone=true;}else if(ambigMatch=ambigTimeOrZoneRegex.exec(input)){isAmbigTime=!ambigMatch[5];// no time part?
isAmbigZone=true;}}else if($.isArray(input)){// arrays have no timezone information, so assume ambiguous zone
isAmbigZone=true;}// otherwise, probably a string with a format
if(parseAsUTC||isAmbigTime){mom=moment.utc.apply(moment,args);}else{mom=moment.apply(null,args);}if(isAmbigTime){mom._ambigTime=true;mom._ambigZone=true;// ambiguous time always means ambiguous zone
}else if(parseZone){// let's record the inputted zone somehow
if(isAmbigZone){mom._ambigZone=true;}else if(isSingleString){if(mom.utcOffset){mom.utcOffset(input);// if not a valid zone, will assign UTC
}else{mom.zone(input);// for moment-pre-2.9
}}}}mom._fullCalendar=true;// flag for extended functionality
return mom;}// A clone method that works with the flags related to our enhanced functionality.
// In the future, use moment.momentProperties
newMomentProto.clone=function(){var mom=oldMomentProto.clone.apply(this,arguments);// these flags weren't transfered with the clone
transferAmbigs(this,mom);if(this._fullCalendar){mom._fullCalendar=true;}return mom;};// Week Number
// -------------------------------------------------------------------------------------------------
// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week=newMomentProto.weeks=function(input){var weekCalc=(this._locale||this._lang).// works pre-moment-2.8
_fullCalendar_weekCalc;if(input==null&&typeof weekCalc==='function'){// custom function only works for getter
return weekCalc(this);}else if(weekCalc==='ISO'){return oldMomentProto.isoWeek.apply(this,arguments);// ISO getter/setter
}return oldMomentProto.week.apply(this,arguments);// local getter/setter
};// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time=function(time){// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
if(!this._fullCalendar){return oldMomentProto.time.apply(this,arguments);}if(time==null){// getter
return moment.duration({hours:this.hours(),minutes:this.minutes(),seconds:this.seconds(),milliseconds:this.milliseconds()});}else{// setter
this._ambigTime=false;// mark that the moment now has a time
if(!moment.isDuration(time)&&!moment.isMoment(time)){time=moment.duration(time);}// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
// Only for Duration times, not Moment times.
var dayHours=0;if(moment.isDuration(time)){dayHours=Math.floor(time.asDays())*24;}// We need to set the individual fields.
// Can't use startOf('day') then add duration. In case of DST at start of day.
return this.hours(dayHours+time.hours()).minutes(time.minutes()).seconds(time.seconds()).milliseconds(time.milliseconds());}};// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime=function(){var a;if(!this._ambigTime){// get the values before any conversion happens
a=this.toArray();// array of y/m/d/h/m/s/ms
// TODO: use keepLocalTime in the future
this.utc();// set the internal UTC flag (will clear the ambig flags)
setUTCValues(this,a.slice(0,3));// set the year/month/date. time will be zero
// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
// which clears all ambig flags. Same with setUTCValues with moment-timezone.
this._ambigTime=true;this._ambigZone=true;// if ambiguous time, also ambiguous timezone offset
}return this;// for chaining
};// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime=function(){return!this._ambigTime;};// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
// TODO: look into Moment's keepLocalTime functionality
newMomentProto.stripZone=function(){var a,wasAmbigTime;if(!this._ambigZone){// get the values before any conversion happens
a=this.toArray();// array of y/m/d/h/m/s/ms
wasAmbigTime=this._ambigTime;this.utc();// set the internal UTC flag (might clear the ambig flags, depending on Moment internals)
setUTCValues(this,a);// will set the year/month/date/hours/minutes/seconds/ms
// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
this._ambigTime=wasAmbigTime||false;// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
// which clears the ambig flags. Same with setUTCValues with moment-timezone.
this._ambigZone=true;}return this;// for chaining
};// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone=function(){return!this._ambigZone;};// this method implicitly marks a zone
newMomentProto.local=function(){var a=this.toArray();// year,month,date,hours,minutes,seconds,ms as an array
var wasAmbigZone=this._ambigZone;oldMomentProto.local.apply(this,arguments);// ensure non-ambiguous
// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
this._ambigTime=false;this._ambigZone=false;if(wasAmbigZone){// If the moment was ambiguously zoned, the date fields were stored as UTC.
// We want to preserve these, but in local time.
// TODO: look into Moment's keepLocalTime functionality
setLocalValues(this,a);}return this;// for chaining
};// implicitly marks a zone
newMomentProto.utc=function(){oldMomentProto.utc.apply(this,arguments);// ensure non-ambiguous
// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
this._ambigTime=false;this._ambigZone=false;return this;};// methods for arbitrarily manipulating timezone offset.
// should clear time/zone ambiguity when called.
$.each(['zone',// only in moment-pre-2.9. deprecated afterwards
'utcOffset'],function(i,name){if(oldMomentProto[name]){// original method exists?
// this method implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto[name]=function(tzo){if(tzo!=null){// setter
// these assignments needs to happen before the original zone method is called.
// I forget why, something to do with a browser crash.
this._ambigTime=false;this._ambigZone=false;}return oldMomentProto[name].apply(this,arguments);};}});// Formatting
// -------------------------------------------------------------------------------------------------
newMomentProto.format=function(){if(this._fullCalendar&&arguments[0]){// an enhanced moment? and a format string provided?
return formatDate(this,arguments[0]);// our extended formatting
}if(this._ambigTime){return oldMomentFormat(this,'YYYY-MM-DD');}if(this._ambigZone){return oldMomentFormat(this,'YYYY-MM-DD[T]HH:mm:ss');}return oldMomentProto.format.apply(this,arguments);};newMomentProto.toISOString=function(){if(this._ambigTime){return oldMomentFormat(this,'YYYY-MM-DD');}if(this._ambigZone){return oldMomentFormat(this,'YYYY-MM-DD[T]HH:mm:ss');}return oldMomentProto.toISOString.apply(this,arguments);};// Querying
// -------------------------------------------------------------------------------------------------
// Is the moment within the specified range? `end` is exclusive.
// FYI, this method is not a standard Moment method, so always do our enhanced logic.
newMomentProto.isWithin=function(start,end){var a=commonlyAmbiguate([this,start,end]);return a[0]>=a[1]&&a[0]<a[2];};// When isSame is called with units, timezone ambiguity is normalized before the comparison happens.
// If no units specified, the two moments must be identically the same, with matching ambig flags.
newMomentProto.isSame=function(input,units){var a;// only do custom logic if this is an enhanced moment
if(!this._fullCalendar){return oldMomentProto.isSame.apply(this,arguments);}if(units){a=commonlyAmbiguate([this,input],true);// normalize timezones but don't erase times
return oldMomentProto.isSame.call(a[0],a[1],units);}else{input=FC.moment.parseZone(input);// normalize input
return oldMomentProto.isSame.call(this,input)&&Boolean(this._ambigTime)===Boolean(input._ambigTime)&&Boolean(this._ambigZone)===Boolean(input._ambigZone);}};// Make these query methods work with ambiguous moments
$.each(['isBefore','isAfter'],function(i,methodName){newMomentProto[methodName]=function(input,units){var a;// only do custom logic if this is an enhanced moment
if(!this._fullCalendar){return oldMomentProto[methodName].apply(this,arguments);}a=commonlyAmbiguate([this,input]);return oldMomentProto[methodName].call(a[0],a[1],units);};});// Misc Internals
// -------------------------------------------------------------------------------------------------
// given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.
// for example, of one moment has ambig time, but not others, all moments will have their time stripped.
// set `preserveTime` to `true` to keep times, but only normalize zone ambiguity.
// returns the original moments if no modifications are necessary.
function commonlyAmbiguate(inputs,preserveTime){var anyAmbigTime=false;var anyAmbigZone=false;var len=inputs.length;var moms=[];var i,mom;// parse inputs into real moments and query their ambig flags
for(i=0;i<len;i++){mom=inputs[i];if(!moment.isMoment(mom)){mom=FC.moment.parseZone(mom);}anyAmbigTime=anyAmbigTime||mom._ambigTime;anyAmbigZone=anyAmbigZone||mom._ambigZone;moms.push(mom);}// strip each moment down to lowest common ambiguity
// use clones to avoid modifying the original moments
for(i=0;i<len;i++){mom=moms[i];if(!preserveTime&&anyAmbigTime&&!mom._ambigTime){moms[i]=mom.clone().stripTime();}else if(anyAmbigZone&&!mom._ambigZone){moms[i]=mom.clone().stripZone();}}return moms;}// Transfers all the flags related to ambiguous time/zone from the `src` moment to the `dest` moment
// TODO: look into moment.momentProperties for this.
function transferAmbigs(src,dest){if(src._ambigTime){dest._ambigTime=true;}else if(dest._ambigTime){dest._ambigTime=false;}if(src._ambigZone){dest._ambigZone=true;}else if(dest._ambigZone){dest._ambigZone=false;}}// Sets the year/month/date/etc values of the moment from the given array.
// Inefficient because it calls each individual setter.
function setMomentValues(mom,a){mom.year(a[0]||0).month(a[1]||0).date(a[2]||0).hours(a[3]||0).minutes(a[4]||0).seconds(a[5]||0).milliseconds(a[6]||0);}// Can we set the moment's internal date directly?
allowValueOptimization='_d'in moment()&&'updateOffset'in moment;// Utility function. Accepts a moment and an array of the UTC year/month/date/etc values to set.
// Assumes the given moment is already in UTC mode.
setUTCValues=allowValueOptimization?function(mom,a){// simlate what moment's accessors do
mom._d.setTime(Date.UTC.apply(Date,a));moment.updateOffset(mom,false);// keepTime=false
}:setMomentValues;// Utility function. Accepts a moment and an array of the local year/month/date/etc values to set.
// Assumes the given moment is already in local mode.
setLocalValues=allowValueOptimization?function(mom,a){// simlate what moment's accessors do
mom._d.setTime(+new Date(// FYI, there is now way to apply an array of args to a constructor
a[0]||0,a[1]||0,a[2]||0,a[3]||0,a[4]||0,a[5]||0,a[6]||0));moment.updateOffset(mom,false);// keepTime=false
}:setMomentValues;;;// Single Date Formatting
// -------------------------------------------------------------------------------------------------
// call this if you want Moment's original format method to be used
function oldMomentFormat(mom,formatStr){return oldMomentProto.format.call(mom,formatStr);// oldMomentProto defined in moment-ext.js
}// Formats `date` with a Moment formatting string, but allow our non-zero areas and
// additional token.
function formatDate(date,formatStr){return formatDateWithChunks(date,getFormatStringChunks(formatStr));}function formatDateWithChunks(date,chunks){var s='';var i;for(i=0;i<chunks.length;i++){s+=formatDateWithChunk(date,chunks[i]);}return s;}// addition formatting tokens we want recognized
var tokenOverrides={t:function t(date){// "a" or "p"
return oldMomentFormat(date,'a').charAt(0);},T:function T(date){// "A" or "P"
return oldMomentFormat(date,'A').charAt(0);}};function formatDateWithChunk(date,chunk){var token;var maybeStr;if(typeof chunk==='string'){// a literal string
return chunk;}else if(token=chunk.token){// a token, like "YYYY"
if(tokenOverrides[token]){return tokenOverrides[token](date);// use our custom token
}return oldMomentFormat(date,token);}else if(chunk.maybe){// a grouping of other chunks that must be non-zero
maybeStr=formatDateWithChunks(date,chunk.maybe);if(maybeStr.match(/[1-9]/)){return maybeStr;}}return'';}// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
// Using a formatting string meant for a single date, generate a range string, like
// "Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
// If the dates are the same as far as the format string is concerned, just return a single
// rendering of one date, without any separator.
function _formatRange(date1,date2,formatStr,separator,isRTL){var localeData;date1=FC.moment.parseZone(date1);date2=FC.moment.parseZone(date2);localeData=(date1.localeData||date1.lang).call(date1);// works with moment-pre-2.8
// Expand localized format strings, like "LL" -> "MMMM D YYYY"
formatStr=localeData.longDateFormat(formatStr)||formatStr;// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
// or non-zero areas in Moment's localized format strings.
separator=separator||' - ';return formatRangeWithChunks(date1,date2,getFormatStringChunks(formatStr),separator,isRTL);}FC.formatRange=_formatRange;// expose
function formatRangeWithChunks(date1,date2,chunks,separator,isRTL){var unzonedDate1=date1.clone().stripZone();// for formatSimilarChunk
var unzonedDate2=date2.clone().stripZone();// "
var chunkStr;// the rendering of the chunk
var leftI;var leftStr='';var rightI;var rightStr='';var middleI;var middleStr1='';var middleStr2='';var middleStr='';// Start at the leftmost side of the formatting string and continue until you hit a token
// that is not the same between dates.
for(leftI=0;leftI<chunks.length;leftI++){chunkStr=formatSimilarChunk(date1,date2,unzonedDate1,unzonedDate2,chunks[leftI]);if(chunkStr===false){break;}leftStr+=chunkStr;}// Similarly, start at the rightmost side of the formatting string and move left
for(rightI=chunks.length-1;rightI>leftI;rightI--){chunkStr=formatSimilarChunk(date1,date2,unzonedDate1,unzonedDate2,chunks[rightI]);if(chunkStr===false){break;}rightStr=chunkStr+rightStr;}// The area in the middle is different for both of the dates.
// Collect them distinctly so we can jam them together later.
for(middleI=leftI;middleI<=rightI;middleI++){middleStr1+=formatDateWithChunk(date1,chunks[middleI]);middleStr2+=formatDateWithChunk(date2,chunks[middleI]);}if(middleStr1||middleStr2){if(isRTL){middleStr=middleStr2+separator+middleStr1;}else{middleStr=middleStr1+separator+middleStr2;}}return leftStr+middleStr+rightStr;}var similarUnitMap={Y:'year',M:'month',D:'day',// day of month
d:'day',// day of week
// prevents a separator between anything time-related...
A:'second',// AM/PM
a:'second',// am/pm
T:'second',// A/P
t:'second',// a/p
H:'second',// hour (24)
h:'second',// hour (12)
m:'second',// minute
s:'second'// second
};// TODO: week maybe?
// Given a formatting chunk, and given that both dates are similar in the regard the
// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.
function formatSimilarChunk(date1,date2,unzonedDate1,unzonedDate2,chunk){var token;var unit;if(typeof chunk==='string'){// a literal string
return chunk;}else if(token=chunk.token){unit=similarUnitMap[token.charAt(0)];// are the dates the same for this unit of measurement?
// use the unzoned dates for this calculation because unreliable when near DST (bug #2396)
if(unit&&unzonedDate1.isSame(unzonedDate2,unit)){return oldMomentFormat(date1,token);// would be the same if we used `date2`
// BTW, don't support custom tokens
}}return false;// the chunk is NOT the same for the two dates
// BTW, don't support splitting on non-zero areas
}// Chunking Utils
// -------------------------------------------------------------------------------------------------
var formatStringChunkCache={};function getFormatStringChunks(formatStr){if(formatStr in formatStringChunkCache){return formatStringChunkCache[formatStr];}return formatStringChunkCache[formatStr]=chunkFormatString(formatStr);}// Break the formatting string into an array of chunks
function chunkFormatString(formatStr){var chunks=[];var chunker=/\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;// TODO: more descrimination
var match;while(match=chunker.exec(formatStr)){if(match[1]){// a literal string inside [ ... ]
chunks.push(match[1]);}else if(match[2]){// non-zero formatting inside ( ... )
chunks.push({maybe:chunkFormatString(match[2])});}else if(match[3]){// a formatting token
chunks.push({token:match[3]});}else if(match[5]){// an unenclosed literal string
chunks.push(match[5]);}}return chunks;};;FC.Class=Class;// export
// Class that all other classes will inherit from
function Class(){}// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
Class.extend=function(){var len=arguments.length;var i;var members;for(i=0;i<len;i++){members=arguments[i];if(i<len-1){// not the last argument?
mixIntoClass(this,members);}}return extendClass(this,members||{});// members will be undefined if no arguments
};// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
Class.mixin=function(members){mixIntoClass(this,members);};function extendClass(superClass,members){var subClass;// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
if(hasOwnProp(members,'constructor')){subClass=members.constructor;}if(typeof subClass!=='function'){subClass=members.constructor=function(){superClass.apply(this,arguments);};}// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
subClass.prototype=createObject(superClass.prototype);// copy each member variable/method onto the the subclass's prototype
copyOwnProps(members,subClass.prototype);copyNativeMethods(members,subClass.prototype);// hack for IE8
// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
copyOwnProps(superClass,subClass);return subClass;}function mixIntoClass(theClass,members){copyOwnProps(members,theClass.prototype);// TODO: copyNativeMethods?
};;var EmitterMixin=FC.EmitterMixin={// jQuery-ification via $(this) allows a non-DOM object to have
// the same event handling capabilities (including namespaces).
on:function on(types,handler){// handlers are always called with an "event" object as their first param.
// sneak the `this` context and arguments into the extra parameter object
// and forward them on to the original handler.
var intercept=function intercept(ev,extra){return handler.apply(extra.context||this,extra.args||[]);};// mimick jQuery's internal "proxy" system (risky, I know)
// causing all functions with the same .guid to appear to be the same.
// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
// this is needed for calling .off with the original non-intercept handler.
if(!handler.guid){handler.guid=$.guid++;}intercept.guid=handler.guid;$(this).on(types,intercept);return this;// for chaining
},off:function off(types,handler){$(this).off(types,handler);return this;// for chaining
},trigger:function trigger(types){var args=Array.prototype.slice.call(arguments,1);// arguments after the first
// pass in "extra" info to the intercept
$(this).triggerHandler(types,{args:args});return this;// for chaining
},triggerWith:function triggerWith(types,context,args){// `triggerHandler` is less reliant on the DOM compared to `trigger`.
// pass in "extra" info to the intercept.
$(this).triggerHandler(types,{context:context,args:args});return this;// for chaining
}};;;/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.
*/var ListenerMixin=FC.ListenerMixin=function(){var guid=0;var ListenerMixin={listenerId:null,/*
		Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
		The `callback` will be called with the `this` context of the object that .listenTo is being called on.
		Can be called:
			.listenTo(other, eventName, callback)
		OR
			.listenTo(other, {
				eventName1: callback1,
				eventName2: callback2
			})
		*/listenTo:function listenTo(other,arg,callback){if((typeof arg==='undefined'?'undefined':(0,_typeof3.default)(arg))==='object'){// given dictionary of callbacks
for(var eventName in arg){if(arg.hasOwnProperty(eventName)){this.listenTo(other,eventName,arg[eventName]);}}}else if(typeof arg==='string'){other.on(arg+'.'+this.getListenerNamespace(),// use event namespacing to identify this object
$.proxy(callback,this)// always use `this` context
// the usually-undesired jQuery guid behavior doesn't matter,
// because we always unbind via namespace
);}},/*
		Causes the current object to stop listening to events on the `other` object.
		`eventName` is optional. If omitted, will stop listening to ALL events on `other`.
		*/stopListeningTo:function stopListeningTo(other,eventName){other.off((eventName||'')+'.'+this.getListenerNamespace());},/*
		Returns a string, unique to this object, to be used for event namespacing
		*/getListenerNamespace:function getListenerNamespace(){if(this.listenerId==null){this.listenerId=guid++;}return'_listener'+this.listenerId;}};return ListenerMixin;}();;;// simple class for toggle a `isIgnoringMouse` flag on delay
// initMouseIgnoring must first be called, with a millisecond delay setting.
var MouseIgnorerMixin={isIgnoringMouse:false,// bool
delayUnignoreMouse:null,// method
initMouseIgnoring:function initMouseIgnoring(delay){this.delayUnignoreMouse=debounce(proxy(this,'unignoreMouse'),delay||1000);},// temporarily ignore mouse actions on segments
tempIgnoreMouse:function tempIgnoreMouse(){this.isIgnoringMouse=true;this.delayUnignoreMouse();},// delayUnignoreMouse eventually calls this
unignoreMouse:function unignoreMouse(){this.isIgnoringMouse=false;}};;;/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/var Popover=Class.extend(ListenerMixin,{isHidden:true,options:null,el:null,// the container element for the popover. generated by this object
margin:10,// the space required between the popover and the edges of the scroll container
constructor:function constructor(options){this.options=options||{};},// Shows the popover on the specified position. Renders it if not already
show:function show(){if(this.isHidden){if(!this.el){this.render();}this.el.show();this.position();this.isHidden=false;this.trigger('show');}},// Hides the popover, through CSS, but does not remove it from the DOM
hide:function hide(){if(!this.isHidden){this.el.hide();this.isHidden=true;this.trigger('hide');}},// Creates `this.el` and renders content inside of it
render:function render(){var _this=this;var options=this.options;this.el=$('<div class="fc-popover"/>').addClass(options.className||'').css({// position initially to the top left to avoid creating scrollbars
top:0,left:0}).append(options.content).appendTo(options.parentEl);// when a click happens on anything inside with a 'fc-close' className, hide the popover
this.el.on('click','.fc-close',function(){_this.hide();});if(options.autoHide){this.listenTo($(document),'mousedown',this.documentMousedown);}},// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
documentMousedown:function documentMousedown(ev){// only hide the popover if the click happened outside the popover
if(this.el&&!$(ev.target).closest(this.el).length){this.hide();}},// Hides and unregisters any handlers
removeElement:function removeElement(){this.hide();if(this.el){this.el.remove();this.el=null;}this.stopListeningTo($(document),'mousedown');},// Positions the popover optimally, using the top/left/right options
position:function position(){var options=this.options;var origin=this.el.offsetParent().offset();var width=this.el.outerWidth();var height=this.el.outerHeight();var windowEl=$(window);var viewportEl=getScrollParent(this.el);var viewportTop;var viewportLeft;var viewportOffset;var top;// the "position" (not "offset") values for the popover
var left;//
// compute top and left
top=options.top||0;if(options.left!==undefined){left=options.left;}else if(options.right!==undefined){left=options.right-width;// derive the left value from the right value
}else{left=0;}if(viewportEl.is(window)||viewportEl.is(document)){// normalize getScrollParent's result
viewportEl=windowEl;viewportTop=0;// the window is always at the top left
viewportLeft=0;// (and .offset() won't work if called here)
}else{viewportOffset=viewportEl.offset();viewportTop=viewportOffset.top;viewportLeft=viewportOffset.left;}// if the window is scrolled, it causes the visible area to be further down
viewportTop+=windowEl.scrollTop();viewportLeft+=windowEl.scrollLeft();// constrain to the view port. if constrained by two edges, give precedence to top/left
if(options.viewportConstrain!==false){top=Math.min(top,viewportTop+viewportEl.outerHeight()-height-this.margin);top=Math.max(top,viewportTop+this.margin);left=Math.min(left,viewportLeft+viewportEl.outerWidth()-width-this.margin);left=Math.max(left,viewportLeft+this.margin);}this.el.css({top:top-origin.top,left:left-origin.left});},// Triggers a callback. Calls a function in the option hash of the same name.
// Arguments beyond the first `name` are forwarded on.
// TODO: better code reuse for this. Repeat code
trigger:function trigger(name){if(this.options[name]){this.options[name].apply(this,Array.prototype.slice.call(arguments,1));}}});;;/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/var CoordCache=FC.CoordCache=Class.extend({els:null,// jQuery set (assumed to be siblings)
forcedOffsetParentEl:null,// options can override the natural offsetParent
origin:null,// {left,top} position of offsetParent of els
boundingRect:null,// constrain cordinates to this rectangle. {left,right,top,bottom} or null
isHorizontal:false,// whether to query for left/right/width
isVertical:false,// whether to query for top/bottom/height
// arrays of coordinates (offsets from topleft of document)
lefts:null,rights:null,tops:null,bottoms:null,constructor:function constructor(options){this.els=$(options.els);this.isHorizontal=options.isHorizontal;this.isVertical=options.isVertical;this.forcedOffsetParentEl=options.offsetParent?$(options.offsetParent):null;},// Queries the els for coordinates and stores them.
// Call this method before using and of the get* methods below.
build:function build(){var offsetParentEl=this.forcedOffsetParentEl||this.els.eq(0).offsetParent();this.origin=offsetParentEl.offset();this.boundingRect=this.queryBoundingRect();if(this.isHorizontal){this.buildElHorizontals();}if(this.isVertical){this.buildElVerticals();}},// Destroys all internal data about coordinates, freeing memory
clear:function clear(){this.origin=null;this.boundingRect=null;this.lefts=null;this.rights=null;this.tops=null;this.bottoms=null;},// When called, if coord caches aren't built, builds them
ensureBuilt:function ensureBuilt(){if(!this.origin){this.build();}},// Compute and return what the elements' bounding rectangle is, from the user's perspective.
// Right now, only returns a rectangle if constrained by an overflow:scroll element.
queryBoundingRect:function queryBoundingRect(){var scrollParentEl=getScrollParent(this.els.eq(0));if(!scrollParentEl.is(document)){return getClientRect(scrollParentEl);}},// Populates the left/right internal coordinate arrays
buildElHorizontals:function buildElHorizontals(){var lefts=[];var rights=[];this.els.each(function(i,node){var el=$(node);var left=el.offset().left;var width=el.outerWidth();lefts.push(left);rights.push(left+width);});this.lefts=lefts;this.rights=rights;},// Populates the top/bottom internal coordinate arrays
buildElVerticals:function buildElVerticals(){var tops=[];var bottoms=[];this.els.each(function(i,node){var el=$(node);var top=el.offset().top;var height=el.outerHeight();tops.push(top);bottoms.push(top+height);});this.tops=tops;this.bottoms=bottoms;},// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
// If no intersection is made, or outside of the boundingRect, returns undefined.
getHorizontalIndex:function getHorizontalIndex(leftOffset){this.ensureBuilt();var boundingRect=this.boundingRect;var lefts=this.lefts;var rights=this.rights;var len=lefts.length;var i;if(!boundingRect||leftOffset>=boundingRect.left&&leftOffset<boundingRect.right){for(i=0;i<len;i++){if(leftOffset>=lefts[i]&&leftOffset<rights[i]){return i;}}}},// Given a top offset (from document top), returns the index of the el that it vertically intersects.
// If no intersection is made, or outside of the boundingRect, returns undefined.
getVerticalIndex:function getVerticalIndex(topOffset){this.ensureBuilt();var boundingRect=this.boundingRect;var tops=this.tops;var bottoms=this.bottoms;var len=tops.length;var i;if(!boundingRect||topOffset>=boundingRect.top&&topOffset<boundingRect.bottom){for(i=0;i<len;i++){if(topOffset>=tops[i]&&topOffset<bottoms[i]){return i;}}}},// Gets the left offset (from document left) of the element at the given index
getLeftOffset:function getLeftOffset(leftIndex){this.ensureBuilt();return this.lefts[leftIndex];},// Gets the left position (from offsetParent left) of the element at the given index
getLeftPosition:function getLeftPosition(leftIndex){this.ensureBuilt();return this.lefts[leftIndex]-this.origin.left;},// Gets the right offset (from document left) of the element at the given index.
// This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
getRightOffset:function getRightOffset(leftIndex){this.ensureBuilt();return this.rights[leftIndex];},// Gets the right position (from offsetParent left) of the element at the given index.
// This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
getRightPosition:function getRightPosition(leftIndex){this.ensureBuilt();return this.rights[leftIndex]-this.origin.left;},// Gets the width of the element at the given index
getWidth:function getWidth(leftIndex){this.ensureBuilt();return this.rights[leftIndex]-this.lefts[leftIndex];},// Gets the top offset (from document top) of the element at the given index
getTopOffset:function getTopOffset(topIndex){this.ensureBuilt();return this.tops[topIndex];},// Gets the top position (from offsetParent top) of the element at the given position
getTopPosition:function getTopPosition(topIndex){this.ensureBuilt();return this.tops[topIndex]-this.origin.top;},// Gets the bottom offset (from the document top) of the element at the given index.
// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
getBottomOffset:function getBottomOffset(topIndex){this.ensureBuilt();return this.bottoms[topIndex];},// Gets the bottom position (from the offsetParent top) of the element at the given index.
// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
getBottomPosition:function getBottomPosition(topIndex){this.ensureBuilt();return this.bottoms[topIndex]-this.origin.top;},// Gets the height of the element at the given index
getHeight:function getHeight(topIndex){this.ensureBuilt();return this.bottoms[topIndex]-this.tops[topIndex];}});;;/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/// TODO: use Emitter
var DragListener=FC.DragListener=Class.extend(ListenerMixin,MouseIgnorerMixin,{options:null,// for IE8 bug-fighting behavior
subjectEl:null,subjectHref:null,// coordinates of the initial mousedown
originX:null,originY:null,// the wrapping element that scrolls, or MIGHT scroll if there's overflow.
// TODO: do this for wrappers that have overflow:hidden as well.
scrollEl:null,isInteracting:false,isDistanceSurpassed:false,isDelayEnded:false,isDragging:false,isTouch:false,delay:null,delayTimeoutId:null,minDistance:null,handleTouchScrollProxy:null,// calls handleTouchScroll, always bound to `this`
constructor:function constructor(options){this.options=options||{};this.handleTouchScrollProxy=proxy(this,'handleTouchScroll');this.initMouseIgnoring(500);},// Interaction (high-level)
// -----------------------------------------------------------------------------------------------------------------
startInteraction:function startInteraction(ev,extraOptions){var isTouch=getEvIsTouch(ev);if(ev.type==='mousedown'){if(this.isIgnoringMouse){return;}else if(!isPrimaryMouseButton(ev)){return;}else{ev.preventDefault();// prevents native selection in most browsers
}}if(!this.isInteracting){// process options
extraOptions=extraOptions||{};this.delay=firstDefined(extraOptions.delay,this.options.delay,0);this.minDistance=firstDefined(extraOptions.distance,this.options.distance,0);this.subjectEl=this.options.subjectEl;this.isInteracting=true;this.isTouch=isTouch;this.isDelayEnded=false;this.isDistanceSurpassed=false;this.originX=getEvX(ev);this.originY=getEvY(ev);this.scrollEl=getScrollParent($(ev.target));this.bindHandlers();this.initAutoScroll();this.handleInteractionStart(ev);this.startDelay(ev);if(!this.minDistance){this.handleDistanceSurpassed(ev);}}},handleInteractionStart:function handleInteractionStart(ev){this.trigger('interactionStart',ev);},endInteraction:function endInteraction(ev,isCancelled){if(this.isInteracting){this.endDrag(ev);if(this.delayTimeoutId){clearTimeout(this.delayTimeoutId);this.delayTimeoutId=null;}this.destroyAutoScroll();this.unbindHandlers();this.isInteracting=false;this.handleInteractionEnd(ev,isCancelled);// a touchstart+touchend on the same element will result in the following addition simulated events:
// mouseover + mouseout + click
// let's ignore these bogus events
if(this.isTouch){this.tempIgnoreMouse();}}},handleInteractionEnd:function handleInteractionEnd(ev,isCancelled){this.trigger('interactionEnd',ev,isCancelled||false);},// Binding To DOM
// -----------------------------------------------------------------------------------------------------------------
bindHandlers:function bindHandlers(){var _this=this;var touchStartIgnores=1;if(this.isTouch){this.listenTo($(document),{touchmove:this.handleTouchMove,touchend:this.endInteraction,touchcancel:this.endInteraction,// Sometimes touchend doesn't fire
// (can't figure out why. touchcancel doesn't fire either. has to do with scrolling?)
// If another touchstart happens, we know it's bogus, so cancel the drag.
// touchend will continue to be broken until user does a shorttap/scroll, but this is best we can do.
touchstart:function touchstart(ev){if(touchStartIgnores){// bindHandlers is called from within a touchstart,
touchStartIgnores--;// and we don't want this to fire immediately, so ignore.
}else{_this.endInteraction(ev,true);// isCancelled=true
}}});// listen to ALL scroll actions on the page
if(!bindAnyScroll(this.handleTouchScrollProxy)&&// hopefully this works and short-circuits the rest
this.scrollEl// otherwise, attach a single handler to this
){this.listenTo(this.scrollEl,'scroll',this.handleTouchScroll);}}else{this.listenTo($(document),{mousemove:this.handleMouseMove,mouseup:this.endInteraction});}this.listenTo($(document),{selectstart:preventDefault,// don't allow selection while dragging
contextmenu:preventDefault// long taps would open menu on Chrome dev tools
});},unbindHandlers:function unbindHandlers(){this.stopListeningTo($(document));// unbind scroll listening
unbindAnyScroll(this.handleTouchScrollProxy);if(this.scrollEl){this.stopListeningTo(this.scrollEl,'scroll');}},// Drag (high-level)
// -----------------------------------------------------------------------------------------------------------------
// extraOptions ignored if drag already started
startDrag:function startDrag(ev,extraOptions){this.startInteraction(ev,extraOptions);// ensure interaction began
if(!this.isDragging){this.isDragging=true;this.handleDragStart(ev);}},handleDragStart:function handleDragStart(ev){this.trigger('dragStart',ev);this.initHrefHack();},handleMove:function handleMove(ev){var dx=getEvX(ev)-this.originX;var dy=getEvY(ev)-this.originY;var minDistance=this.minDistance;var distanceSq;// current distance from the origin, squared
if(!this.isDistanceSurpassed){distanceSq=dx*dx+dy*dy;if(distanceSq>=minDistance*minDistance){// use pythagorean theorem
this.handleDistanceSurpassed(ev);}}if(this.isDragging){this.handleDrag(dx,dy,ev);}},// Called while the mouse is being moved and when we know a legitimate drag is taking place
handleDrag:function handleDrag(dx,dy,ev){this.trigger('drag',dx,dy,ev);this.updateAutoScroll(ev);// will possibly cause scrolling
},endDrag:function endDrag(ev){if(this.isDragging){this.isDragging=false;this.handleDragEnd(ev);}},handleDragEnd:function handleDragEnd(ev){this.trigger('dragEnd',ev);this.destroyHrefHack();},// Delay
// -----------------------------------------------------------------------------------------------------------------
startDelay:function startDelay(initialEv){var _this=this;if(this.delay){this.delayTimeoutId=setTimeout(function(){_this.handleDelayEnd(initialEv);},this.delay);}else{this.handleDelayEnd(initialEv);}},handleDelayEnd:function handleDelayEnd(initialEv){this.isDelayEnded=true;if(this.isDistanceSurpassed){this.startDrag(initialEv);}},// Distance
// -----------------------------------------------------------------------------------------------------------------
handleDistanceSurpassed:function handleDistanceSurpassed(ev){this.isDistanceSurpassed=true;if(this.isDelayEnded){this.startDrag(ev);}},// Mouse / Touch
// -----------------------------------------------------------------------------------------------------------------
handleTouchMove:function handleTouchMove(ev){// prevent inertia and touchmove-scrolling while dragging
if(this.isDragging){ev.preventDefault();}this.handleMove(ev);},handleMouseMove:function handleMouseMove(ev){this.handleMove(ev);},// Scrolling (unrelated to auto-scroll)
// -----------------------------------------------------------------------------------------------------------------
handleTouchScroll:function handleTouchScroll(ev){// if the drag is being initiated by touch, but a scroll happens before
// the drag-initiating delay is over, cancel the drag
if(!this.isDragging){this.endInteraction(ev,true);// isCancelled=true
}},// <A> HREF Hack
// -----------------------------------------------------------------------------------------------------------------
initHrefHack:function initHrefHack(){var subjectEl=this.subjectEl;// remove a mousedown'd <a>'s href so it is not visited (IE8 bug)
if(this.subjectHref=subjectEl?subjectEl.attr('href'):null){subjectEl.removeAttr('href');}},destroyHrefHack:function destroyHrefHack(){var subjectEl=this.subjectEl;var subjectHref=this.subjectHref;// restore a mousedown'd <a>'s href (for IE8 bug)
setTimeout(function(){// must be outside of the click's execution
if(subjectHref){subjectEl.attr('href',subjectHref);}},0);},// Utils
// -----------------------------------------------------------------------------------------------------------------
// Triggers a callback. Calls a function in the option hash of the same name.
// Arguments beyond the first `name` are forwarded on.
trigger:function trigger(name){if(this.options[name]){this.options[name].apply(this,Array.prototype.slice.call(arguments,1));}// makes _methods callable by event name. TODO: kill this
if(this['_'+name]){this['_'+name].apply(this,Array.prototype.slice.call(arguments,1));}}});;;/*
this.scrollEl is set in DragListener
*/DragListener.mixin({isAutoScroll:false,scrollBounds:null,// { top, bottom, left, right }
scrollTopVel:null,// pixels per second
scrollLeftVel:null,// pixels per second
scrollIntervalId:null,// ID of setTimeout for scrolling animation loop
// defaults
scrollSensitivity:30,// pixels from edge for scrolling to start
scrollSpeed:200,// pixels per second, at maximum speed
scrollIntervalMs:50,// millisecond wait between scroll increment
initAutoScroll:function initAutoScroll(){var scrollEl=this.scrollEl;this.isAutoScroll=this.options.scroll&&scrollEl&&!scrollEl.is(window)&&!scrollEl.is(document);if(this.isAutoScroll){// debounce makes sure rapid calls don't happen
this.listenTo(scrollEl,'scroll',debounce(this.handleDebouncedScroll,100));}},destroyAutoScroll:function destroyAutoScroll(){this.endAutoScroll();// kill any animation loop
// remove the scroll handler if there is a scrollEl
if(this.isAutoScroll){this.stopListeningTo(this.scrollEl,'scroll');// will probably get removed by unbindHandlers too :(
}},// Computes and stores the bounding rectangle of scrollEl
computeScrollBounds:function computeScrollBounds(){if(this.isAutoScroll){this.scrollBounds=getOuterRect(this.scrollEl);// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
}},// Called when the dragging is in progress and scrolling should be updated
updateAutoScroll:function updateAutoScroll(ev){var sensitivity=this.scrollSensitivity;var bounds=this.scrollBounds;var topCloseness,bottomCloseness;var leftCloseness,rightCloseness;var topVel=0;var leftVel=0;if(bounds){// only scroll if scrollEl exists
// compute closeness to edges. valid range is from 0.0 - 1.0
topCloseness=(sensitivity-(getEvY(ev)-bounds.top))/sensitivity;bottomCloseness=(sensitivity-(bounds.bottom-getEvY(ev)))/sensitivity;leftCloseness=(sensitivity-(getEvX(ev)-bounds.left))/sensitivity;rightCloseness=(sensitivity-(bounds.right-getEvX(ev)))/sensitivity;// translate vertical closeness into velocity.
// mouse must be completely in bounds for velocity to happen.
if(topCloseness>=0&&topCloseness<=1){topVel=topCloseness*this.scrollSpeed*-1;// negative. for scrolling up
}else if(bottomCloseness>=0&&bottomCloseness<=1){topVel=bottomCloseness*this.scrollSpeed;}// translate horizontal closeness into velocity
if(leftCloseness>=0&&leftCloseness<=1){leftVel=leftCloseness*this.scrollSpeed*-1;// negative. for scrolling left
}else if(rightCloseness>=0&&rightCloseness<=1){leftVel=rightCloseness*this.scrollSpeed;}}this.setScrollVel(topVel,leftVel);},// Sets the speed-of-scrolling for the scrollEl
setScrollVel:function setScrollVel(topVel,leftVel){this.scrollTopVel=topVel;this.scrollLeftVel=leftVel;this.constrainScrollVel();// massages into realistic values
// if there is non-zero velocity, and an animation loop hasn't already started, then START
if((this.scrollTopVel||this.scrollLeftVel)&&!this.scrollIntervalId){this.scrollIntervalId=setInterval(proxy(this,'scrollIntervalFunc'),// scope to `this`
this.scrollIntervalMs);}},// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
constrainScrollVel:function constrainScrollVel(){var el=this.scrollEl;if(this.scrollTopVel<0){// scrolling up?
if(el.scrollTop()<=0){// already scrolled all the way up?
this.scrollTopVel=0;}}else if(this.scrollTopVel>0){// scrolling down?
if(el.scrollTop()+el[0].clientHeight>=el[0].scrollHeight){// already scrolled all the way down?
this.scrollTopVel=0;}}if(this.scrollLeftVel<0){// scrolling left?
if(el.scrollLeft()<=0){// already scrolled all the left?
this.scrollLeftVel=0;}}else if(this.scrollLeftVel>0){// scrolling right?
if(el.scrollLeft()+el[0].clientWidth>=el[0].scrollWidth){// already scrolled all the way right?
this.scrollLeftVel=0;}}},// This function gets called during every iteration of the scrolling animation loop
scrollIntervalFunc:function scrollIntervalFunc(){var el=this.scrollEl;var frac=this.scrollIntervalMs/1000;// considering animation frequency, what the vel should be mult'd by
// change the value of scrollEl's scroll
if(this.scrollTopVel){el.scrollTop(el.scrollTop()+this.scrollTopVel*frac);}if(this.scrollLeftVel){el.scrollLeft(el.scrollLeft()+this.scrollLeftVel*frac);}this.constrainScrollVel();// since the scroll values changed, recompute the velocities
// if scrolled all the way, which causes the vels to be zero, stop the animation loop
if(!this.scrollTopVel&&!this.scrollLeftVel){this.endAutoScroll();}},// Kills any existing scrolling animation loop
endAutoScroll:function endAutoScroll(){if(this.scrollIntervalId){clearInterval(this.scrollIntervalId);this.scrollIntervalId=null;this.handleScrollEnd();}},// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
handleDebouncedScroll:function handleDebouncedScroll(){// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
if(!this.scrollIntervalId){this.handleScrollEnd();}},// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
handleScrollEnd:function handleScrollEnd(){}});;;/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/var HitDragListener=DragListener.extend({component:null,// converts coordinates to hits
// methods: prepareHits, releaseHits, queryHit
origHit:null,// the hit the mouse was over when listening started
hit:null,// the hit the mouse is over
coordAdjust:null,// delta that will be added to the mouse coordinates when computing collisions
constructor:function constructor(component,options){DragListener.call(this,options);// call the super-constructor
this.component=component;},// Called when drag listening starts (but a real drag has not necessarily began).
// ev might be undefined if dragging was started manually.
handleInteractionStart:function handleInteractionStart(ev){var subjectEl=this.subjectEl;var subjectRect;var origPoint;var point;this.computeCoords();if(ev){origPoint={left:getEvX(ev),top:getEvY(ev)};point=origPoint;// constrain the point to bounds of the element being dragged
if(subjectEl){subjectRect=getOuterRect(subjectEl);// used for centering as well
point=constrainPoint(point,subjectRect);}this.origHit=this.queryHit(point.left,point.top);// treat the center of the subject as the collision point?
if(subjectEl&&this.options.subjectCenter){// only consider the area the subject overlaps the hit. best for large subjects.
// TODO: skip this if hit didn't supply left/right/top/bottom
if(this.origHit){subjectRect=intersectRects(this.origHit,subjectRect)||subjectRect;// in case there is no intersection
}point=getRectCenter(subjectRect);}this.coordAdjust=diffPoints(point,origPoint);// point - origPoint
}else{this.origHit=null;this.coordAdjust=null;}// call the super-method. do it after origHit has been computed
DragListener.prototype.handleInteractionStart.apply(this,arguments);},// Recomputes the drag-critical positions of elements
computeCoords:function computeCoords(){this.component.prepareHits();this.computeScrollBounds();// why is this here??????
},// Called when the actual drag has started
handleDragStart:function handleDragStart(ev){var hit;DragListener.prototype.handleDragStart.apply(this,arguments);// call the super-method
// might be different from this.origHit if the min-distance is large
hit=this.queryHit(getEvX(ev),getEvY(ev));// report the initial hit the mouse is over
// especially important if no min-distance and drag starts immediately
if(hit){this.handleHitOver(hit);}},// Called when the drag moves
handleDrag:function handleDrag(dx,dy,ev){var hit;DragListener.prototype.handleDrag.apply(this,arguments);// call the super-method
hit=this.queryHit(getEvX(ev),getEvY(ev));if(!isHitsEqual(hit,this.hit)){// a different hit than before?
if(this.hit){this.handleHitOut();}if(hit){this.handleHitOver(hit);}}},// Called when dragging has been stopped
handleDragEnd:function handleDragEnd(){this.handleHitDone();DragListener.prototype.handleDragEnd.apply(this,arguments);// call the super-method
},// Called when a the mouse has just moved over a new hit
handleHitOver:function handleHitOver(hit){var isOrig=isHitsEqual(hit,this.origHit);this.hit=hit;this.trigger('hitOver',this.hit,isOrig,this.origHit);},// Called when the mouse has just moved out of a hit
handleHitOut:function handleHitOut(){if(this.hit){this.trigger('hitOut',this.hit);this.handleHitDone();this.hit=null;}},// Called after a hitOut. Also called before a dragStop
handleHitDone:function handleHitDone(){if(this.hit){this.trigger('hitDone',this.hit);}},// Called when the interaction ends, whether there was a real drag or not
handleInteractionEnd:function handleInteractionEnd(){DragListener.prototype.handleInteractionEnd.apply(this,arguments);// call the super-method
this.origHit=null;this.hit=null;this.component.releaseHits();},// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
handleScrollEnd:function handleScrollEnd(){DragListener.prototype.handleScrollEnd.apply(this,arguments);// call the super-method
this.computeCoords();// hits' absolute positions will be in new places. recompute
},// Gets the hit underneath the coordinates for the given mouse event
queryHit:function queryHit(left,top){if(this.coordAdjust){left+=this.coordAdjust.left;top+=this.coordAdjust.top;}return this.component.queryHit(left,top);}});// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0,hit1){if(!hit0&&!hit1){return true;}if(hit0&&hit1){return hit0.component===hit1.component&&isHitPropsWithin(hit0,hit1)&&isHitPropsWithin(hit1,hit0);// ensures all props are identical
}return false;}// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit,superHit){for(var propName in subHit){if(!/^(component|left|right|top|bottom)$/.test(propName)){if(subHit[propName]!==superHit[propName]){return false;}}}return true;};;/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/var MouseFollower=Class.extend(ListenerMixin,{options:null,sourceEl:null,// the element that will be cloned and made to look like it is dragging
el:null,// the clone of `sourceEl` that will track the mouse
parentEl:null,// the element that `el` (the clone) will be attached to
// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
top0:null,left0:null,// the absolute coordinates of the initiating touch/mouse action
y0:null,x0:null,// the number of pixels the mouse has moved from its initial position
topDelta:null,leftDelta:null,isFollowing:false,isHidden:false,isAnimating:false,// doing the revert animation?
constructor:function constructor(sourceEl,options){this.options=options=options||{};this.sourceEl=sourceEl;this.parentEl=options.parentEl?$(options.parentEl):sourceEl.parent();// default to sourceEl's parent
},// Causes the element to start following the mouse
start:function start(ev){if(!this.isFollowing){this.isFollowing=true;this.y0=getEvY(ev);this.x0=getEvX(ev);this.topDelta=0;this.leftDelta=0;if(!this.isHidden){this.updatePosition();}if(getEvIsTouch(ev)){this.listenTo($(document),'touchmove',this.handleMove);}else{this.listenTo($(document),'mousemove',this.handleMove);}}},// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
stop:function stop(shouldRevert,callback){var _this=this;var revertDuration=this.options.revertDuration;function complete(){this.isAnimating=false;_this.removeElement();this.top0=this.left0=null;// reset state for future updatePosition calls
if(callback){callback();}}if(this.isFollowing&&!this.isAnimating){// disallow more than one stop animation at a time
this.isFollowing=false;this.stopListeningTo($(document));if(shouldRevert&&revertDuration&&!this.isHidden){// do a revert animation?
this.isAnimating=true;this.el.animate({top:this.top0,left:this.left0},{duration:revertDuration,complete:complete});}else{complete();}}},// Gets the tracking element. Create it if necessary
getEl:function getEl(){var el=this.el;if(!el){this.sourceEl.width();// hack to force IE8 to compute correct bounding box
el=this.el=this.sourceEl.clone().addClass(this.options.additionalClass||'').css({position:'absolute',visibility:'',// in case original element was hidden (commonly through hideEvents())
display:this.isHidden?'none':'',// for when initially hidden
margin:0,right:'auto',// erase and set width instead
bottom:'auto',// erase and set height instead
width:this.sourceEl.width(),// explicit height in case there was a 'right' value
height:this.sourceEl.height(),// explicit width in case there was a 'bottom' value
opacity:this.options.opacity||'',zIndex:this.options.zIndex});// we don't want long taps or any mouse interaction causing selection/menus.
// would use preventSelection(), but that prevents selectstart, causing problems.
el.addClass('fc-unselectable');el.appendTo(this.parentEl);}return el;},// Removes the tracking element if it has already been created
removeElement:function removeElement(){if(this.el){this.el.remove();this.el=null;}},// Update the CSS position of the tracking element
updatePosition:function updatePosition(){var sourceOffset;var origin;this.getEl();// ensure this.el
// make sure origin info was computed
if(this.top0===null){this.sourceEl.width();// hack to force IE8 to compute correct bounding box
sourceOffset=this.sourceEl.offset();origin=this.el.offsetParent().offset();this.top0=sourceOffset.top-origin.top;this.left0=sourceOffset.left-origin.left;}this.el.css({top:this.top0+this.topDelta,left:this.left0+this.leftDelta});},// Gets called when the user moves the mouse
handleMove:function handleMove(ev){this.topDelta=getEvY(ev)-this.y0;this.leftDelta=getEvX(ev)-this.x0;if(!this.isHidden){this.updatePosition();}},// Temporarily makes the tracking element invisible. Can be called before following starts
hide:function hide(){if(!this.isHidden){this.isHidden=true;if(this.el){this.el.hide();}}},// Show the tracking element after it has been temporarily hidden
show:function show(){if(this.isHidden){this.isHidden=false;this.updatePosition();this.getEl().show();}}});;;/* An abstract class comprised of a "grid" of areas that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/var Grid=FC.Grid=Class.extend(ListenerMixin,MouseIgnorerMixin,{view:null,// a View object
isRTL:null,// shortcut to the view's isRTL option
start:null,end:null,el:null,// the containing element
elsByFill:null,// a hash of jQuery element sets used for rendering each fill. Keyed by fill name.
// derived from options
eventTimeFormat:null,displayEventTime:null,displayEventEnd:null,minResizeDuration:null,// TODO: hack. set by subclasses. minumum event resize duration
// if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
// of the date areas. if not defined, assumes to be day and time granularity.
// TODO: port isTimeScale into same system?
largeUnit:null,dayDragListener:null,segDragListener:null,segResizeListener:null,externalDragListener:null,constructor:function constructor(view){this.view=view;this.isRTL=view.opt('isRTL');this.elsByFill={};this.dayDragListener=this.buildDayDragListener();this.initMouseIgnoring();},/* Options
	------------------------------------------------------------------------------------------------------------------*/// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
computeEventTimeFormat:function computeEventTimeFormat(){return this.view.opt('smallTimeFormat');},// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
// Only applies to non-all-day events.
computeDisplayEventTime:function computeDisplayEventTime(){return true;},// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
computeDisplayEventEnd:function computeDisplayEventEnd(){return true;},/* Dates
	------------------------------------------------------------------------------------------------------------------*/// Tells the grid about what period of time to display.
// Any date-related internal data should be generated.
setRange:function setRange(range){this.start=range.start.clone();this.end=range.end.clone();this.rangeUpdated();this.processRangeOptions();},// Called when internal variables that rely on the range should be updated
rangeUpdated:function rangeUpdated(){},// Updates values that rely on options and also relate to range
processRangeOptions:function processRangeOptions(){var view=this.view;var displayEventTime;var displayEventEnd;this.eventTimeFormat=view.opt('eventTimeFormat')||view.opt('timeFormat')||// deprecated
this.computeEventTimeFormat();displayEventTime=view.opt('displayEventTime');if(displayEventTime==null){displayEventTime=this.computeDisplayEventTime();// might be based off of range
}displayEventEnd=view.opt('displayEventEnd');if(displayEventEnd==null){displayEventEnd=this.computeDisplayEventEnd();// might be based off of range
}this.displayEventTime=displayEventTime;this.displayEventEnd=displayEventEnd;},// Converts a span (has unzoned start/end and any other grid-specific location information)
// into an array of segments (pieces of events whose format is decided by the grid).
spanToSegs:function spanToSegs(span){// subclasses must implement
},// Diffs the two dates, returning a duration, based on granularity of the grid
// TODO: port isTimeScale into this system?
diffDates:function diffDates(a,b){if(this.largeUnit){return diffByUnit(a,b,this.largeUnit);}else{return diffDayTime(a,b);}},/* Hit Area
	------------------------------------------------------------------------------------------------------------------*/// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
prepareHits:function prepareHits(){},// Called when queryHit calls have subsided. Good place to clear any coordinate caches.
releaseHits:function releaseHits(){},// Given coordinates from the topleft of the document, return data about the date-related area underneath.
// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
// Must have a `grid` property, a reference to this current grid. TODO: avoid this
// The returned object will be processed by getHitSpan and getHitEl.
queryHit:function queryHit(leftOffset,topOffset){},// Given position-level information about a date-related area within the grid,
// should return an object with at least a start/end date. Can provide other information as well.
getHitSpan:function getHitSpan(hit){},// Given position-level information about a date-related area within the grid,
// should return a jQuery element that best represents it. passed to dayClick callback.
getHitEl:function getHitEl(hit){},/* Rendering
	------------------------------------------------------------------------------------------------------------------*/// Sets the container element that the grid should render inside of.
// Does other DOM-related initializations.
setElement:function setElement(el){this.el=el;preventSelection(el);this.bindDayHandler('touchstart',this.dayTouchStart);this.bindDayHandler('mousedown',this.dayMousedown);// attach event-element-related handlers. in Grid.events
// same garbage collection note as above.
this.bindSegHandlers();this.bindGlobalHandlers();},bindDayHandler:function bindDayHandler(name,handler){var _this=this;// attach a handler to the grid's root element.
// jQuery will take care of unregistering them when removeElement gets called.
this.el.on(name,function(ev){if(!$(ev.target).is('.fc-event-container *, .fc-more')&&// not an an event element, or "more.." link
!$(ev.target).closest('.fc-popover').length// not on a popover (like the "more.." events one)
){return handler.call(_this,ev);}});},// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
removeElement:function removeElement(){this.unbindGlobalHandlers();this.clearDragListeners();this.el.remove();// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
},// Renders the basic structure of grid view before any content is rendered
renderSkeleton:function renderSkeleton(){// subclasses should implement
},// Renders the grid's date-related content (like areas that represent days/times).
// Assumes setRange has already been called and the skeleton has already been rendered.
renderDates:function renderDates(){// subclasses should implement
},// Unrenders the grid's date-related content
unrenderDates:function unrenderDates(){// subclasses should implement
},/* Handlers
	------------------------------------------------------------------------------------------------------------------*/// Binds DOM handlers to elements that reside outside the grid, such as the document
bindGlobalHandlers:function bindGlobalHandlers(){this.listenTo($(document),{dragstart:this.externalDragStart,// jqui
sortstart:this.externalDragStart// jqui
});},// Unbinds DOM handlers from elements that reside outside the grid
unbindGlobalHandlers:function unbindGlobalHandlers(){this.stopListeningTo($(document));},// Process a mousedown on an element that represents a day. For day clicking and selecting.
dayMousedown:function dayMousedown(ev){if(!this.isIgnoringMouse){this.dayDragListener.startInteraction(ev,{//distance: 5, // needs more work if we want dayClick to fire correctly
});}},dayTouchStart:function dayTouchStart(ev){var view=this.view;// HACK to prevent a user's clickaway for unselecting a range or an event
// from causing a dayClick.
if(view.isSelected||view.selectedEvent){this.tempIgnoreMouse();}this.dayDragListener.startInteraction(ev,{delay:this.view.opt('longPressDelay')});},// Creates a listener that tracks the user's drag across day elements.
// For day clicking and selecting.
buildDayDragListener:function buildDayDragListener(){var _this=this;var view=this.view;var isSelectable=view.opt('selectable');var dayClickHit;// null if invalid dayClick
var selectionSpan;// null if invalid selection
// this listener tracks a mousedown on a day element, and a subsequent drag.
// if the drag ends on the same day, it is a 'dayClick'.
// if 'selectable' is enabled, this listener also detects selections.
var dragListener=new HitDragListener(this,{scroll:view.opt('dragScroll'),interactionStart:function interactionStart(){dayClickHit=dragListener.origHit;// for dayClick, where no dragging happens
},dragStart:function dragStart(){view.unselect();// since we could be rendering a new selection, we want to clear any old one
},hitOver:function hitOver(hit,isOrig,origHit){if(origHit){// click needs to have started on a hit
// if user dragged to another cell at any point, it can no longer be a dayClick
if(!isOrig){dayClickHit=null;}if(isSelectable){selectionSpan=_this.computeSelection(_this.getHitSpan(origHit),_this.getHitSpan(hit));if(selectionSpan){_this.renderSelection(selectionSpan);}else if(selectionSpan===false){disableCursor();}}}},hitOut:function hitOut(){dayClickHit=null;selectionSpan=null;_this.unrenderSelection();enableCursor();},interactionEnd:function interactionEnd(ev,isCancelled){if(!isCancelled){if(dayClickHit&&!_this.isIgnoringMouse// see hack in dayTouchStart
){view.triggerDayClick(_this.getHitSpan(dayClickHit),_this.getHitEl(dayClickHit),ev);}if(selectionSpan){// the selection will already have been rendered. just report it
view.reportSelection(selectionSpan,ev);}enableCursor();}}});return dragListener;},// Kills all in-progress dragging.
// Useful for when public API methods that result in re-rendering are invoked during a drag.
// Also useful for when touch devices misbehave and don't fire their touchend.
clearDragListeners:function clearDragListeners(){this.dayDragListener.endInteraction();if(this.segDragListener){this.segDragListener.endInteraction();// will clear this.segDragListener
}if(this.segResizeListener){this.segResizeListener.endInteraction();// will clear this.segResizeListener
}if(this.externalDragListener){this.externalDragListener.endInteraction();// will clear this.externalDragListener
}},/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/// TODO: should probably move this to Grid.events, like we did event dragging / resizing
// Renders a mock event at the given event location, which contains zoned start/end properties.
// Returns all mock event elements.
renderEventLocationHelper:function renderEventLocationHelper(eventLocation,sourceSeg){var fakeEvent=this.fabricateHelperEvent(eventLocation,sourceSeg);return this.renderHelper(fakeEvent,sourceSeg);// do the actual rendering
},// Builds a fake event given zoned event date properties and a segment is should be inspired from.
// The range's end can be null, in which case the mock event that is rendered will have a null end time.
// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
fabricateHelperEvent:function fabricateHelperEvent(eventLocation,sourceSeg){var fakeEvent=sourceSeg?createObject(sourceSeg.event):{};// mask the original event object if possible
fakeEvent.start=eventLocation.start.clone();fakeEvent.end=eventLocation.end?eventLocation.end.clone():null;fakeEvent.allDay=null;// force it to be freshly computed by normalizeEventDates
this.view.calendar.normalizeEventDates(fakeEvent);// this extra className will be useful for differentiating real events from mock events in CSS
fakeEvent.className=(fakeEvent.className||[]).concat('fc-helper');// if something external is being dragged in, don't render a resizer
if(!sourceSeg){fakeEvent.editable=false;}return fakeEvent;},// Renders a mock event. Given zoned event date properties.
// Must return all mock event elements.
renderHelper:function renderHelper(eventLocation,sourceSeg){// subclasses must implement
},// Unrenders a mock event
unrenderHelper:function unrenderHelper(){// subclasses must implement
},/* Selection
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
// Given a span (unzoned start/end and other misc data)
renderSelection:function renderSelection(span){this.renderHighlight(span);},// Unrenders any visual indications of a selection. Will unrender a highlight by default.
unrenderSelection:function unrenderSelection(){this.unrenderHighlight();},// Given the first and last date-spans of a selection, returns another date-span object.
// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
// Will return false if the selection is invalid and this should be indicated to the user.
// Will return null/undefined if a selection invalid but no error should be reported.
computeSelection:function computeSelection(span0,span1){var span=this.computeSelectionSpan(span0,span1);if(span&&!this.view.calendar.isSelectionSpanAllowed(span)){return false;}return span;},// Given two spans, must return the combination of the two.
// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
computeSelectionSpan:function computeSelectionSpan(span0,span1){var dates=[span0.start,span0.end,span1.start,span1.end];dates.sort(compareNumbers);// sorts chronologically. works with Moments
return{start:dates[0].clone(),end:dates[3].clone()};},/* Highlight
	------------------------------------------------------------------------------------------------------------------*/// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
renderHighlight:function renderHighlight(span){this.renderFill('highlight',this.spanToSegs(span));},// Unrenders the emphasis on a date range
unrenderHighlight:function unrenderHighlight(){this.unrenderFill('highlight');},// Generates an array of classNames for rendering the highlight. Used by the fill system.
highlightSegClasses:function highlightSegClasses(){return['fc-highlight'];},/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/renderBusinessHours:function renderBusinessHours(){},unrenderBusinessHours:function unrenderBusinessHours(){},/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/getNowIndicatorUnit:function getNowIndicatorUnit(){},renderNowIndicator:function renderNowIndicator(date){},unrenderNowIndicator:function unrenderNowIndicator(){},/* Fill System (highlight, background events, business hours)
	--------------------------------------------------------------------------------------------------------------------
	TODO: remove this system. like we did in TimeGrid
	*/// Renders a set of rectangles over the given segments of time.
// MUST RETURN a subset of segs, the segs that were actually rendered.
// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
renderFill:function renderFill(type,segs){// subclasses must implement
},// Unrenders a specific type of fill that is currently rendered on the grid
unrenderFill:function unrenderFill(type){var el=this.elsByFill[type];if(el){el.remove();delete this.elsByFill[type];}},// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
// Only returns segments that successfully rendered.
// To be harnessed by renderFill (implemented by subclasses).
// Analagous to renderFgSegEls.
renderFillSegEls:function renderFillSegEls(type,segs){var _this=this;var segElMethod=this[type+'SegEl'];var html='';var renderedSegs=[];var i;if(segs.length){// build a large concatenation of segment HTML
for(i=0;i<segs.length;i++){html+=this.fillSegHtml(type,segs[i]);}// Grab individual elements from the combined HTML string. Use each as the default rendering.
// Then, compute the 'el' for each segment.
$(html).each(function(i,node){var seg=segs[i];var el=$(node);// allow custom filter methods per-type
if(segElMethod){el=segElMethod.call(_this,seg,el);}if(el){// custom filters did not cancel the render
el=$(el);// allow custom filter to return raw DOM node
// correct element type? (would be bad if a non-TD were inserted into a table for example)
if(el.is(_this.fillSegTag)){seg.el=el;renderedSegs.push(seg);}}});}return renderedSegs;},fillSegTag:'div',// subclasses can override
// Builds the HTML needed for one fill segment. Generic enough to work with different types.
fillSegHtml:function fillSegHtml(type,seg){// custom hooks per-type
var classesMethod=this[type+'SegClasses'];var cssMethod=this[type+'SegCss'];var classes=classesMethod?classesMethod.call(this,seg):[];var css=cssToStr(cssMethod?cssMethod.call(this,seg):{});return'<'+this.fillSegTag+(classes.length?' class="'+classes.join(' ')+'"':'')+(css?' style="'+css+'"':'')+' />';},/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/// Computes HTML classNames for a single-day element
getDayClasses:function getDayClasses(date){var view=this.view;var today=view.calendar.getNow();var classes=['fc-'+dayIDs[date.day()]];if(view.intervalDuration.as('months')==1&&date.month()!=view.intervalStart.month()){classes.push('fc-other-month');}if(date.isSame(today,'day')){classes.push('fc-today',view.highlightStateClass);}else if(date<today){classes.push('fc-past');}else{classes.push('fc-future');}return classes;}});;;/* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------*/Grid.mixin({mousedOverSeg:null,// the segment object the user's mouse is over. null if over nothing
isDraggingSeg:false,// is a segment being dragged? boolean
isResizingSeg:false,// is a segment being resized? boolean
isDraggingExternal:false,// jqui-dragging an external element? boolean
segs:null,// the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`
// Renders the given events onto the grid
renderEvents:function renderEvents(events){var bgEvents=[];var fgEvents=[];var i;for(i=0;i<events.length;i++){(isBgEvent(events[i])?bgEvents:fgEvents).push(events[i]);}this.segs=[].concat(// record all segs
this.renderBgEvents(bgEvents),this.renderFgEvents(fgEvents));},renderBgEvents:function renderBgEvents(events){var segs=this.eventsToSegs(events);// renderBgSegs might return a subset of segs, segs that were actually rendered
return this.renderBgSegs(segs)||segs;},renderFgEvents:function renderFgEvents(events){var segs=this.eventsToSegs(events);// renderFgSegs might return a subset of segs, segs that were actually rendered
return this.renderFgSegs(segs)||segs;},// Unrenders all events currently rendered on the grid
unrenderEvents:function unrenderEvents(){this.handleSegMouseout();// trigger an eventMouseout if user's mouse is over an event
this.clearDragListeners();this.unrenderFgSegs();this.unrenderBgSegs();this.segs=null;},// Retrieves all rendered segment objects currently rendered on the grid
getEventSegs:function getEventSegs(){return this.segs||[];},/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
renderFgSegs:function renderFgSegs(segs){// subclasses must implement
},// Unrenders all currently rendered foreground segments
unrenderFgSegs:function unrenderFgSegs(){// subclasses must implement
},// Renders and assigns an `el` property for each foreground event segment.
// Only returns segments that successfully rendered.
// A utility that subclasses may use.
renderFgSegEls:function renderFgSegEls(segs,disableResizing){var view=this.view;var html='';var renderedSegs=[];var i;if(segs.length){// don't build an empty html string
// build a large concatenation of event segment HTML
for(i=0;i<segs.length;i++){html+=this.fgSegHtml(segs[i],disableResizing);}// Grab individual elements from the combined HTML string. Use each as the default rendering.
// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
$(html).each(function(i,node){var seg=segs[i];var el=view.resolveEventEl(seg.event,$(node));if(el){el.data('fc-seg',seg);// used by handlers
seg.el=el;renderedSegs.push(seg);}});}return renderedSegs;},// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
fgSegHtml:function fgSegHtml(seg,disableResizing){// subclasses should implement
},/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/// Renders the given background event segments onto the grid.
// Returns a subset of the segs that were actually rendered.
renderBgSegs:function renderBgSegs(segs){return this.renderFill('bgEvent',segs);},// Unrenders all the currently rendered background event segments
unrenderBgSegs:function unrenderBgSegs(){this.unrenderFill('bgEvent');},// Renders a background event element, given the default rendering. Called by the fill system.
bgEventSegEl:function bgEventSegEl(seg,el){return this.view.resolveEventEl(seg.event,el);// will filter through eventRender
},// Generates an array of classNames to be used for the default rendering of a background event.
// Called by the fill system.
bgEventSegClasses:function bgEventSegClasses(seg){var event=seg.event;var source=event.source||{};return['fc-bgevent'].concat(event.className,source.className||[]);},// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
// Called by the fill system.
bgEventSegCss:function bgEventSegCss(seg){return{'background-color':this.getSegSkinCss(seg)['background-color']};},// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
businessHoursSegClasses:function businessHoursSegClasses(seg){return['fc-nonbusiness','fc-bgevent'];},/* Handlers
	------------------------------------------------------------------------------------------------------------------*/// Attaches event-element-related handlers to the container element and leverage bubbling
bindSegHandlers:function bindSegHandlers(){this.bindSegHandler('touchstart',this.handleSegTouchStart);this.bindSegHandler('touchend',this.handleSegTouchEnd);this.bindSegHandler('mouseenter',this.handleSegMouseover);this.bindSegHandler('mouseleave',this.handleSegMouseout);this.bindSegHandler('mousedown',this.handleSegMousedown);this.bindSegHandler('click',this.handleSegClick);},// Executes a handler for any a user-interaction on a segment.
// Handler gets called with (seg, ev), and with the `this` context of the Grid
bindSegHandler:function bindSegHandler(name,handler){var _this=this;this.el.on(name,'.fc-event-container > *',function(ev){var seg=$(this).data('fc-seg');// grab segment data. put there by View::renderEvents
// only call the handlers if there is not a drag/resize in progress
if(seg&&!_this.isDraggingSeg&&!_this.isResizingSeg){return handler.call(_this,seg,ev);// context will be the Grid
}});},handleSegClick:function handleSegClick(seg,ev){return this.view.trigger('eventClick',seg.el[0],seg.event,ev);// can return `false` to cancel
},// Updates internal state and triggers handlers for when an event element is moused over
handleSegMouseover:function handleSegMouseover(seg,ev){if(!this.isIgnoringMouse&&!this.mousedOverSeg){this.mousedOverSeg=seg;seg.el.addClass('fc-allow-mouse-resize');this.view.trigger('eventMouseover',seg.el[0],seg.event,ev);}},// Updates internal state and triggers handlers for when an event element is moused out.
// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
handleSegMouseout:function handleSegMouseout(seg,ev){ev=ev||{};// if given no args, make a mock mouse event
if(this.mousedOverSeg){seg=seg||this.mousedOverSeg;// if given no args, use the currently moused-over segment
this.mousedOverSeg=null;seg.el.removeClass('fc-allow-mouse-resize');this.view.trigger('eventMouseout',seg.el[0],seg.event,ev);}},handleSegMousedown:function handleSegMousedown(seg,ev){var isResizing=this.startSegResize(seg,ev,{distance:5});if(!isResizing&&this.view.isEventDraggable(seg.event)){this.buildSegDragListener(seg).startInteraction(ev,{distance:5});}},handleSegTouchStart:function handleSegTouchStart(seg,ev){var view=this.view;var event=seg.event;var isSelected=view.isEventSelected(event);var isDraggable=view.isEventDraggable(event);var isResizable=view.isEventResizable(event);var isResizing=false;var dragListener;if(isSelected&&isResizable){// only allow resizing of the event is selected
isResizing=this.startSegResize(seg,ev);}if(!isResizing&&(isDraggable||isResizable)){// allowed to be selected?
dragListener=isDraggable?this.buildSegDragListener(seg):this.buildSegSelectListener(seg);// seg isn't draggable, but still needs to be selected
dragListener.startInteraction(ev,{// won't start if already started
delay:isSelected?0:this.view.opt('longPressDelay')// do delay if not already selected
});}// a long tap simulates a mouseover. ignore this bogus mouseover.
this.tempIgnoreMouse();},handleSegTouchEnd:function handleSegTouchEnd(seg,ev){// touchstart+touchend = click, which simulates a mouseover.
// ignore this bogus mouseover.
this.tempIgnoreMouse();},// returns boolean whether resizing actually started or not.
// assumes the seg allows resizing.
// `dragOptions` are optional.
startSegResize:function startSegResize(seg,ev,dragOptions){if($(ev.target).is('.fc-resizer')){this.buildSegResizeListener(seg,$(ev.target).is('.fc-start-resizer')).startInteraction(ev,dragOptions);return true;}return false;},/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/// Builds a listener that will track user-dragging on an event segment.
// Generic enough to work with any type of Grid.
// Has side effect of setting/unsetting `segDragListener`
buildSegDragListener:function buildSegDragListener(seg){var _this=this;var view=this.view;var calendar=view.calendar;var el=seg.el;var event=seg.event;var isDragging;var mouseFollower;// A clone of the original element that will move with the mouse
var dropLocation;// zoned event date properties
if(this.segDragListener){return this.segDragListener;}// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
// of the view.
var dragListener=this.segDragListener=new HitDragListener(view,{scroll:view.opt('dragScroll'),subjectEl:el,subjectCenter:true,interactionStart:function interactionStart(ev){isDragging=false;mouseFollower=new MouseFollower(seg.el,{additionalClass:'fc-dragging',parentEl:view.el,opacity:dragListener.isTouch?null:view.opt('dragOpacity'),revertDuration:view.opt('dragRevertDuration'),zIndex:2// one above the .fc-view
});mouseFollower.hide();// don't show until we know this is a real drag
mouseFollower.start(ev);},dragStart:function dragStart(ev){if(dragListener.isTouch&&!view.isEventSelected(event)){// if not previously selected, will fire after a delay. then, select the event
view.selectEvent(event);}isDragging=true;_this.handleSegMouseout(seg,ev);// ensure a mouseout on the manipulated event has been reported
_this.segDragStart(seg,ev);view.hideEvent(event);// hide all event segments. our mouseFollower will take over
},hitOver:function hitOver(hit,isOrig,origHit){var dragHelperEls;// starting hit could be forced (DayGrid.limit)
if(seg.hit){origHit=seg.hit;}// since we are querying the parent view, might not belong to this grid
dropLocation=_this.computeEventDrop(origHit.component.getHitSpan(origHit),hit.component.getHitSpan(hit),event);if(dropLocation&&!calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation),event)){disableCursor();dropLocation=null;}// if a valid drop location, have the subclass render a visual indication
if(dropLocation&&(dragHelperEls=view.renderDrag(dropLocation,seg))){dragHelperEls.addClass('fc-dragging');if(!dragListener.isTouch){_this.applyDragOpacity(dragHelperEls);}mouseFollower.hide();// if the subclass is already using a mock event "helper", hide our own
}else{mouseFollower.show();// otherwise, have the helper follow the mouse (no snapping)
}if(isOrig){dropLocation=null;// needs to have moved hits to be a valid drop
}},hitOut:function hitOut(){// called before mouse moves to a different hit OR moved out of all hits
view.unrenderDrag();// unrender whatever was done in renderDrag
mouseFollower.show();// show in case we are moving out of all hits
dropLocation=null;},hitDone:function hitDone(){// Called after a hitOut OR before a dragEnd
enableCursor();},interactionEnd:function interactionEnd(ev){// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
mouseFollower.stop(!dropLocation,function(){if(isDragging){view.unrenderDrag();view.showEvent(event);_this.segDragStop(seg,ev);}if(dropLocation){view.reportEventDrop(event,dropLocation,this.largeUnit,el,ev);}});_this.segDragListener=null;}});return dragListener;},// seg isn't draggable, but let's use a generic DragListener
// simply for the delay, so it can be selected.
// Has side effect of setting/unsetting `segDragListener`
buildSegSelectListener:function buildSegSelectListener(seg){var _this=this;var view=this.view;var event=seg.event;if(this.segDragListener){return this.segDragListener;}var dragListener=this.segDragListener=new DragListener({dragStart:function dragStart(ev){if(dragListener.isTouch&&!view.isEventSelected(event)){// if not previously selected, will fire after a delay. then, select the event
view.selectEvent(event);}},interactionEnd:function interactionEnd(ev){_this.segDragListener=null;}});return dragListener;},// Called before event segment dragging starts
segDragStart:function segDragStart(seg,ev){this.isDraggingSeg=true;this.view.trigger('eventDragStart',seg.el[0],seg.event,ev,{});// last argument is jqui dummy
},// Called after event segment dragging stops
segDragStop:function segDragStop(seg,ev){this.isDraggingSeg=false;this.view.trigger('eventDragStop',seg.el[0],seg.event,ev,{});// last argument is jqui dummy
},// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
// A falsy returned value indicates an invalid drop.
// DOES NOT consider overlap/constraint.
computeEventDrop:function computeEventDrop(startSpan,endSpan,event){var calendar=this.view.calendar;var dragStart=startSpan.start;var dragEnd=endSpan.start;var delta;var dropLocation;// zoned event date properties
if(dragStart.hasTime()===dragEnd.hasTime()){delta=this.diffDates(dragEnd,dragStart);// if an all-day event was in a timed area and it was dragged to a different time,
// guarantee an end and adjust start/end to have times
if(event.allDay&&durationHasTime(delta)){dropLocation={start:event.start.clone(),end:calendar.getEventEnd(event),// will be an ambig day
allDay:false// for normalizeEventTimes
};calendar.normalizeEventTimes(dropLocation);}// othewise, work off existing values
else{dropLocation={start:event.start.clone(),end:event.end?event.end.clone():null,allDay:event.allDay// keep it the same
};}dropLocation.start.add(delta);if(dropLocation.end){dropLocation.end.add(delta);}}else{// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
dropLocation={start:dragEnd.clone(),end:null,// end should be cleared
allDay:!dragEnd.hasTime()};}return dropLocation;},// Utility for apply dragOpacity to a jQuery set
applyDragOpacity:function applyDragOpacity(els){var opacity=this.view.opt('dragOpacity');if(opacity!=null){els.each(function(i,node){// Don't use jQuery (will set an IE filter), do it the old fashioned way.
// In IE8, a helper element will disappears if there's a filter.
node.style.opacity=opacity;});}},/* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/// Called when a jQuery UI drag is initiated anywhere in the DOM
externalDragStart:function externalDragStart(ev,ui){var view=this.view;var el;var accept;if(view.opt('droppable')){// only listen if this setting is on
el=$((ui?ui.item:null)||ev.target);// Test that the dragged element passes the dropAccept selector or filter function.
// FYI, the default is "*" (matches all)
accept=view.opt('dropAccept');if($.isFunction(accept)?accept.call(el[0],el):el.is(accept)){if(!this.isDraggingExternal){// prevent double-listening if fired twice
this.listenToExternalDrag(el,ev,ui);}}}},// Called when a jQuery UI drag starts and it needs to be monitored for dropping
listenToExternalDrag:function listenToExternalDrag(el,ev,ui){var _this=this;var calendar=this.view.calendar;var meta=getDraggedElMeta(el);// extra data about event drop, including possible event to create
var dropLocation;// a null value signals an unsuccessful drag
// listener that tracks mouse movement over date-associated pixel regions
var dragListener=_this.externalDragListener=new HitDragListener(this,{interactionStart:function interactionStart(){_this.isDraggingExternal=true;},hitOver:function hitOver(hit){dropLocation=_this.computeExternalDrop(hit.component.getHitSpan(hit),// since we are querying the parent view, might not belong to this grid
meta);if(// invalid hit?
dropLocation&&!calendar.isExternalSpanAllowed(_this.eventToSpan(dropLocation),dropLocation,meta.eventProps)){disableCursor();dropLocation=null;}if(dropLocation){_this.renderDrag(dropLocation);// called without a seg parameter
}},hitOut:function hitOut(){dropLocation=null;// signal unsuccessful
},hitDone:function hitDone(){// Called after a hitOut OR before a dragEnd
enableCursor();_this.unrenderDrag();},interactionEnd:function interactionEnd(ev){if(dropLocation){// element was dropped on a valid hit
_this.view.reportExternalDrop(meta,dropLocation,el,ev,ui);}_this.isDraggingExternal=false;_this.externalDragListener=null;}});dragListener.startDrag(ev);// start listening immediately
},// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
// Returning a null value signals an invalid drop hit.
// DOES NOT consider overlap/constraint.
computeExternalDrop:function computeExternalDrop(span,meta){var calendar=this.view.calendar;var dropLocation={start:calendar.applyTimezone(span.start),// simulate a zoned event start date
end:null};// if dropped on an all-day span, and element's metadata specified a time, set it
if(meta.startTime&&!dropLocation.start.hasTime()){dropLocation.start.time(meta.startTime);}if(meta.duration){dropLocation.end=dropLocation.start.clone().add(meta.duration);}return dropLocation;},/* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of an event or external element being dragged.
// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
// A truthy returned value indicates this method has rendered a helper element.
// Must return elements used for any mock events.
renderDrag:function renderDrag(dropLocation,seg){// subclasses must implement
},// Unrenders a visual indication of an event or external element being dragged
unrenderDrag:function unrenderDrag(){// subclasses must implement
},/* Resizing
	------------------------------------------------------------------------------------------------------------------*/// Creates a listener that tracks the user as they resize an event segment.
// Generic enough to work with any type of Grid.
buildSegResizeListener:function buildSegResizeListener(seg,isStart){var _this=this;var view=this.view;var calendar=view.calendar;var el=seg.el;var event=seg.event;var eventEnd=calendar.getEventEnd(event);var isDragging;var resizeLocation;// zoned event date properties. falsy if invalid resize
// Tracks mouse movement over the *grid's* coordinate map
var dragListener=this.segResizeListener=new HitDragListener(this,{scroll:view.opt('dragScroll'),subjectEl:el,interactionStart:function interactionStart(){isDragging=false;},dragStart:function dragStart(ev){isDragging=true;_this.handleSegMouseout(seg,ev);// ensure a mouseout on the manipulated event has been reported
_this.segResizeStart(seg,ev);},hitOver:function hitOver(hit,isOrig,origHit){var origHitSpan=_this.getHitSpan(origHit);var hitSpan=_this.getHitSpan(hit);resizeLocation=isStart?_this.computeEventStartResize(origHitSpan,hitSpan,event):_this.computeEventEndResize(origHitSpan,hitSpan,event);if(resizeLocation){if(!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation),event)){disableCursor();resizeLocation=null;}// no change? (TODO: how does this work with timezones?)
else if(resizeLocation.start.isSame(event.start)&&resizeLocation.end.isSame(eventEnd)){resizeLocation=null;}}if(resizeLocation){view.hideEvent(event);_this.renderEventResize(resizeLocation,seg);}},hitOut:function hitOut(){// called before mouse moves to a different hit OR moved out of all hits
resizeLocation=null;},hitDone:function hitDone(){// resets the rendering to show the original event
_this.unrenderEventResize();view.showEvent(event);enableCursor();},interactionEnd:function interactionEnd(ev){if(isDragging){_this.segResizeStop(seg,ev);}if(resizeLocation){// valid date to resize to?
view.reportEventResize(event,resizeLocation,this.largeUnit,el,ev);}_this.segResizeListener=null;}});return dragListener;},// Called before event segment resizing starts
segResizeStart:function segResizeStart(seg,ev){this.isResizingSeg=true;this.view.trigger('eventResizeStart',seg.el[0],seg.event,ev,{});// last argument is jqui dummy
},// Called after event segment resizing stops
segResizeStop:function segResizeStop(seg,ev){this.isResizingSeg=false;this.view.trigger('eventResizeStop',seg.el[0],seg.event,ev,{});// last argument is jqui dummy
},// Returns new date-information for an event segment being resized from its start
computeEventStartResize:function computeEventStartResize(startSpan,endSpan,event){return this.computeEventResize('start',startSpan,endSpan,event);},// Returns new date-information for an event segment being resized from its end
computeEventEndResize:function computeEventEndResize(startSpan,endSpan,event){return this.computeEventResize('end',startSpan,endSpan,event);},// Returns new zoned date information for an event segment being resized from its start OR end
// `type` is either 'start' or 'end'.
// DOES NOT consider overlap/constraint.
computeEventResize:function computeEventResize(type,startSpan,endSpan,event){var calendar=this.view.calendar;var delta=this.diffDates(endSpan[type],startSpan[type]);var resizeLocation;// zoned event date properties
var defaultDuration;// build original values to work from, guaranteeing a start and end
resizeLocation={start:event.start.clone(),end:calendar.getEventEnd(event),allDay:event.allDay};// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
if(resizeLocation.allDay&&durationHasTime(delta)){resizeLocation.allDay=false;calendar.normalizeEventTimes(resizeLocation);}resizeLocation[type].add(delta);// apply delta to start or end
// if the event was compressed too small, find a new reasonable duration for it
if(!resizeLocation.start.isBefore(resizeLocation.end)){defaultDuration=this.minResizeDuration||(// TODO: hack
event.allDay?calendar.defaultAllDayEventDuration:calendar.defaultTimedEventDuration);if(type=='start'){// resizing the start?
resizeLocation.start=resizeLocation.end.clone().subtract(defaultDuration);}else{// resizing the end?
resizeLocation.end=resizeLocation.start.clone().add(defaultDuration);}}return resizeLocation;},// Renders a visual indication of an event being resized.
// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
// Must return elements used for any mock events.
renderEventResize:function renderEventResize(range,seg){// subclasses must implement
},// Unrenders a visual indication of an event being resized.
unrenderEventResize:function unrenderEventResize(){// subclasses must implement
},/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/// Compute the text that should be displayed on an event's element.
// `range` can be the Event object itself, or something range-like, with at least a `start`.
// If event times are disabled, or the event has no time, will return a blank string.
// If not specified, formatStr will default to the eventTimeFormat setting,
// and displayEnd will default to the displayEventEnd setting.
getEventTimeText:function getEventTimeText(range,formatStr,displayEnd){if(formatStr==null){formatStr=this.eventTimeFormat;}if(displayEnd==null){displayEnd=this.displayEventEnd;}if(this.displayEventTime&&range.start.hasTime()){if(displayEnd&&range.end){return this.view.formatRange(range,formatStr);}else{return range.start.format(formatStr);}}return'';},// Generic utility for generating the HTML classNames for an event segment's element
getSegClasses:function getSegClasses(seg,isDraggable,isResizable){var view=this.view;var event=seg.event;var classes=['fc-event',seg.isStart?'fc-start':'fc-not-start',seg.isEnd?'fc-end':'fc-not-end'].concat(event.className,event.source?event.source.className:[]);if(isDraggable){classes.push('fc-draggable');}if(isResizable){classes.push('fc-resizable');}// event is currently selected? attach a className.
if(view.isEventSelected(event)){classes.push('fc-selected');}return classes;},// Utility for generating event skin-related CSS properties
getSegSkinCss:function getSegSkinCss(seg){var event=seg.event;var view=this.view;var source=event.source||{};var eventColor=event.color;var sourceColor=source.color;var optionColor=view.opt('eventColor');return{'background-color':event.backgroundColor||eventColor||source.backgroundColor||sourceColor||view.opt('eventBackgroundColor')||optionColor,'border-color':event.borderColor||eventColor||source.borderColor||sourceColor||view.opt('eventBorderColor')||optionColor,color:event.textColor||source.textColor||view.opt('eventTextColor')};},/* Converting events -> eventRange -> eventSpan -> eventSegs
	------------------------------------------------------------------------------------------------------------------*/// Generates an array of segments for the given single event
// Can accept an event "location" as well (which only has start/end and no allDay)
eventToSegs:function eventToSegs(event){return this.eventsToSegs([event]);},eventToSpan:function eventToSpan(event){return this.eventToSpans(event)[0];},// Generates spans (always unzoned) for the given event.
// Does not do any inverting for inverse-background events.
// Can accept an event "location" as well (which only has start/end and no allDay)
eventToSpans:function eventToSpans(event){var range=this.eventToRange(event);return this.eventRangeToSpans(range,event);},// Converts an array of event objects into an array of event segment objects.
// A custom `segSliceFunc` may be given for arbitrarily slicing up events.
// Doesn't guarantee an order for the resulting array.
eventsToSegs:function eventsToSegs(allEvents,segSliceFunc){var _this=this;var eventsById=groupEventsById(allEvents);var segs=[];$.each(eventsById,function(id,events){var ranges=[];var i;for(i=0;i<events.length;i++){ranges.push(_this.eventToRange(events[i]));}// inverse-background events (utilize only the first event in calculations)
if(isInverseBgEvent(events[0])){ranges=_this.invertRanges(ranges);for(i=0;i<ranges.length;i++){segs.push.apply(segs,// append to
_this.eventRangeToSegs(ranges[i],events[0],segSliceFunc));}}// normal event ranges
else{for(i=0;i<ranges.length;i++){segs.push.apply(segs,// append to
_this.eventRangeToSegs(ranges[i],events[i],segSliceFunc));}}});return segs;},// Generates the unzoned start/end dates an event appears to occupy
// Can accept an event "location" as well (which only has start/end and no allDay)
eventToRange:function eventToRange(event){return{start:event.start.clone().stripZone(),end:(event.end?event.end.clone():// derive the end from the start and allDay. compute allDay if necessary
this.view.calendar.getDefaultEventEnd(event.allDay!=null?event.allDay:!event.start.hasTime(),event.start)).stripZone()};},// Given an event's range (unzoned start/end), and the event itself,
// slice into segments (using the segSliceFunc function if specified)
eventRangeToSegs:function eventRangeToSegs(range,event,segSliceFunc){var spans=this.eventRangeToSpans(range,event);var segs=[];var i;for(i=0;i<spans.length;i++){segs.push.apply(segs,// append to
this.eventSpanToSegs(spans[i],event,segSliceFunc));}return segs;},// Given an event's unzoned date range, return an array of "span" objects.
// Subclasses can override.
eventRangeToSpans:function eventRangeToSpans(range,event){return[$.extend({},range)];// copy into a single-item array
},// Given an event's span (unzoned start/end and other misc data), and the event itself,
// slices into segments and attaches event-derived properties to them.
eventSpanToSegs:function eventSpanToSegs(span,event,segSliceFunc){var segs=segSliceFunc?segSliceFunc(span):this.spanToSegs(span);var i,seg;for(i=0;i<segs.length;i++){seg=segs[i];seg.event=event;seg.eventStartMS=+span.start;// TODO: not the best name after making spans unzoned
seg.eventDurationMS=span.end-span.start;}return segs;},// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
// SIDE EFFECT: will mutate the given array and will use its date references.
invertRanges:function invertRanges(ranges){var view=this.view;var viewStart=view.start.clone();// need a copy
var viewEnd=view.end.clone();// need a copy
var inverseRanges=[];var start=viewStart;// the end of the previous range. the start of the new range
var i,range;// ranges need to be in order. required for our date-walking algorithm
ranges.sort(compareRanges);for(i=0;i<ranges.length;i++){range=ranges[i];// add the span of time before the event (if there is any)
if(range.start>start){// compare millisecond time (skip any ambig logic)
inverseRanges.push({start:start,end:range.start});}start=range.end;}// add the span of time after the last event (if there is any)
if(start<viewEnd){// compare millisecond time (skip any ambig logic)
inverseRanges.push({start:start,end:viewEnd});}return inverseRanges;},sortEventSegs:function sortEventSegs(segs){segs.sort(proxy(this,'compareEventSegs'));},// A cmp function for determining which segments should take visual priority
compareEventSegs:function compareEventSegs(seg1,seg2){return seg1.eventStartMS-seg2.eventStartMS||// earlier events go first
seg2.eventDurationMS-seg1.eventDurationMS||// tie? longer events go first
seg2.event.allDay-seg1.event.allDay||// tie? put all-day events first (booleans cast to 0/1)
compareByFieldSpecs(seg1.event,seg2.event,this.view.eventOrderSpecs);}});/* Utilities
----------------------------------------------------------------------------------------------------------------------*/function isBgEvent(event){// returns true if background OR inverse-background
var rendering=getEventRendering(event);return rendering==='background'||rendering==='inverse-background';}FC.isBgEvent=isBgEvent;// export
function isInverseBgEvent(event){return getEventRendering(event)==='inverse-background';}function getEventRendering(event){return firstDefined((event.source||{}).rendering,event.rendering);}function groupEventsById(events){var eventsById={};var i,event;for(i=0;i<events.length;i++){event=events[i];(eventsById[event._id]||(eventsById[event._id]=[])).push(event);}return eventsById;}// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
function compareRanges(range1,range2){return range1.start-range2.start;// earlier ranges go first
}/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
FC.dataAttrPrefix='';// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el){var prefix=FC.dataAttrPrefix;var eventProps;// properties for creating the event, not related to date/time
var startTime;// a Duration
var duration;var stick;if(prefix){prefix+='-';}eventProps=el.data(prefix+'event')||null;if(eventProps){if((typeof eventProps==='undefined'?'undefined':(0,_typeof3.default)(eventProps))==='object'){eventProps=$.extend({},eventProps);// make a copy
}else{// something like 1 or true. still signal event creation
eventProps={};}// pluck special-cased date/time properties
startTime=eventProps.start;if(startTime==null){startTime=eventProps.time;}// accept 'time' as well
duration=eventProps.duration;stick=eventProps.stick;delete eventProps.start;delete eventProps.time;delete eventProps.duration;delete eventProps.stick;}// fallback to standalone attribute values for each of the date/time properties
if(startTime==null){startTime=el.data(prefix+'start');}if(startTime==null){startTime=el.data(prefix+'time');}// accept 'time' as well
if(duration==null){duration=el.data(prefix+'duration');}if(stick==null){stick=el.data(prefix+'stick');}// massage into correct data types
startTime=startTime!=null?moment.duration(startTime):null;duration=duration!=null?moment.duration(duration):null;stick=Boolean(stick);return{eventProps:eventProps,startTime:startTime,duration:duration,stick:stick};};;/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/var DayTableMixin=FC.DayTableMixin={breakOnWeeks:false,// should create a new row for each week?
dayDates:null,// whole-day dates for each column. left to right
dayIndices:null,// for each day from start, the offset
daysPerRow:null,rowCnt:null,colCnt:null,colHeadFormat:null,// Populates internal variables used for date calculation and rendering
updateDayTable:function updateDayTable(){var view=this.view;var date=this.start.clone();var dayIndex=-1;var dayIndices=[];var dayDates=[];var daysPerRow;var firstDay;var rowCnt;while(date.isBefore(this.end)){// loop each day from start to end
if(view.isHiddenDay(date)){dayIndices.push(dayIndex+0.5);// mark that it's between indices
}else{dayIndex++;dayIndices.push(dayIndex);dayDates.push(date.clone());}date.add(1,'days');}if(this.breakOnWeeks){// count columns until the day-of-week repeats
firstDay=dayDates[0].day();for(daysPerRow=1;daysPerRow<dayDates.length;daysPerRow++){if(dayDates[daysPerRow].day()==firstDay){break;}}rowCnt=Math.ceil(dayDates.length/daysPerRow);}else{rowCnt=1;daysPerRow=dayDates.length;}this.dayDates=dayDates;this.dayIndices=dayIndices;this.daysPerRow=daysPerRow;this.rowCnt=rowCnt;this.updateDayTableCols();},// Computes and assigned the colCnt property and updates any options that may be computed from it
updateDayTableCols:function updateDayTableCols(){this.colCnt=this.computeColCnt();this.colHeadFormat=this.view.opt('columnFormat')||this.computeColHeadFormat();},// Determines how many columns there should be in the table
computeColCnt:function computeColCnt(){return this.daysPerRow;},// Computes the ambiguously-timed moment for the given cell
getCellDate:function getCellDate(row,col){return this.dayDates[this.getCellDayIndex(row,col)].clone();},// Computes the ambiguously-timed date range for the given cell
getCellRange:function getCellRange(row,col){var start=this.getCellDate(row,col);var end=start.clone().add(1,'days');return{start:start,end:end};},// Returns the number of day cells, chronologically, from the first of the grid (0-based)
getCellDayIndex:function getCellDayIndex(row,col){return row*this.daysPerRow+this.getColDayIndex(col);},// Returns the numner of day cells, chronologically, from the first cell in *any given row*
getColDayIndex:function getColDayIndex(col){if(this.isRTL){return this.colCnt-1-col;}else{return col;}},// Given a date, returns its chronolocial cell-index from the first cell of the grid.
// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
// If before the first offset, returns a negative number.
// If after the last offset, returns an offset past the last cell offset.
// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
getDateDayIndex:function getDateDayIndex(date){var dayIndices=this.dayIndices;var dayOffset=date.diff(this.start,'days');if(dayOffset<0){return dayIndices[0]-1;}else if(dayOffset>=dayIndices.length){return dayIndices[dayIndices.length-1]+1;}else{return dayIndices[dayOffset];}},/* Options
	------------------------------------------------------------------------------------------------------------------*/// Computes a default column header formatting string if `colFormat` is not explicitly defined
computeColHeadFormat:function computeColHeadFormat(){// if more than one week row, or if there are a lot of columns with not much space,
// put just the day numbers will be in each cell
if(this.rowCnt>1||this.colCnt>10){return'ddd';// "Sat"
}// multiple days, so full single date string WON'T be in title text
else if(this.colCnt>1){return this.view.opt('dayOfMonthFormat');// "Sat 12/10"
}// single day, so full single date string will probably be in title text
else{return'dddd';// "Saturday"
}},/* Slicing
	------------------------------------------------------------------------------------------------------------------*/// Slices up a date range into a segment for every week-row it intersects with
sliceRangeByRow:function sliceRangeByRow(range){var daysPerRow=this.daysPerRow;var normalRange=this.view.computeDayRange(range);// make whole-day range, considering nextDayThreshold
var rangeFirst=this.getDateDayIndex(normalRange.start);// inclusive first index
var rangeLast=this.getDateDayIndex(normalRange.end.clone().subtract(1,'days'));// inclusive last index
var segs=[];var row;var rowFirst,rowLast;// inclusive day-index range for current row
var segFirst,segLast;// inclusive day-index range for segment
for(row=0;row<this.rowCnt;row++){rowFirst=row*daysPerRow;rowLast=rowFirst+daysPerRow-1;// intersect segment's offset range with the row's
segFirst=Math.max(rangeFirst,rowFirst);segLast=Math.min(rangeLast,rowLast);// deal with in-between indices
segFirst=Math.ceil(segFirst);// in-between starts round to next cell
segLast=Math.floor(segLast);// in-between ends round to prev cell
if(segFirst<=segLast){// was there any intersection with the current row?
segs.push({row:row,// normalize to start of row
firstRowDayIndex:segFirst-rowFirst,lastRowDayIndex:segLast-rowFirst,// must be matching integers to be the segment's start/end
isStart:segFirst===rangeFirst,isEnd:segLast===rangeLast});}}return segs;},// Slices up a date range into a segment for every day-cell it intersects with.
// TODO: make more DRY with sliceRangeByRow somehow.
sliceRangeByDay:function sliceRangeByDay(range){var daysPerRow=this.daysPerRow;var normalRange=this.view.computeDayRange(range);// make whole-day range, considering nextDayThreshold
var rangeFirst=this.getDateDayIndex(normalRange.start);// inclusive first index
var rangeLast=this.getDateDayIndex(normalRange.end.clone().subtract(1,'days'));// inclusive last index
var segs=[];var row;var rowFirst,rowLast;// inclusive day-index range for current row
var i;var segFirst,segLast;// inclusive day-index range for segment
for(row=0;row<this.rowCnt;row++){rowFirst=row*daysPerRow;rowLast=rowFirst+daysPerRow-1;for(i=rowFirst;i<=rowLast;i++){// intersect segment's offset range with the row's
segFirst=Math.max(rangeFirst,i);segLast=Math.min(rangeLast,i);// deal with in-between indices
segFirst=Math.ceil(segFirst);// in-between starts round to next cell
segLast=Math.floor(segLast);// in-between ends round to prev cell
if(segFirst<=segLast){// was there any intersection with the current row?
segs.push({row:row,// normalize to start of row
firstRowDayIndex:segFirst-rowFirst,lastRowDayIndex:segLast-rowFirst,// must be matching integers to be the segment's start/end
isStart:segFirst===rangeFirst,isEnd:segLast===rangeLast});}}}return segs;},/* Header Rendering
	------------------------------------------------------------------------------------------------------------------*/renderHeadHtml:function renderHeadHtml(){var view=this.view;return''+'<div class="fc-row '+view.widgetHeaderClass+'">'+'<table>'+'<thead>'+this.renderHeadTrHtml()+'</thead>'+'</table>'+'</div>';},renderHeadIntroHtml:function renderHeadIntroHtml(){return this.renderIntroHtml();// fall back to generic
},renderHeadTrHtml:function renderHeadTrHtml(){return''+'<tr>'+(this.isRTL?'':this.renderHeadIntroHtml())+this.renderHeadDateCellsHtml()+(this.isRTL?this.renderHeadIntroHtml():'')+'</tr>';},renderHeadDateCellsHtml:function renderHeadDateCellsHtml(){var htmls=[];var col,date;for(col=0;col<this.colCnt;col++){date=this.getCellDate(0,col);htmls.push(this.renderHeadDateCellHtml(date));}return htmls.join('');},// TODO: when internalApiVersion, accept an object for HTML attributes
// (colspan should be no different)
renderHeadDateCellHtml:function renderHeadDateCellHtml(date,colspan,otherAttrs){var view=this.view;return''+'<th class="fc-day-header '+view.widgetHeaderClass+' fc-'+dayIDs[date.day()]+'"'+(this.rowCnt==1?' data-date="'+date.format('YYYY-MM-DD')+'"':'')+(colspan>1?' colspan="'+colspan+'"':'')+(otherAttrs?' '+otherAttrs:'')+'>'+htmlEscape(date.format(this.colHeadFormat))+'</th>';},/* Background Rendering
	------------------------------------------------------------------------------------------------------------------*/renderBgTrHtml:function renderBgTrHtml(row){return''+'<tr>'+(this.isRTL?'':this.renderBgIntroHtml(row))+this.renderBgCellsHtml(row)+(this.isRTL?this.renderBgIntroHtml(row):'')+'</tr>';},renderBgIntroHtml:function renderBgIntroHtml(row){return this.renderIntroHtml();// fall back to generic
},renderBgCellsHtml:function renderBgCellsHtml(row){var htmls=[];var col,date;for(col=0;col<this.colCnt;col++){date=this.getCellDate(row,col);htmls.push(this.renderBgCellHtml(date));}return htmls.join('');},renderBgCellHtml:function renderBgCellHtml(date,otherAttrs){var view=this.view;var classes=this.getDayClasses(date);classes.unshift('fc-day',view.widgetContentClass);return'<td class="'+classes.join(' ')+'"'+' data-date="'+date.format('YYYY-MM-DD')+'"'+(// if date has a time, won't format it
otherAttrs?' '+otherAttrs:'')+'></td>';},/* Generic
	------------------------------------------------------------------------------------------------------------------*/// Generates the default HTML intro for any row. User classes should override
renderIntroHtml:function renderIntroHtml(){},// TODO: a generic method for dealing with <tr>, RTL, intro
// when increment internalApiVersion
// wrapTr (scheduler)
/* Utils
	------------------------------------------------------------------------------------------------------------------*/// Applies the generic "intro" and "outro" HTML to the given cells.
// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
bookendCells:function bookendCells(trEl){var introHtml=this.renderIntroHtml();if(introHtml){if(this.isRTL){trEl.append(introHtml);}else{trEl.prepend(introHtml);}}}};;;/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/var DayGrid=FC.DayGrid=Grid.extend(DayTableMixin,{numbersVisible:false,// should render a row for day/week numbers? set by outside view. TODO: make internal
bottomCoordPadding:0,// hack for extending the hit area for the last row of the coordinate grid
rowEls:null,// set of fake row elements
cellEls:null,// set of whole-day elements comprising the row's background
helperEls:null,// set of cell skeleton elements for rendering the mock event "helper"
rowCoordCache:null,colCoordCache:null,// Renders the rows and columns into the component's `this.el`, which should already be assigned.
// isRigid determins whether the individual rows should ignore the contents and be a constant height.
// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
renderDates:function renderDates(isRigid){var view=this.view;var rowCnt=this.rowCnt;var colCnt=this.colCnt;var html='';var row;var col;for(row=0;row<rowCnt;row++){html+=this.renderDayRowHtml(row,isRigid);}this.el.html(html);this.rowEls=this.el.find('.fc-row');this.cellEls=this.el.find('.fc-day');this.rowCoordCache=new CoordCache({els:this.rowEls,isVertical:true});this.colCoordCache=new CoordCache({els:this.cellEls.slice(0,this.colCnt),// only the first row
isHorizontal:true});// trigger dayRender with each cell's element
for(row=0;row<rowCnt;row++){for(col=0;col<colCnt;col++){view.trigger('dayRender',null,this.getCellDate(row,col),this.getCellEl(row,col));}}},unrenderDates:function unrenderDates(){this.removeSegPopover();},renderBusinessHours:function renderBusinessHours(){var events=this.view.calendar.getBusinessHoursEvents(true);// wholeDay=true
var segs=this.eventsToSegs(events);this.renderFill('businessHours',segs,'bgevent');},unrenderBusinessHours:function unrenderBusinessHours(){this.unrenderFill('businessHours');},// Generates the HTML for a single row, which is a div that wraps a table.
// `row` is the row number.
renderDayRowHtml:function renderDayRowHtml(row,isRigid){var view=this.view;var classes=['fc-row','fc-week',view.widgetContentClass];if(isRigid){classes.push('fc-rigid');}return''+'<div class="'+classes.join(' ')+'">'+'<div class="fc-bg">'+'<table>'+this.renderBgTrHtml(row)+'</table>'+'</div>'+'<div class="fc-content-skeleton">'+'<table>'+(this.numbersVisible?'<thead>'+this.renderNumberTrHtml(row)+'</thead>':'')+'</table>'+'</div>'+'</div>';},/* Grid Number Rendering
	------------------------------------------------------------------------------------------------------------------*/renderNumberTrHtml:function renderNumberTrHtml(row){return''+'<tr>'+(this.isRTL?'':this.renderNumberIntroHtml(row))+this.renderNumberCellsHtml(row)+(this.isRTL?this.renderNumberIntroHtml(row):'')+'</tr>';},renderNumberIntroHtml:function renderNumberIntroHtml(row){return this.renderIntroHtml();},renderNumberCellsHtml:function renderNumberCellsHtml(row){var htmls=[];var col,date;for(col=0;col<this.colCnt;col++){date=this.getCellDate(row,col);htmls.push(this.renderNumberCellHtml(date));}return htmls.join('');},// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
// The number row will only exist if either day numbers or week numbers are turned on.
renderNumberCellHtml:function renderNumberCellHtml(date){var classes;if(!this.view.dayNumbersVisible){// if there are week numbers but not day numbers
return'<td/>';//  will create an empty space above events :(
}classes=this.getDayClasses(date);classes.unshift('fc-day-number');return''+'<td class="'+classes.join(' ')+'" data-date="'+date.format()+'">'+date.date()+'</td>';},/* Options
	------------------------------------------------------------------------------------------------------------------*/// Computes a default event time formatting string if `timeFormat` is not explicitly defined
computeEventTimeFormat:function computeEventTimeFormat(){return this.view.opt('extraSmallTimeFormat');// like "6p" or "6:30p"
},// Computes a default `displayEventEnd` value if one is not expliclty defined
computeDisplayEventEnd:function computeDisplayEventEnd(){return this.colCnt==1;// we'll likely have space if there's only one day
},/* Dates
	------------------------------------------------------------------------------------------------------------------*/rangeUpdated:function rangeUpdated(){this.updateDayTable();},// Slices up the given span (unzoned start/end with other misc data) into an array of segments
spanToSegs:function spanToSegs(span){var segs=this.sliceRangeByRow(span);var i,seg;for(i=0;i<segs.length;i++){seg=segs[i];if(this.isRTL){seg.leftCol=this.daysPerRow-1-seg.lastRowDayIndex;seg.rightCol=this.daysPerRow-1-seg.firstRowDayIndex;}else{seg.leftCol=seg.firstRowDayIndex;seg.rightCol=seg.lastRowDayIndex;}}return segs;},/* Hit System
	------------------------------------------------------------------------------------------------------------------*/prepareHits:function prepareHits(){this.colCoordCache.build();this.rowCoordCache.build();this.rowCoordCache.bottoms[this.rowCnt-1]+=this.bottomCoordPadding;// hack
},releaseHits:function releaseHits(){this.colCoordCache.clear();this.rowCoordCache.clear();},queryHit:function queryHit(leftOffset,topOffset){var col=this.colCoordCache.getHorizontalIndex(leftOffset);var row=this.rowCoordCache.getVerticalIndex(topOffset);if(row!=null&&col!=null){return this.getCellHit(row,col);}},getHitSpan:function getHitSpan(hit){return this.getCellRange(hit.row,hit.col);},getHitEl:function getHitEl(hit){return this.getCellEl(hit.row,hit.col);},/* Cell System
	------------------------------------------------------------------------------------------------------------------*/// FYI: the first column is the leftmost column, regardless of date
getCellHit:function getCellHit(row,col){return{row:row,col:col,component:this,// needed unfortunately :(
left:this.colCoordCache.getLeftOffset(col),right:this.colCoordCache.getRightOffset(col),top:this.rowCoordCache.getTopOffset(row),bottom:this.rowCoordCache.getBottomOffset(row)};},getCellEl:function getCellEl(row,col){return this.cellEls.eq(row*this.colCnt+col);},/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods
// Renders a visual indication of an event or external element being dragged.
// `eventLocation` has zoned start and end (optional)
renderDrag:function renderDrag(eventLocation,seg){// always render a highlight underneath
this.renderHighlight(this.eventToSpan(eventLocation));// if a segment from the same calendar but another component is being dragged, render a helper event
if(seg&&!seg.el.closest(this.el).length){return this.renderEventLocationHelper(eventLocation,seg);// returns mock event elements
}},// Unrenders any visual indication of a hovering event
unrenderDrag:function unrenderDrag(){this.unrenderHighlight();this.unrenderHelper();},/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of an event being resized
renderEventResize:function renderEventResize(eventLocation,seg){this.renderHighlight(this.eventToSpan(eventLocation));return this.renderEventLocationHelper(eventLocation,seg);// returns mock event elements
},// Unrenders a visual indication of an event being resized
unrenderEventResize:function unrenderEventResize(){this.unrenderHighlight();this.unrenderHelper();},/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
renderHelper:function renderHelper(event,sourceSeg){var helperNodes=[];var segs=this.eventToSegs(event);var rowStructs;segs=this.renderFgSegEls(segs);// assigns each seg's el and returns a subset of segs that were rendered
rowStructs=this.renderSegRows(segs);// inject each new event skeleton into each associated row
this.rowEls.each(function(row,rowNode){var rowEl=$(rowNode);// the .fc-row
var skeletonEl=$('<div class="fc-helper-skeleton"><table/></div>');// will be absolutely positioned
var skeletonTop;// If there is an original segment, match the top position. Otherwise, put it at the row's top level
if(sourceSeg&&sourceSeg.row===row){skeletonTop=sourceSeg.el.position().top;}else{skeletonTop=rowEl.find('.fc-content-skeleton tbody').position().top;}skeletonEl.css('top',skeletonTop).find('table').append(rowStructs[row].tbodyEl);rowEl.append(skeletonEl);helperNodes.push(skeletonEl[0]);});return(// must return the elements rendered
this.helperEls=$(helperNodes)// array -> jQuery set
);},// Unrenders any visual indication of a mock helper event
unrenderHelper:function unrenderHelper(){if(this.helperEls){this.helperEls.remove();this.helperEls=null;}},/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/fillSegTag:'td',// override the default tag name
// Renders a set of rectangles over the given segments of days.
// Only returns segments that successfully rendered.
renderFill:function renderFill(type,segs,className){var nodes=[];var i,seg;var skeletonEl;segs=this.renderFillSegEls(type,segs);// assignes `.el` to each seg. returns successfully rendered segs
for(i=0;i<segs.length;i++){seg=segs[i];skeletonEl=this.renderFillRow(type,seg,className);this.rowEls.eq(seg.row).append(skeletonEl);nodes.push(skeletonEl[0]);}this.elsByFill[type]=$(nodes);return segs;},// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
renderFillRow:function renderFillRow(type,seg,className){var colCnt=this.colCnt;var startCol=seg.leftCol;var endCol=seg.rightCol+1;var skeletonEl;var trEl;className=className||type.toLowerCase();skeletonEl=$('<div class="fc-'+className+'-skeleton">'+'<table><tr/></table>'+'</div>');trEl=skeletonEl.find('tr');if(startCol>0){trEl.append('<td colspan="'+startCol+'"/>');}trEl.append(seg.el.attr('colspan',endCol-startCol));if(endCol<colCnt){trEl.append('<td colspan="'+(colCnt-endCol)+'"/>');}this.bookendCells(trEl);return skeletonEl;}});;;/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/DayGrid.mixin({rowStructs:null,// an array of objects, each holding information about a row's foreground event-rendering
// Unrenders all events currently rendered on the grid
unrenderEvents:function unrenderEvents(){this.removeSegPopover();// removes the "more.." events popover
Grid.prototype.unrenderEvents.apply(this,arguments);// calls the super-method
},// Retrieves all rendered segment objects currently rendered on the grid
getEventSegs:function getEventSegs(){return Grid.prototype.getEventSegs.call(this)// get the segments from the super-method
.concat(this.popoverSegs||[]);// append the segments from the "more..." popover
},// Renders the given background event segments onto the grid
renderBgSegs:function renderBgSegs(segs){// don't render timed background events
var allDaySegs=$.grep(segs,function(seg){return seg.event.allDay;});return Grid.prototype.renderBgSegs.call(this,allDaySegs);// call the super-method
},// Renders the given foreground event segments onto the grid
renderFgSegs:function renderFgSegs(segs){var rowStructs;// render an `.el` on each seg
// returns a subset of the segs. segs that were actually rendered
segs=this.renderFgSegEls(segs);rowStructs=this.rowStructs=this.renderSegRows(segs);// append to each row's content skeleton
this.rowEls.each(function(i,rowNode){$(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);});return segs;// return only the segs that were actually rendered
},// Unrenders all currently rendered foreground event segments
unrenderFgSegs:function unrenderFgSegs(){var rowStructs=this.rowStructs||[];var rowStruct;while(rowStruct=rowStructs.pop()){rowStruct.tbodyEl.remove();}this.rowStructs=null;},// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
renderSegRows:function renderSegRows(segs){var rowStructs=[];var segRows;var row;segRows=this.groupSegRows(segs);// group into nested arrays
// iterate each row of segment groupings
for(row=0;row<segRows.length;row++){rowStructs.push(this.renderSegRow(row,segRows[row]));}return rowStructs;},// Builds the HTML to be used for the default element for an individual segment
fgSegHtml:function fgSegHtml(seg,disableResizing){var view=this.view;var event=seg.event;var isDraggable=view.isEventDraggable(event);var isResizableFromStart=!disableResizing&&event.allDay&&seg.isStart&&view.isEventResizableFromStart(event);var isResizableFromEnd=!disableResizing&&event.allDay&&seg.isEnd&&view.isEventResizableFromEnd(event);var classes=this.getSegClasses(seg,isDraggable,isResizableFromStart||isResizableFromEnd);var skinCss=cssToStr(this.getSegSkinCss(seg));var timeHtml='';var timeText;var titleHtml;classes.unshift('fc-day-grid-event','fc-h-event');// Only display a timed events time if it is the starting segment
if(seg.isStart){timeText=this.getEventTimeText(event);if(timeText){timeHtml='<span class="fc-time">'+htmlEscape(timeText)+'</span>';}}titleHtml='<span class="fc-title">'+(htmlEscape(event.title||'')||'&nbsp;')+// we always want one line of height
'</span>';return'<a class="'+classes.join(' ')+'"'+(event.url?' href="'+htmlEscape(event.url)+'"':'')+(skinCss?' style="'+skinCss+'"':'')+'>'+'<div class="fc-content">'+(this.isRTL?titleHtml+' '+timeHtml:// put a natural space in between
timeHtml+' '+titleHtml//
)+'</div>'+(isResizableFromStart?'<div class="fc-resizer fc-start-resizer" />':'')+(isResizableFromEnd?'<div class="fc-resizer fc-end-resizer" />':'')+'</a>';},// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
// the segments. Returns object with a bunch of internal data about how the render was calculated.
// NOTE: modifies rowSegs
renderSegRow:function renderSegRow(row,rowSegs){var colCnt=this.colCnt;var segLevels=this.buildSegLevels(rowSegs);// group into sub-arrays of levels
var levelCnt=Math.max(1,segLevels.length);// ensure at least one level
var tbody=$('<tbody/>');var segMatrix=[];// lookup for which segments are rendered into which level+col cells
var cellMatrix=[];// lookup for all <td> elements of the level+col matrix
var loneCellMatrix=[];// lookup for <td> elements that only take up a single column
var i,levelSegs;var col;var tr;var j,seg;var td;// populates empty cells from the current column (`col`) to `endCol`
function emptyCellsUntil(endCol){while(col<endCol){// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
td=(loneCellMatrix[i-1]||[])[col];if(td){td.attr('rowspan',parseInt(td.attr('rowspan')||1,10)+1);}else{td=$('<td/>');tr.append(td);}cellMatrix[i][col]=td;loneCellMatrix[i][col]=td;col++;}}for(i=0;i<levelCnt;i++){// iterate through all levels
levelSegs=segLevels[i];col=0;tr=$('<tr/>');segMatrix.push([]);cellMatrix.push([]);loneCellMatrix.push([]);// levelCnt might be 1 even though there are no actual levels. protect against this.
// this single empty row is useful for styling.
if(levelSegs){for(j=0;j<levelSegs.length;j++){// iterate through segments in level
seg=levelSegs[j];emptyCellsUntil(seg.leftCol);// create a container that occupies or more columns. append the event element.
td=$('<td class="fc-event-container"/>').append(seg.el);if(seg.leftCol!=seg.rightCol){td.attr('colspan',seg.rightCol-seg.leftCol+1);}else{// a single-column segment
loneCellMatrix[i][col]=td;}while(col<=seg.rightCol){cellMatrix[i][col]=td;segMatrix[i][col]=seg;col++;}tr.append(td);}}emptyCellsUntil(colCnt);// finish off the row
this.bookendCells(tr);tbody.append(tr);}return{// a "rowStruct"
row:row,// the row number
tbodyEl:tbody,cellMatrix:cellMatrix,segMatrix:segMatrix,segLevels:segLevels,segs:rowSegs};},// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
// NOTE: modifies segs
buildSegLevels:function buildSegLevels(segs){var levels=[];var i,seg;var j;// Give preference to elements with certain criteria, so they have
// a chance to be closer to the top.
this.sortEventSegs(segs);for(i=0;i<segs.length;i++){seg=segs[i];// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
for(j=0;j<levels.length;j++){if(!isDaySegCollision(seg,levels[j])){break;}}// `j` now holds the desired subrow index
seg.level=j;// create new level array if needed and append segment
(levels[j]||(levels[j]=[])).push(seg);}// order segments left-to-right. very important if calendar is RTL
for(j=0;j<levels.length;j++){levels[j].sort(compareDaySegCols);}return levels;},// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
groupSegRows:function groupSegRows(segs){var segRows=[];var i;for(i=0;i<this.rowCnt;i++){segRows.push([]);}for(i=0;i<segs.length;i++){segRows[segs[i].row].push(segs[i]);}return segRows;}});// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg,otherSegs){var i,otherSeg;for(i=0;i<otherSegs.length;i++){otherSeg=otherSegs[i];if(otherSeg.leftCol<=seg.rightCol&&otherSeg.rightCol>=seg.leftCol){return true;}}return false;}// A cmp function for determining the leftmost event
function compareDaySegCols(a,b){return a.leftCol-b.leftCol;};;/* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/// NOTE: all the segs being passed around in here are foreground segs
DayGrid.mixin({segPopover:null,// the Popover that holds events that can't fit in a cell. null when not visible
popoverSegs:null,// an array of segment objects that the segPopover holds. null when not visible
removeSegPopover:function removeSegPopover(){if(this.segPopover){this.segPopover.hide();// in handler, will call segPopover's removeElement
}},// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
// `levelLimit` can be false (don't limit), a number, or true (should be computed).
limitRows:function limitRows(levelLimit){var rowStructs=this.rowStructs||[];var row;// row #
var rowLevelLimit;for(row=0;row<rowStructs.length;row++){this.unlimitRow(row);if(!levelLimit){rowLevelLimit=false;}else if(typeof levelLimit==='number'){rowLevelLimit=levelLimit;}else{rowLevelLimit=this.computeRowLevelLimit(row);}if(rowLevelLimit!==false){this.limitRow(row,rowLevelLimit);}}},// Computes the number of levels a row will accomodate without going outside its bounds.
// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
// `row` is the row number.
computeRowLevelLimit:function computeRowLevelLimit(row){var rowEl=this.rowEls.eq(row);// the containing "fake" row div
var rowHeight=rowEl.height();// TODO: cache somehow?
var trEls=this.rowStructs[row].tbodyEl.children();var i,trEl;var trHeight;function iterInnerHeights(i,childNode){trHeight=Math.max(trHeight,$(childNode).outerHeight());}// Reveal one level <tr> at a time and stop when we find one out of bounds
for(i=0;i<trEls.length;i++){trEl=trEls.eq(i).removeClass('fc-limited');// reset to original state (reveal)
// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
// so instead, find the tallest inner content element.
trHeight=0;trEl.find('> td > :first-child').each(iterInnerHeights);if(trEl.position().top+trHeight>rowHeight){return i;}}return false;// should not limit at all
},// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
// `row` is the row number.
// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
limitRow:function limitRow(row,levelLimit){var _this=this;var rowStruct=this.rowStructs[row];var moreNodes=[];// array of "more" <a> links and <td> DOM nodes
var col=0;// col #, left-to-right (not chronologically)
var levelSegs;// array of segment objects in the last allowable level, ordered left-to-right
var cellMatrix;// a matrix (by level, then column) of all <td> jQuery elements in the row
var limitedNodes;// array of temporarily hidden level <tr> and segment <td> DOM nodes
var i,seg;var segsBelow;// array of segment objects below `seg` in the current `col`
var totalSegsBelow;// total number of segments below `seg` in any of the columns `seg` occupies
var colSegsBelow;// array of segment arrays, below seg, one for each column (offset from segs's first column)
var td,rowspan;var segMoreNodes;// array of "more" <td> cells that will stand-in for the current seg's cell
var j;var moreTd,moreWrap,moreLink;// Iterates through empty level cells and places "more" links inside if need be
function emptyCellsUntil(endCol){// goes from current `col` to `endCol`
while(col<endCol){segsBelow=_this.getCellSegs(row,col,levelLimit);if(segsBelow.length){td=cellMatrix[levelLimit-1][col];moreLink=_this.renderMoreLink(row,col,segsBelow);moreWrap=$('<div/>').append(moreLink);td.append(moreWrap);moreNodes.push(moreWrap[0]);}col++;}}if(levelLimit&&levelLimit<rowStruct.segLevels.length){// is it actually over the limit?
levelSegs=rowStruct.segLevels[levelLimit-1];cellMatrix=rowStruct.cellMatrix;limitedNodes=rowStruct.tbodyEl.children().slice(levelLimit)// get level <tr> elements past the limit
.addClass('fc-limited').get();// hide elements and get a simple DOM-nodes array
// iterate though segments in the last allowable level
for(i=0;i<levelSegs.length;i++){seg=levelSegs[i];emptyCellsUntil(seg.leftCol);// process empty cells before the segment
// determine *all* segments below `seg` that occupy the same columns
colSegsBelow=[];totalSegsBelow=0;while(col<=seg.rightCol){segsBelow=this.getCellSegs(row,col,levelLimit);colSegsBelow.push(segsBelow);totalSegsBelow+=segsBelow.length;col++;}if(totalSegsBelow){// do we need to replace this segment with one or many "more" links?
td=cellMatrix[levelLimit-1][seg.leftCol];// the segment's parent cell
rowspan=td.attr('rowspan')||1;segMoreNodes=[];// make a replacement <td> for each column the segment occupies. will be one for each colspan
for(j=0;j<colSegsBelow.length;j++){moreTd=$('<td class="fc-more-cell"/>').attr('rowspan',rowspan);segsBelow=colSegsBelow[j];moreLink=this.renderMoreLink(row,seg.leftCol+j,[seg].concat(segsBelow)// count seg as hidden too
);moreWrap=$('<div/>').append(moreLink);moreTd.append(moreWrap);segMoreNodes.push(moreTd[0]);moreNodes.push(moreTd[0]);}td.addClass('fc-limited').after($(segMoreNodes));// hide original <td> and inject replacements
limitedNodes.push(td[0]);}}emptyCellsUntil(this.colCnt);// finish off the level
rowStruct.moreEls=$(moreNodes);// for easy undoing later
rowStruct.limitedEls=$(limitedNodes);// for easy undoing later
}},// Reveals all levels and removes all "more"-related elements for a grid's row.
// `row` is a row number.
unlimitRow:function unlimitRow(row){var rowStruct=this.rowStructs[row];if(rowStruct.moreEls){rowStruct.moreEls.remove();rowStruct.moreEls=null;}if(rowStruct.limitedEls){rowStruct.limitedEls.removeClass('fc-limited');rowStruct.limitedEls=null;}},// Renders an <a> element that represents hidden event element for a cell.
// Responsible for attaching click handler as well.
renderMoreLink:function renderMoreLink(row,col,hiddenSegs){var _this=this;var view=this.view;return $('<a class="fc-more"/>').text(this.getMoreLinkText(hiddenSegs.length)).on('click',function(ev){var clickOption=view.opt('eventLimitClick');var date=_this.getCellDate(row,col);var moreEl=$(this);var dayEl=_this.getCellEl(row,col);var allSegs=_this.getCellSegs(row,col);// rescope the segments to be within the cell's date
var reslicedAllSegs=_this.resliceDaySegs(allSegs,date);var reslicedHiddenSegs=_this.resliceDaySegs(hiddenSegs,date);if(typeof clickOption==='function'){// the returned value can be an atomic option
clickOption=view.trigger('eventLimitClick',null,{date:date,dayEl:dayEl,moreEl:moreEl,segs:reslicedAllSegs,hiddenSegs:reslicedHiddenSegs},ev);}if(clickOption==='popover'){_this.showSegPopover(row,col,moreEl,reslicedAllSegs);}else if(typeof clickOption==='string'){// a view name
view.calendar.zoomTo(date,clickOption);}});},// Reveals the popover that displays all events within a cell
showSegPopover:function showSegPopover(row,col,moreLink,segs){var _this=this;var view=this.view;var moreWrap=moreLink.parent();// the <div> wrapper around the <a>
var topEl;// the element we want to match the top coordinate of
var options;if(this.rowCnt==1){topEl=view.el;// will cause the popover to cover any sort of header
}else{topEl=this.rowEls.eq(row);// will align with top of row
}options={className:'fc-more-popover',content:this.renderSegPopoverContent(row,col,segs),parentEl:this.el,top:topEl.offset().top,autoHide:true,// when the user clicks elsewhere, hide the popover
viewportConstrain:view.opt('popoverViewportConstrain'),hide:function hide(){// kill everything when the popover is hidden
_this.segPopover.removeElement();_this.segPopover=null;_this.popoverSegs=null;}};// Determine horizontal coordinate.
// We use the moreWrap instead of the <td> to avoid border confusion.
if(this.isRTL){options.right=moreWrap.offset().left+moreWrap.outerWidth()+1;// +1 to be over cell border
}else{options.left=moreWrap.offset().left-1;// -1 to be over cell border
}this.segPopover=new Popover(options);this.segPopover.show();},// Builds the inner DOM contents of the segment popover
renderSegPopoverContent:function renderSegPopoverContent(row,col,segs){var view=this.view;var isTheme=view.opt('theme');var title=this.getCellDate(row,col).format(view.opt('dayPopoverFormat'));var content=$('<div class="fc-header '+view.widgetHeaderClass+'">'+'<span class="fc-close '+(isTheme?'ui-icon ui-icon-closethick':'fc-icon fc-icon-x')+'"></span>'+'<span class="fc-title">'+htmlEscape(title)+'</span>'+'<div class="fc-clear"/>'+'</div>'+'<div class="fc-body '+view.widgetContentClass+'">'+'<div class="fc-event-container"></div>'+'</div>');var segContainer=content.find('.fc-event-container');var i;// render each seg's `el` and only return the visible segs
segs=this.renderFgSegEls(segs,true);// disableResizing=true
this.popoverSegs=segs;for(i=0;i<segs.length;i++){// because segments in the popover are not part of a grid coordinate system, provide a hint to any
// grids that want to do drag-n-drop about which cell it came from
this.prepareHits();segs[i].hit=this.getCellHit(row,col);this.releaseHits();segContainer.append(segs[i].el);}return content;},// Given the events within an array of segment objects, reslice them to be in a single day
resliceDaySegs:function resliceDaySegs(segs,dayDate){// build an array of the original events
var events=$.map(segs,function(seg){return seg.event;});var dayStart=dayDate.clone();var dayEnd=dayStart.clone().add(1,'days');var dayRange={start:dayStart,end:dayEnd};// slice the events with a custom slicing function
segs=this.eventsToSegs(events,function(range){var seg=intersectRanges(range,dayRange);// undefind if no intersection
return seg?[seg]:[];// must return an array of segments
});// force an order because eventsToSegs doesn't guarantee one
this.sortEventSegs(segs);return segs;},// Generates the text that should be inside a "more" link, given the number of events it represents
getMoreLinkText:function getMoreLinkText(num){var opt=this.view.opt('eventLimitText');if(typeof opt==='function'){return opt(num);}else{return'+'+num+' '+opt;}},// Returns segments within a given cell.
// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
getCellSegs:function getCellSegs(row,col,startLevel){var segMatrix=this.rowStructs[row].segMatrix;var level=startLevel||0;var segs=[];var seg;while(level<segMatrix.length){seg=segMatrix[level][col];if(seg){segs.push(seg);}level++;}return segs;}});;;/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/// We mixin DayTable, even though there is only a single row of days
var TimeGrid=FC.TimeGrid=Grid.extend(DayTableMixin,{slotDuration:null,// duration of a "slot", a distinct time segment on given day, visualized by lines
snapDuration:null,// granularity of time for dragging and selecting
snapsPerSlot:null,minTime:null,// Duration object that denotes the first visible time of any given day
maxTime:null,// Duration object that denotes the exclusive visible end time of any given day
labelFormat:null,// formatting string for times running along vertical axis
labelInterval:null,// duration of how often a label should be displayed for a slot
colEls:null,// cells elements in the day-row background
slatContainerEl:null,// div that wraps all the slat rows
slatEls:null,// elements running horizontally across all columns
nowIndicatorEls:null,colCoordCache:null,slatCoordCache:null,constructor:function constructor(){Grid.apply(this,arguments);// call the super-constructor
this.processOptions();},// Renders the time grid into `this.el`, which should already be assigned.
// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
renderDates:function renderDates(){this.el.html(this.renderHtml());this.colEls=this.el.find('.fc-day');this.slatContainerEl=this.el.find('.fc-slats');this.slatEls=this.slatContainerEl.find('tr');this.colCoordCache=new CoordCache({els:this.colEls,isHorizontal:true});this.slatCoordCache=new CoordCache({els:this.slatEls,isVertical:true});this.renderContentSkeleton();},// Renders the basic HTML skeleton for the grid
renderHtml:function renderHtml(){return''+'<div class="fc-bg">'+'<table>'+this.renderBgTrHtml(0)+// row=0
'</table>'+'</div>'+'<div class="fc-slats">'+'<table>'+this.renderSlatRowHtml()+'</table>'+'</div>';},// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
renderSlatRowHtml:function renderSlatRowHtml(){var view=this.view;var isRTL=this.isRTL;var html='';var slotTime=moment.duration(+this.minTime);// wish there was .clone() for durations
var slotDate;// will be on the view's first day, but we only care about its time
var isLabeled;var axisHtml;// Calculate the time for each slot
while(slotTime<this.maxTime){slotDate=this.start.clone().time(slotTime);isLabeled=isInt(divideDurationByDuration(slotTime,this.labelInterval));axisHtml='<td class="fc-axis fc-time '+view.widgetContentClass+'" '+view.axisStyleAttr()+'>'+(isLabeled?'<span>'+// for matchCellWidths
htmlEscape(slotDate.format(this.labelFormat))+'</span>':'')+'</td>';html+='<tr data-time="'+slotDate.format('HH:mm:ss')+'"'+(isLabeled?'':' class="fc-minor"')+'>'+(!isRTL?axisHtml:'')+'<td class="'+view.widgetContentClass+'"/>'+(isRTL?axisHtml:'')+"</tr>";slotTime.add(this.slotDuration);}return html;},/* Options
	------------------------------------------------------------------------------------------------------------------*/// Parses various options into properties of this object
processOptions:function processOptions(){var view=this.view;var slotDuration=view.opt('slotDuration');var snapDuration=view.opt('snapDuration');var input;slotDuration=moment.duration(slotDuration);snapDuration=snapDuration?moment.duration(snapDuration):slotDuration;this.slotDuration=slotDuration;this.snapDuration=snapDuration;this.snapsPerSlot=slotDuration/snapDuration;// TODO: ensure an integer multiple?
this.minResizeDuration=snapDuration;// hack
this.minTime=moment.duration(view.opt('minTime'));this.maxTime=moment.duration(view.opt('maxTime'));// might be an array value (for TimelineView).
// if so, getting the most granular entry (the last one probably).
input=view.opt('slotLabelFormat');if($.isArray(input)){input=input[input.length-1];}this.labelFormat=input||view.opt('axisFormat')||// deprecated
view.opt('smallTimeFormat');// the computed default
input=view.opt('slotLabelInterval');this.labelInterval=input?moment.duration(input):this.computeLabelInterval(slotDuration);},// Computes an automatic value for slotLabelInterval
computeLabelInterval:function computeLabelInterval(slotDuration){var i;var labelInterval;var slotsPerLabel;// find the smallest stock label interval that results in more than one slots-per-label
for(i=AGENDA_STOCK_SUB_DURATIONS.length-1;i>=0;i--){labelInterval=moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);slotsPerLabel=divideDurationByDuration(labelInterval,slotDuration);if(isInt(slotsPerLabel)&&slotsPerLabel>1){return labelInterval;}}return moment.duration(slotDuration);// fall back. clone
},// Computes a default event time formatting string if `timeFormat` is not explicitly defined
computeEventTimeFormat:function computeEventTimeFormat(){return this.view.opt('noMeridiemTimeFormat');// like "6:30" (no AM/PM)
},// Computes a default `displayEventEnd` value if one is not expliclty defined
computeDisplayEventEnd:function computeDisplayEventEnd(){return true;},/* Hit System
	------------------------------------------------------------------------------------------------------------------*/prepareHits:function prepareHits(){this.colCoordCache.build();this.slatCoordCache.build();},releaseHits:function releaseHits(){this.colCoordCache.clear();// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
},queryHit:function queryHit(leftOffset,topOffset){var snapsPerSlot=this.snapsPerSlot;var colCoordCache=this.colCoordCache;var slatCoordCache=this.slatCoordCache;var colIndex=colCoordCache.getHorizontalIndex(leftOffset);var slatIndex=slatCoordCache.getVerticalIndex(topOffset);if(colIndex!=null&&slatIndex!=null){var slatTop=slatCoordCache.getTopOffset(slatIndex);var slatHeight=slatCoordCache.getHeight(slatIndex);var partial=(topOffset-slatTop)/slatHeight;// floating point number between 0 and 1
var localSnapIndex=Math.floor(partial*snapsPerSlot);// the snap # relative to start of slat
var snapIndex=slatIndex*snapsPerSlot+localSnapIndex;var snapTop=slatTop+localSnapIndex/snapsPerSlot*slatHeight;var snapBottom=slatTop+(localSnapIndex+1)/snapsPerSlot*slatHeight;return{col:colIndex,snap:snapIndex,component:this,// needed unfortunately :(
left:colCoordCache.getLeftOffset(colIndex),right:colCoordCache.getRightOffset(colIndex),top:snapTop,bottom:snapBottom};}},getHitSpan:function getHitSpan(hit){var start=this.getCellDate(0,hit.col);// row=0
var time=this.computeSnapTime(hit.snap);// pass in the snap-index
var end;start.time(time);end=start.clone().add(this.snapDuration);return{start:start,end:end};},getHitEl:function getHitEl(hit){return this.colEls.eq(hit.col);},/* Dates
	------------------------------------------------------------------------------------------------------------------*/rangeUpdated:function rangeUpdated(){this.updateDayTable();},// Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
computeSnapTime:function computeSnapTime(snapIndex){return moment.duration(this.minTime+this.snapDuration*snapIndex);},// Slices up the given span (unzoned start/end with other misc data) into an array of segments
spanToSegs:function spanToSegs(span){var segs=this.sliceRangeByTimes(span);var i;for(i=0;i<segs.length;i++){if(this.isRTL){segs[i].col=this.daysPerRow-1-segs[i].dayIndex;}else{segs[i].col=segs[i].dayIndex;}}return segs;},sliceRangeByTimes:function sliceRangeByTimes(range){var segs=[];var seg;var dayIndex;var dayDate;var dayRange;for(dayIndex=0;dayIndex<this.daysPerRow;dayIndex++){dayDate=this.dayDates[dayIndex].clone();// TODO: better API for this?
dayRange={start:dayDate.clone().time(this.minTime),end:dayDate.clone().time(this.maxTime)};seg=intersectRanges(range,dayRange);// both will be ambig timezone
if(seg){seg.dayIndex=dayIndex;segs.push(seg);}}return segs;},/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/updateSize:function updateSize(isResize){// NOT a standard Grid method
this.slatCoordCache.build();if(isResize){this.updateSegVerticals([].concat(this.fgSegs||[],this.bgSegs||[],this.businessSegs||[]));}},getTotalSlatHeight:function getTotalSlatHeight(){return this.slatContainerEl.outerHeight();},// Computes the top coordinate, relative to the bounds of the grid, of the given date.
// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
computeDateTop:function computeDateTop(date,startOfDayDate){return this.computeTimeTop(moment.duration(date-startOfDayDate.clone().stripTime()));},// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
computeTimeTop:function computeTimeTop(time){var len=this.slatEls.length;var slatCoverage=(time-this.minTime)/this.slotDuration;// floating-point value of # of slots covered
var slatIndex;var slatRemainder;// compute a floating-point number for how many slats should be progressed through.
// from 0 to number of slats (inclusive)
// constrained because minTime/maxTime might be customized.
slatCoverage=Math.max(0,slatCoverage);slatCoverage=Math.min(len,slatCoverage);// an integer index of the furthest whole slat
// from 0 to number slats (*exclusive*, so len-1)
slatIndex=Math.floor(slatCoverage);slatIndex=Math.min(slatIndex,len-1);// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
// could be 1.0 if slatCoverage is covering *all* the slots
slatRemainder=slatCoverage-slatIndex;return this.slatCoordCache.getTopPosition(slatIndex)+this.slatCoordCache.getHeight(slatIndex)*slatRemainder;},/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of an event being dragged over the specified date(s).
// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function renderDrag(eventLocation,seg){if(seg){// if there is event information for this drag, render a helper event
// returns mock event elements
// signal that a helper has been rendered
return this.renderEventLocationHelper(eventLocation,seg);}else{// otherwise, just render a highlight
this.renderHighlight(this.eventToSpan(eventLocation));}},// Unrenders any visual indication of an event being dragged
unrenderDrag:function unrenderDrag(){this.unrenderHelper();this.unrenderHighlight();},/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of an event being resized
renderEventResize:function renderEventResize(eventLocation,seg){return this.renderEventLocationHelper(eventLocation,seg);// returns mock event elements
},// Unrenders any visual indication of an event being resized
unrenderEventResize:function unrenderEventResize(){this.unrenderHelper();},/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
renderHelper:function renderHelper(event,sourceSeg){return this.renderHelperSegs(this.eventToSegs(event),sourceSeg);// returns mock event elements
},// Unrenders any mock helper event
unrenderHelper:function unrenderHelper(){this.unrenderHelperSegs();},/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/renderBusinessHours:function renderBusinessHours(){var events=this.view.calendar.getBusinessHoursEvents();var segs=this.eventsToSegs(events);this.renderBusinessSegs(segs);},unrenderBusinessHours:function unrenderBusinessHours(){this.unrenderBusinessSegs();},/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/getNowIndicatorUnit:function getNowIndicatorUnit(){return'minute';// will refresh on the minute
},renderNowIndicator:function renderNowIndicator(date){// seg system might be overkill, but it handles scenario where line needs to be rendered
//  more than once because of columns with the same date (resources columns for example)
var segs=this.spanToSegs({start:date,end:date});var top=this.computeDateTop(date,date);var nodes=[];var i;// render lines within the columns
for(i=0;i<segs.length;i++){nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>').css('top',top).appendTo(this.colContainerEls.eq(segs[i].col))[0]);}// render an arrow over the axis
if(segs.length>0){// is the current time in view?
nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>').css('top',top).appendTo(this.el.find('.fc-content-skeleton'))[0]);}this.nowIndicatorEls=$(nodes);},unrenderNowIndicator:function unrenderNowIndicator(){if(this.nowIndicatorEls){this.nowIndicatorEls.remove();this.nowIndicatorEls=null;}},/* Selection
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
renderSelection:function renderSelection(span){if(this.view.opt('selectHelper')){// this setting signals that a mock helper event should be rendered
// normally acceps an eventLocation, span has a start/end, which is good enough
this.renderEventLocationHelper(span);}else{this.renderHighlight(span);}},// Unrenders any visual indication of a selection
unrenderSelection:function unrenderSelection(){this.unrenderHelper();this.unrenderHighlight();},/* Highlight
	------------------------------------------------------------------------------------------------------------------*/renderHighlight:function renderHighlight(span){this.renderHighlightSegs(this.spanToSegs(span));},unrenderHighlight:function unrenderHighlight(){this.unrenderHighlightSegs();}});;;/* Methods for rendering SEGMENTS, pieces of content that live on the view
 ( this file is no longer just for events )
----------------------------------------------------------------------------------------------------------------------*/TimeGrid.mixin({colContainerEls:null,// containers for each column
// inner-containers for each column where different types of segs live
fgContainerEls:null,bgContainerEls:null,helperContainerEls:null,highlightContainerEls:null,businessContainerEls:null,// arrays of different types of displayed segments
fgSegs:null,bgSegs:null,helperSegs:null,highlightSegs:null,businessSegs:null,// Renders the DOM that the view's content will live in
renderContentSkeleton:function renderContentSkeleton(){var cellHtml='';var i;var skeletonEl;for(i=0;i<this.colCnt;i++){cellHtml+='<td>'+'<div class="fc-content-col">'+'<div class="fc-event-container fc-helper-container"></div>'+'<div class="fc-event-container"></div>'+'<div class="fc-highlight-container"></div>'+'<div class="fc-bgevent-container"></div>'+'<div class="fc-business-container"></div>'+'</div>'+'</td>';}skeletonEl=$('<div class="fc-content-skeleton">'+'<table>'+'<tr>'+cellHtml+'</tr>'+'</table>'+'</div>');this.colContainerEls=skeletonEl.find('.fc-content-col');this.helperContainerEls=skeletonEl.find('.fc-helper-container');this.fgContainerEls=skeletonEl.find('.fc-event-container:not(.fc-helper-container)');this.bgContainerEls=skeletonEl.find('.fc-bgevent-container');this.highlightContainerEls=skeletonEl.find('.fc-highlight-container');this.businessContainerEls=skeletonEl.find('.fc-business-container');this.bookendCells(skeletonEl.find('tr'));// TODO: do this on string level
this.el.append(skeletonEl);},/* Foreground Events
	------------------------------------------------------------------------------------------------------------------*/renderFgSegs:function renderFgSegs(segs){segs=this.renderFgSegsIntoContainers(segs,this.fgContainerEls);this.fgSegs=segs;return segs;// needed for Grid::renderEvents
},unrenderFgSegs:function unrenderFgSegs(){this.unrenderNamedSegs('fgSegs');},/* Foreground Helper Events
	------------------------------------------------------------------------------------------------------------------*/renderHelperSegs:function renderHelperSegs(segs,sourceSeg){var helperEls=[];var i,seg;var sourceEl;segs=this.renderFgSegsIntoContainers(segs,this.helperContainerEls);// Try to make the segment that is in the same row as sourceSeg look the same
for(i=0;i<segs.length;i++){seg=segs[i];if(sourceSeg&&sourceSeg.col===seg.col){sourceEl=sourceSeg.el;seg.el.css({left:sourceEl.css('left'),right:sourceEl.css('right'),'margin-left':sourceEl.css('margin-left'),'margin-right':sourceEl.css('margin-right')});}helperEls.push(seg.el[0]);}this.helperSegs=segs;return $(helperEls);// must return rendered helpers
},unrenderHelperSegs:function unrenderHelperSegs(){this.unrenderNamedSegs('helperSegs');},/* Background Events
	------------------------------------------------------------------------------------------------------------------*/renderBgSegs:function renderBgSegs(segs){segs=this.renderFillSegEls('bgEvent',segs);// TODO: old fill system
this.updateSegVerticals(segs);this.attachSegsByCol(this.groupSegsByCol(segs),this.bgContainerEls);this.bgSegs=segs;return segs;// needed for Grid::renderEvents
},unrenderBgSegs:function unrenderBgSegs(){this.unrenderNamedSegs('bgSegs');},/* Highlight
	------------------------------------------------------------------------------------------------------------------*/renderHighlightSegs:function renderHighlightSegs(segs){segs=this.renderFillSegEls('highlight',segs);// TODO: old fill system
this.updateSegVerticals(segs);this.attachSegsByCol(this.groupSegsByCol(segs),this.highlightContainerEls);this.highlightSegs=segs;},unrenderHighlightSegs:function unrenderHighlightSegs(){this.unrenderNamedSegs('highlightSegs');},/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/renderBusinessSegs:function renderBusinessSegs(segs){segs=this.renderFillSegEls('businessHours',segs);// TODO: old fill system
this.updateSegVerticals(segs);this.attachSegsByCol(this.groupSegsByCol(segs),this.businessContainerEls);this.businessSegs=segs;},unrenderBusinessSegs:function unrenderBusinessSegs(){this.unrenderNamedSegs('businessSegs');},/* Seg Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
groupSegsByCol:function groupSegsByCol(segs){var segsByCol=[];var i;for(i=0;i<this.colCnt;i++){segsByCol.push([]);}for(i=0;i<segs.length;i++){segsByCol[segs[i].col].push(segs[i]);}return segsByCol;},// Given segments grouped by column, insert the segments' elements into a parallel array of container
// elements, each living within a column.
attachSegsByCol:function attachSegsByCol(segsByCol,containerEls){var col;var segs;var i;for(col=0;col<this.colCnt;col++){// iterate each column grouping
segs=segsByCol[col];for(i=0;i<segs.length;i++){containerEls.eq(col).append(segs[i].el);}}},// Given the name of a property of `this` object, assumed to be an array of segments,
// loops through each segment and removes from DOM. Will null-out the property afterwards.
unrenderNamedSegs:function unrenderNamedSegs(propName){var segs=this[propName];var i;if(segs){for(i=0;i<segs.length;i++){segs[i].el.remove();}this[propName]=null;}},/* Foreground Event Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/// Given an array of foreground segments, render a DOM element for each, computes position,
// and attaches to the column inner-container elements.
renderFgSegsIntoContainers:function renderFgSegsIntoContainers(segs,containerEls){var segsByCol;var col;segs=this.renderFgSegEls(segs);// will call fgSegHtml
segsByCol=this.groupSegsByCol(segs);for(col=0;col<this.colCnt;col++){this.updateFgSegCoords(segsByCol[col]);}this.attachSegsByCol(segsByCol,containerEls);return segs;},// Renders the HTML for a single event segment's default rendering
fgSegHtml:function fgSegHtml(seg,disableResizing){var view=this.view;var event=seg.event;var isDraggable=view.isEventDraggable(event);var isResizableFromStart=!disableResizing&&seg.isStart&&view.isEventResizableFromStart(event);var isResizableFromEnd=!disableResizing&&seg.isEnd&&view.isEventResizableFromEnd(event);var classes=this.getSegClasses(seg,isDraggable,isResizableFromStart||isResizableFromEnd);var skinCss=cssToStr(this.getSegSkinCss(seg));var timeText;var fullTimeText;// more verbose time text. for the print stylesheet
var startTimeText;// just the start time text
classes.unshift('fc-time-grid-event','fc-v-event');if(view.isMultiDayEvent(event)){// if the event appears to span more than one day...
// Don't display time text on segments that run entirely through a day.
// That would appear as midnight-midnight and would look dumb.
// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
if(seg.isStart||seg.isEnd){timeText=this.getEventTimeText(seg);fullTimeText=this.getEventTimeText(seg,'LT');startTimeText=this.getEventTimeText(seg,null,false);// displayEnd=false
}}else{// Display the normal time text for the *event's* times
timeText=this.getEventTimeText(event);fullTimeText=this.getEventTimeText(event,'LT');startTimeText=this.getEventTimeText(event,null,false);// displayEnd=false
}return'<a class="'+classes.join(' ')+'"'+(event.url?' href="'+htmlEscape(event.url)+'"':'')+(skinCss?' style="'+skinCss+'"':'')+'>'+'<div class="fc-content">'+(timeText?'<div class="fc-time"'+' data-start="'+htmlEscape(startTimeText)+'"'+' data-full="'+htmlEscape(fullTimeText)+'"'+'>'+'<span>'+htmlEscape(timeText)+'</span>'+'</div>':'')+(event.title?'<div class="fc-title">'+htmlEscape(event.title)+'</div>':'')+'</div>'+'<div class="fc-bg"/>'+(/* TODO: write CSS for this
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				*/isResizableFromEnd?'<div class="fc-resizer fc-end-resizer" />':'')+'</a>';},/* Seg Position Utils
	------------------------------------------------------------------------------------------------------------------*/// Refreshes the CSS top/bottom coordinates for each segment element.
// Works when called after initial render, after a window resize/zoom for example.
updateSegVerticals:function updateSegVerticals(segs){this.computeSegVerticals(segs);this.assignSegVerticals(segs);},// For each segment in an array, computes and assigns its top and bottom properties
computeSegVerticals:function computeSegVerticals(segs){var i,seg;for(i=0;i<segs.length;i++){seg=segs[i];seg.top=this.computeDateTop(seg.start,seg.start);seg.bottom=this.computeDateTop(seg.end,seg.start);}},// Given segments that already have their top/bottom properties computed, applies those values to
// the segments' elements.
assignSegVerticals:function assignSegVerticals(segs){var i,seg;for(i=0;i<segs.length;i++){seg=segs[i];seg.el.css(this.generateSegVerticalCss(seg));}},// Generates an object with CSS properties for the top/bottom coordinates of a segment element
generateSegVerticalCss:function generateSegVerticalCss(seg){return{top:seg.top,bottom:-seg.bottom// flipped because needs to be space beyond bottom edge of event container
};},/* Foreground Event Positioning Utils
	------------------------------------------------------------------------------------------------------------------*/// Given segments that are assumed to all live in the *same column*,
// compute their verical/horizontal coordinates and assign to their elements.
updateFgSegCoords:function updateFgSegCoords(segs){this.computeSegVerticals(segs);// horizontals relies on this
this.computeFgSegHorizontals(segs);// compute horizontal coordinates, z-index's, and reorder the array
this.assignSegVerticals(segs);this.assignFgSegHorizontals(segs);},// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
// NOTE: Also reorders the given array by date!
computeFgSegHorizontals:function computeFgSegHorizontals(segs){var levels;var level0;var i;this.sortEventSegs(segs);// order by certain criteria
levels=buildSlotSegLevels(segs);computeForwardSlotSegs(levels);if(level0=levels[0]){for(i=0;i<level0.length;i++){computeSlotSegPressures(level0[i]);}for(i=0;i<level0.length;i++){this.computeFgSegForwardBack(level0[i],0,0);}}},// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a "series", which means consecutive segments with the same pressure
// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
computeFgSegForwardBack:function computeFgSegForwardBack(seg,seriesBackwardPressure,seriesBackwardCoord){var forwardSegs=seg.forwardSegs;var i;if(seg.forwardCoord===undefined){// not already computed
if(!forwardSegs.length){// if there are no forward segments, this segment should butt up against the edge
seg.forwardCoord=1;}else{// sort highest pressure first
this.sortForwardSegs(forwardSegs);// this segment's forwardCoord will be calculated from the backwardCoord of the
// highest-pressure forward segment.
this.computeFgSegForwardBack(forwardSegs[0],seriesBackwardPressure+1,seriesBackwardCoord);seg.forwardCoord=forwardSegs[0].backwardCoord;}// calculate the backwardCoord from the forwardCoord. consider the series
seg.backwardCoord=seg.forwardCoord-(seg.forwardCoord-seriesBackwardCoord)/(// available width for series
seriesBackwardPressure+1);// # of segments in the series
// use this segment's coordinates to computed the coordinates of the less-pressurized
// forward segments
for(i=0;i<forwardSegs.length;i++){this.computeFgSegForwardBack(forwardSegs[i],0,seg.forwardCoord);}}},sortForwardSegs:function sortForwardSegs(forwardSegs){forwardSegs.sort(proxy(this,'compareForwardSegs'));},// A cmp function for determining which forward segment to rely on more when computing coordinates.
compareForwardSegs:function compareForwardSegs(seg1,seg2){// put higher-pressure first
return seg2.forwardPressure-seg1.forwardPressure||// put segments that are closer to initial edge first (and favor ones with no coords yet)
(seg1.backwardCoord||0)-(seg2.backwardCoord||0)||// do normal sorting...
this.compareEventSegs(seg1,seg2);},// Given foreground event segments that have already had their position coordinates computed,
// assigns position-related CSS values to their elements.
assignFgSegHorizontals:function assignFgSegHorizontals(segs){var i,seg;for(i=0;i<segs.length;i++){seg=segs[i];seg.el.css(this.generateFgSegHorizontalCss(seg));// if the height is short, add a className for alternate styling
if(seg.bottom-seg.top<30){seg.el.addClass('fc-short');}}},// Generates an object with CSS properties/values that should be applied to an event segment element.
// Contains important positioning-related properties that should be applied to any event element, customized or not.
generateFgSegHorizontalCss:function generateFgSegHorizontalCss(seg){var shouldOverlap=this.view.opt('slotEventOverlap');var backwardCoord=seg.backwardCoord;// the left side if LTR. the right side if RTL. floating-point
var forwardCoord=seg.forwardCoord;// the right side if LTR. the left side if RTL. floating-point
var props=this.generateSegVerticalCss(seg);// get top/bottom first
var left;// amount of space from left edge, a fraction of the total width
var right;// amount of space from right edge, a fraction of the total width
if(shouldOverlap){// double the width, but don't go beyond the maximum forward coordinate (1.0)
forwardCoord=Math.min(1,backwardCoord+(forwardCoord-backwardCoord)*2);}if(this.isRTL){left=1-forwardCoord;right=backwardCoord;}else{left=backwardCoord;right=1-forwardCoord;}props.zIndex=seg.level+1;// convert from 0-base to 1-based
props.left=left*100+'%';props.right=right*100+'%';if(shouldOverlap&&seg.forwardPressure){// add padding to the edge so that forward stacked events don't cover the resizer's icon
props[this.isRTL?'marginLeft':'marginRight']=10*2;// 10 is a guesstimate of the icon's width
}return props;}});// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs){var levels=[];var i,seg;var j;for(i=0;i<segs.length;i++){seg=segs[i];// go through all the levels and stop on the first level where there are no collisions
for(j=0;j<levels.length;j++){if(!computeSlotSegCollisions(seg,levels[j]).length){break;}}seg.level=j;(levels[j]||(levels[j]=[])).push(seg);}return levels;}// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels){var i,level;var j,seg;var k;for(i=0;i<levels.length;i++){level=levels[i];for(j=0;j<level.length;j++){seg=level[j];seg.forwardSegs=[];for(k=i+1;k<levels.length;k++){computeSlotSegCollisions(seg,levels[k],seg.forwardSegs);}}}}// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg){var forwardSegs=seg.forwardSegs;var forwardPressure=0;var i,forwardSeg;if(seg.forwardPressure===undefined){// not already computed
for(i=0;i<forwardSegs.length;i++){forwardSeg=forwardSegs[i];// figure out the child's maximum forward path
computeSlotSegPressures(forwardSeg);// either use the existing maximum, or use the child's forward pressure
// plus one (for the forwardSeg itself)
forwardPressure=Math.max(forwardPressure,1+forwardSeg.forwardPressure);}seg.forwardPressure=forwardPressure;}}// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg,otherSegs,results){results=results||[];for(var i=0;i<otherSegs.length;i++){if(isSlotSegCollision(seg,otherSegs[i])){results.push(otherSegs[i]);}}return results;}// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1,seg2){return seg1.bottom>seg2.top&&seg1.top<seg2.bottom;};;/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/var View=FC.View=Class.extend(EmitterMixin,ListenerMixin,{type:null,// subclass' view name (string)
name:null,// deprecated. use `type` instead
title:null,// the text that will be displayed in the header's title
calendar:null,// owner Calendar object
options:null,// hash containing all options. already merged with view-specific-options
el:null,// the view's containing element. set by Calendar
displaying:null,// a promise representing the state of rendering. null if no render requested
isSkeletonRendered:false,isEventsRendered:false,// range the view is actually displaying (moments)
start:null,end:null,// exclusive
// range the view is formally responsible for (moments)
// may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates
intervalStart:null,intervalEnd:null,// exclusive
intervalDuration:null,intervalUnit:null,// name of largest unit being displayed, like "month" or "week"
isRTL:false,isSelected:false,// boolean whether a range of time is user-selected or not
selectedEvent:null,eventOrderSpecs:null,// criteria for ordering events when they have same date/time
// classNames styled by jqui themes
widgetHeaderClass:null,widgetContentClass:null,highlightStateClass:null,// for date utils, computed from options
nextDayThreshold:null,isHiddenDayHash:null,// now indicator
isNowIndicatorRendered:null,initialNowDate:null,// result first getNow call
initialNowQueriedMs:null,// ms time the getNow was called
nowIndicatorTimeoutID:null,// for refresh timing of now indicator
nowIndicatorIntervalID:null,// "
constructor:function constructor(calendar,type,options,intervalDuration){this.calendar=calendar;this.type=this.name=type;// .name is deprecated
this.options=options;this.intervalDuration=intervalDuration||moment.duration(1,'day');this.nextDayThreshold=moment.duration(this.opt('nextDayThreshold'));this.initThemingProps();this.initHiddenDays();this.isRTL=this.opt('isRTL');this.eventOrderSpecs=parseFieldSpecs(this.opt('eventOrder'));this.initialize();},// A good place for subclasses to initialize member variables
initialize:function initialize(){// subclasses can implement
},// Retrieves an option with the given name
opt:function opt(name){return this.options[name];},// Triggers handlers that are view-related. Modifies args before passing to calendar.
trigger:function trigger(name,thisObj){// arguments beyond thisObj are passed along
var calendar=this.calendar;return calendar.trigger.apply(calendar,[name,thisObj||this].concat(Array.prototype.slice.call(arguments,2),// arguments beyond thisObj
[this]// always make the last argument a reference to the view. TODO: deprecate
));},/* Dates
	------------------------------------------------------------------------------------------------------------------*/// Updates all internal dates to center around the given current unzoned date.
setDate:function setDate(date){this.setRange(this.computeRange(date));},// Updates all internal dates for displaying the given unzoned range.
setRange:function setRange(range){$.extend(this,range);// assigns every property to this object's member variables
this.updateTitle();},// Given a single current unzoned date, produce information about what range to display.
// Subclasses can override. Must return all properties.
computeRange:function computeRange(date){var intervalUnit=computeIntervalUnit(this.intervalDuration);var intervalStart=date.clone().startOf(intervalUnit);var intervalEnd=intervalStart.clone().add(this.intervalDuration);var start,end;// normalize the range's time-ambiguity
if(/year|month|week|day/.test(intervalUnit)){// whole-days?
intervalStart.stripTime();intervalEnd.stripTime();}else{// needs to have a time?
if(!intervalStart.hasTime()){intervalStart=this.calendar.time(0);// give 00:00 time
}if(!intervalEnd.hasTime()){intervalEnd=this.calendar.time(0);// give 00:00 time
}}start=intervalStart.clone();start=this.skipHiddenDays(start);end=intervalEnd.clone();end=this.skipHiddenDays(end,-1,true);// exclusively move backwards
return{intervalUnit:intervalUnit,intervalStart:intervalStart,intervalEnd:intervalEnd,start:start,end:end};},// Computes the new date when the user hits the prev button, given the current date
computePrevDate:function computePrevDate(date){return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration),-1);},// Computes the new date when the user hits the next button, given the current date
computeNextDate:function computeNextDate(date){return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).add(this.intervalDuration));},// Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely
// visible. `direction` is optional and indicates which direction the current date was being
// incremented or decremented (1 or -1).
massageCurrentDate:function massageCurrentDate(date,direction){if(this.intervalDuration.as('days')<=1){// if the view displays a single day or smaller
if(this.isHiddenDay(date)){date=this.skipHiddenDays(date,direction);date.startOf('day');}}return date;},/* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/// Sets the view's title property to the most updated computed value
updateTitle:function updateTitle(){this.title=this.computeTitle();},// Computes what the title at the top of the calendar should be for this view
computeTitle:function computeTitle(){return this.formatRange({// in case intervalStart/End has a time, make sure timezone is correct
start:this.calendar.applyTimezone(this.intervalStart),end:this.calendar.applyTimezone(this.intervalEnd)},this.opt('titleFormat')||this.computeTitleFormat(),this.opt('titleRangeSeparator'));},// Generates the format string that should be used to generate the title for the current date range.
// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
computeTitleFormat:function computeTitleFormat(){if(this.intervalUnit=='year'){return'YYYY';}else if(this.intervalUnit=='month'){return this.opt('monthYearFormat');// like "September 2014"
}else if(this.intervalDuration.as('days')>1){return'll';// multi-day range. shorter, like "Sep 9 - 10 2014"
}else{return'LL';// one day. longer, like "September 9 2014"
}},// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
// The timezones of the dates within `range` will be respected.
formatRange:function formatRange(range,formatStr,separator){var end=range.end;if(!end.hasTime()){// all-day?
end=end.clone().subtract(1);// convert to inclusive. last ms of previous day
}return _formatRange(range.start,end,formatStr,separator,this.opt('isRTL'));},/* Rendering
	------------------------------------------------------------------------------------------------------------------*/// Sets the container element that the view should render inside of.
// Does other DOM-related initializations.
setElement:function setElement(el){this.el=el;this.bindGlobalHandlers();},// Removes the view's container element from the DOM, clearing any content beforehand.
// Undoes any other DOM-related attachments.
removeElement:function removeElement(){this.clear();// clears all content
// clean up the skeleton
if(this.isSkeletonRendered){this.unrenderSkeleton();this.isSkeletonRendered=false;}this.unbindGlobalHandlers();this.el.remove();// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
// We don't null-out the View's other jQuery element references upon destroy,
//  so we shouldn't kill this.el either.
},// Does everything necessary to display the view centered around the given unzoned date.
// Does every type of rendering EXCEPT rendering events.
// Is asychronous and returns a promise.
display:function display(date,explicitScrollState){var _this=this;var prevScrollState=null;if(explicitScrollState!=null&&this.displaying){// don't need prevScrollState if explicitScrollState
prevScrollState=this.queryScroll();}this.calendar.freezeContentHeight();return syncThen(this.clear(),function(){// clear the content first
return _this.displaying=syncThen(_this.displayView(date),function(){// displayView might return a promise
// caller of display() wants a specific scroll state?
if(explicitScrollState!=null){// we make an assumption that this is NOT the initial render,
// and thus don't need forceScroll (is inconveniently asynchronous)
_this.setScroll(explicitScrollState);}else{_this.forceScroll(_this.computeInitialScroll(prevScrollState));}_this.calendar.unfreezeContentHeight();_this.triggerRender();});});},// Does everything necessary to clear the content of the view.
// Clears dates and events. Does not clear the skeleton.
// Is asychronous and returns a promise.
clear:function clear(){var _this=this;var displaying=this.displaying;if(displaying){// previously displayed, or in the process of being displayed?
return syncThen(displaying,function(){// wait for the display to finish
_this.displaying=null;_this.clearEvents();return _this.clearView();// might return a promise. chain it
});}else{return $.when();// an immediately-resolved promise
}},// Displays the view's non-event content, such as date-related content or anything required by events.
// Renders the view's non-content skeleton if necessary.
// Can be asynchronous and return a promise.
displayView:function displayView(date){if(!this.isSkeletonRendered){this.renderSkeleton();this.isSkeletonRendered=true;}if(date){this.setDate(date);}if(this.render){this.render();// TODO: deprecate
}this.renderDates();this.updateSize();this.renderBusinessHours();// might need coordinates, so should go after updateSize()
this.startNowIndicator();},// Unrenders the view content that was rendered in displayView.
// Can be asynchronous and return a promise.
clearView:function clearView(){this.unselect();this.stopNowIndicator();this.triggerUnrender();this.unrenderBusinessHours();this.unrenderDates();if(this.destroy){this.destroy();// TODO: deprecate
}},// Renders the basic structure of the view before any content is rendered
renderSkeleton:function renderSkeleton(){// subclasses should implement
},// Unrenders the basic structure of the view
unrenderSkeleton:function unrenderSkeleton(){// subclasses should implement
},// Renders the view's date-related content.
// Assumes setRange has already been called and the skeleton has already been rendered.
renderDates:function renderDates(){// subclasses should implement
},// Unrenders the view's date-related content
unrenderDates:function unrenderDates(){// subclasses should override
},// Signals that the view's content has been rendered
triggerRender:function triggerRender(){this.trigger('viewRender',this,this,this.el);},// Signals that the view's content is about to be unrendered
triggerUnrender:function triggerUnrender(){this.trigger('viewDestroy',this,this,this.el);},// Binds DOM handlers to elements that reside outside the view container, such as the document
bindGlobalHandlers:function bindGlobalHandlers(){this.listenTo($(document),'mousedown',this.handleDocumentMousedown);this.listenTo($(document),'touchstart',this.processUnselect);},// Unbinds DOM handlers from elements that reside outside the view container
unbindGlobalHandlers:function unbindGlobalHandlers(){this.stopListeningTo($(document));},// Initializes internal variables related to theming
initThemingProps:function initThemingProps(){var tm=this.opt('theme')?'ui':'fc';this.widgetHeaderClass=tm+'-widget-header';this.widgetContentClass=tm+'-widget-content';this.highlightStateClass=tm+'-state-highlight';},/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/// Renders business-hours onto the view. Assumes updateSize has already been called.
renderBusinessHours:function renderBusinessHours(){// subclasses should implement
},// Unrenders previously-rendered business-hours
unrenderBusinessHours:function unrenderBusinessHours(){// subclasses should implement
},/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/// Immediately render the current time indicator and begins re-rendering it at an interval,
// which is defined by this.getNowIndicatorUnit().
// TODO: somehow do this for the current whole day's background too
startNowIndicator:function startNowIndicator(){var _this=this;var unit;var update;var delay;// ms wait value
if(this.opt('nowIndicator')){unit=this.getNowIndicatorUnit();if(unit){update=proxy(this,'updateNowIndicator');// bind to `this`
this.initialNowDate=this.calendar.getNow();this.initialNowQueriedMs=+new Date();this.renderNowIndicator(this.initialNowDate);this.isNowIndicatorRendered=true;// wait until the beginning of the next interval
delay=this.initialNowDate.clone().startOf(unit).add(1,unit)-this.initialNowDate;this.nowIndicatorTimeoutID=setTimeout(function(){_this.nowIndicatorTimeoutID=null;update();delay=+moment.duration(1,unit);delay=Math.max(100,delay);// prevent too frequent
_this.nowIndicatorIntervalID=setInterval(update,delay);// update every interval
},delay);}}},// rerenders the now indicator, computing the new current time from the amount of time that has passed
// since the initial getNow call.
updateNowIndicator:function updateNowIndicator(){if(this.isNowIndicatorRendered){this.unrenderNowIndicator();this.renderNowIndicator(this.initialNowDate.clone().add(new Date()-this.initialNowQueriedMs)// add ms
);}},// Immediately unrenders the view's current time indicator and stops any re-rendering timers.
// Won't cause side effects if indicator isn't rendered.
stopNowIndicator:function stopNowIndicator(){if(this.isNowIndicatorRendered){if(this.nowIndicatorTimeoutID){clearTimeout(this.nowIndicatorTimeoutID);this.nowIndicatorTimeoutID=null;}if(this.nowIndicatorIntervalID){clearTimeout(this.nowIndicatorIntervalID);this.nowIndicatorIntervalID=null;}this.unrenderNowIndicator();this.isNowIndicatorRendered=false;}},// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
// should be refreshed. If something falsy is returned, no time indicator is rendered at all.
getNowIndicatorUnit:function getNowIndicatorUnit(){// subclasses should implement
},// Renders a current time indicator at the given datetime
renderNowIndicator:function renderNowIndicator(date){// subclasses should implement
},// Undoes the rendering actions from renderNowIndicator
unrenderNowIndicator:function unrenderNowIndicator(){// subclasses should implement
},/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/// Refreshes anything dependant upon sizing of the container element of the grid
updateSize:function updateSize(isResize){var scrollState;if(isResize){scrollState=this.queryScroll();}this.updateHeight(isResize);this.updateWidth(isResize);this.updateNowIndicator();if(isResize){this.setScroll(scrollState);}},// Refreshes the horizontal dimensions of the calendar
updateWidth:function updateWidth(isResize){// subclasses should implement
},// Refreshes the vertical dimensions of the calendar
updateHeight:function updateHeight(isResize){var calendar=this.calendar;// we poll the calendar for height information
this.setHeight(calendar.getSuggestedViewHeight(),calendar.isHeightAuto());},// Updates the vertical dimensions of the calendar to the specified height.
// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
setHeight:function setHeight(height,isAuto){// subclasses should implement
},/* Scroller
	------------------------------------------------------------------------------------------------------------------*/// Computes the initial pre-configured scroll state prior to allowing the user to change it.
// Given the scroll state from the previous rendering. If first time rendering, given null.
computeInitialScroll:function computeInitialScroll(previousScrollState){return 0;},// Retrieves the view's current natural scroll state. Can return an arbitrary format.
queryScroll:function queryScroll(){// subclasses must implement
},// Sets the view's scroll state. Will accept the same format computeInitialScroll and queryScroll produce.
setScroll:function setScroll(scrollState){// subclasses must implement
},// Sets the scroll state, making sure to overcome any predefined scroll value the browser has in mind
forceScroll:function forceScroll(scrollState){var _this=this;this.setScroll(scrollState);setTimeout(function(){_this.setScroll(scrollState);},0);},/* Event Elements / Segments
	------------------------------------------------------------------------------------------------------------------*/// Does everything necessary to display the given events onto the current view
displayEvents:function displayEvents(events){var scrollState=this.queryScroll();this.clearEvents();this.renderEvents(events);this.isEventsRendered=true;this.setScroll(scrollState);this.triggerEventRender();},// Does everything necessary to clear the view's currently-rendered events
clearEvents:function clearEvents(){var scrollState;if(this.isEventsRendered){// TODO: optimize: if we know this is part of a displayEvents call, don't queryScroll/setScroll
scrollState=this.queryScroll();this.triggerEventUnrender();if(this.destroyEvents){this.destroyEvents();// TODO: deprecate
}this.unrenderEvents();this.setScroll(scrollState);this.isEventsRendered=false;}},// Renders the events onto the view.
renderEvents:function renderEvents(events){// subclasses should implement
},// Removes event elements from the view.
unrenderEvents:function unrenderEvents(){// subclasses should implement
},// Signals that all events have been rendered
triggerEventRender:function triggerEventRender(){this.renderedEventSegEach(function(seg){this.trigger('eventAfterRender',seg.event,seg.event,seg.el);});this.trigger('eventAfterAllRender');},// Signals that all event elements are about to be removed
triggerEventUnrender:function triggerEventUnrender(){this.renderedEventSegEach(function(seg){this.trigger('eventDestroy',seg.event,seg.event,seg.el);});},// Given an event and the default element used for rendering, returns the element that should actually be used.
// Basically runs events and elements through the eventRender hook.
resolveEventEl:function resolveEventEl(event,el){var custom=this.trigger('eventRender',event,event,el);if(custom===false){// means don't render at all
el=null;}else if(custom&&custom!==true){el=$(custom);}return el;},// Hides all rendered event segments linked to the given event
showEvent:function showEvent(event){this.renderedEventSegEach(function(seg){seg.el.css('visibility','');},event);},// Shows all rendered event segments linked to the given event
hideEvent:function hideEvent(event){this.renderedEventSegEach(function(seg){seg.el.css('visibility','hidden');},event);},// Iterates through event segments that have been rendered (have an el). Goes through all by default.
// If the optional `event` argument is specified, only iterates through segments linked to that event.
// The `this` value of the callback function will be the view.
renderedEventSegEach:function renderedEventSegEach(func,event){var segs=this.getEventSegs();var i;for(i=0;i<segs.length;i++){if(!event||segs[i].event._id===event._id){if(segs[i].el){func.call(this,segs[i]);}}}},// Retrieves all the rendered segment objects for the view
getEventSegs:function getEventSegs(){// subclasses must implement
return[];},/* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/// Computes if the given event is allowed to be dragged by the user
isEventDraggable:function isEventDraggable(event){var source=event.source||{};return firstDefined(event.startEditable,source.startEditable,this.opt('eventStartEditable'),event.editable,source.editable,this.opt('editable'));},// Must be called when an event in the view is dropped onto new location.
// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
reportEventDrop:function reportEventDrop(event,dropLocation,largeUnit,el,ev){var calendar=this.calendar;var mutateResult=calendar.mutateEvent(event,dropLocation,largeUnit);var undoFunc=function undoFunc(){mutateResult.undo();calendar.reportEventChange();};this.triggerEventDrop(event,mutateResult.dateDelta,undoFunc,el,ev);calendar.reportEventChange();// will rerender events
},// Triggers event-drop handlers that have subscribed via the API
triggerEventDrop:function triggerEventDrop(event,dateDelta,undoFunc,el,ev){this.trigger('eventDrop',el[0],event,dateDelta,undoFunc,ev,{});// {} = jqui dummy
},/* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
// `meta` is the parsed data that has been embedded into the dragging event.
// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
reportExternalDrop:function reportExternalDrop(meta,dropLocation,el,ev,ui){var eventProps=meta.eventProps;var eventInput;var event;// Try to build an event object and render it. TODO: decouple the two
if(eventProps){eventInput=$.extend({},eventProps,dropLocation);event=this.calendar.renderEvent(eventInput,meta.stick)[0];// renderEvent returns an array
}this.triggerExternalDrop(event,dropLocation,el,ev,ui);},// Triggers external-drop handlers that have subscribed via the API
triggerExternalDrop:function triggerExternalDrop(event,dropLocation,el,ev,ui){// trigger 'drop' regardless of whether element represents an event
this.trigger('drop',el[0],dropLocation.start,ev,ui);if(event){this.trigger('eventReceive',null,event);// signal an external event landed
}},/* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of a event or external-element drag over the given drop zone.
// If an external-element, seg will be `null`.
// Must return elements used for any mock events.
renderDrag:function renderDrag(dropLocation,seg){// subclasses must implement
},// Unrenders a visual indication of an event or external-element being dragged.
unrenderDrag:function unrenderDrag(){// subclasses must implement
},/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/// Computes if the given event is allowed to be resized from its starting edge
isEventResizableFromStart:function isEventResizableFromStart(event){return this.opt('eventResizableFromStart')&&this.isEventResizable(event);},// Computes if the given event is allowed to be resized from its ending edge
isEventResizableFromEnd:function isEventResizableFromEnd(event){return this.isEventResizable(event);},// Computes if the given event is allowed to be resized by the user at all
isEventResizable:function isEventResizable(event){var source=event.source||{};return firstDefined(event.durationEditable,source.durationEditable,this.opt('eventDurationEditable'),event.editable,source.editable,this.opt('editable'));},// Must be called when an event in the view has been resized to a new length
reportEventResize:function reportEventResize(event,resizeLocation,largeUnit,el,ev){var calendar=this.calendar;var mutateResult=calendar.mutateEvent(event,resizeLocation,largeUnit);var undoFunc=function undoFunc(){mutateResult.undo();calendar.reportEventChange();};this.triggerEventResize(event,mutateResult.durationDelta,undoFunc,el,ev);calendar.reportEventChange();// will rerender events
},// Triggers event-resize handlers that have subscribed via the API
triggerEventResize:function triggerEventResize(event,durationDelta,undoFunc,el,ev){this.trigger('eventResize',el[0],event,durationDelta,undoFunc,ev,{});// {} = jqui dummy
},/* Selection (time range)
	------------------------------------------------------------------------------------------------------------------*/// Selects a date span on the view. `start` and `end` are both Moments.
// `ev` is the native mouse event that begin the interaction.
select:function select(span,ev){this.unselect(ev);this.renderSelection(span);this.reportSelection(span,ev);},// Renders a visual indication of the selection
renderSelection:function renderSelection(span){// subclasses should implement
},// Called when a new selection is made. Updates internal state and triggers handlers.
reportSelection:function reportSelection(span,ev){this.isSelected=true;this.triggerSelect(span,ev);},// Triggers handlers to 'select'
triggerSelect:function triggerSelect(span,ev){this.trigger('select',null,this.calendar.applyTimezone(span.start),// convert to calendar's tz for external API
this.calendar.applyTimezone(span.end),// "
ev);},// Undoes a selection. updates in the internal state and triggers handlers.
// `ev` is the native mouse event that began the interaction.
unselect:function unselect(ev){if(this.isSelected){this.isSelected=false;if(this.destroySelection){this.destroySelection();// TODO: deprecate
}this.unrenderSelection();this.trigger('unselect',null,ev);}},// Unrenders a visual indication of selection
unrenderSelection:function unrenderSelection(){// subclasses should implement
},/* Event Selection
	------------------------------------------------------------------------------------------------------------------*/selectEvent:function selectEvent(event){if(!this.selectedEvent||this.selectedEvent!==event){this.unselectEvent();this.renderedEventSegEach(function(seg){seg.el.addClass('fc-selected');},event);this.selectedEvent=event;}},unselectEvent:function unselectEvent(){if(this.selectedEvent){this.renderedEventSegEach(function(seg){seg.el.removeClass('fc-selected');},this.selectedEvent);this.selectedEvent=null;}},isEventSelected:function isEventSelected(event){// event references might change on refetchEvents(), while selectedEvent doesn't,
// so compare IDs
return this.selectedEvent&&this.selectedEvent._id===event._id;},/* Mouse / Touch Unselecting (time range & event unselection)
	------------------------------------------------------------------------------------------------------------------*/// TODO: move consistently to down/start or up/end?
// TODO: don't kill previous selection if touch scrolling
handleDocumentMousedown:function handleDocumentMousedown(ev){if(isPrimaryMouseButton(ev)){this.processUnselect(ev);}},processUnselect:function processUnselect(ev){this.processRangeUnselect(ev);this.processEventUnselect(ev);},processRangeUnselect:function processRangeUnselect(ev){var ignore;// is there a time-range selection?
if(this.isSelected&&this.opt('unselectAuto')){// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
ignore=this.opt('unselectCancel');if(!ignore||!$(ev.target).closest(ignore).length){this.unselect(ev);}}},processEventUnselect:function processEventUnselect(ev){if(this.selectedEvent){if(!$(ev.target).closest('.fc-selected').length){this.unselectEvent();}}},/* Day Click
	------------------------------------------------------------------------------------------------------------------*/// Triggers handlers to 'dayClick'
// Span has start/end of the clicked area. Only the start is useful.
triggerDayClick:function triggerDayClick(span,dayEl,ev){this.trigger('dayClick',dayEl,this.calendar.applyTimezone(span.start),// convert to calendar's timezone for external API
ev);},/* Date Utils
	------------------------------------------------------------------------------------------------------------------*/// Initializes internal variables related to calculating hidden days-of-week
initHiddenDays:function initHiddenDays(){var hiddenDays=this.opt('hiddenDays')||[];// array of day-of-week indices that are hidden
var isHiddenDayHash=[];// is the day-of-week hidden? (hash with day-of-week-index -> bool)
var dayCnt=0;var i;if(this.opt('weekends')===false){hiddenDays.push(0,6);// 0=sunday, 6=saturday
}for(i=0;i<7;i++){if(!(isHiddenDayHash[i]=$.inArray(i,hiddenDays)!==-1)){dayCnt++;}}if(!dayCnt){throw'invalid hiddenDays';// all days were hidden? bad.
}this.isHiddenDayHash=isHiddenDayHash;},// Is the current day hidden?
// `day` is a day-of-week index (0-6), or a Moment
isHiddenDay:function isHiddenDay(day){if(moment.isMoment(day)){day=day.day();}return this.isHiddenDayHash[day];},// Incrementing the current day until it is no longer a hidden day, returning a copy.
// If the initial value of `date` is not a hidden day, don't do anything.
// Pass `isExclusive` as `true` if you are dealing with an end date.
// `inc` defaults to `1` (increment one day forward each time)
skipHiddenDays:function skipHiddenDays(date,inc,isExclusive){var out=date.clone();inc=inc||1;while(this.isHiddenDayHash[(out.day()+(isExclusive?inc:0)+7)%7]){out.add(inc,'days');}return out;},// Returns the date range of the full days the given range visually appears to occupy.
// Returns a new range object.
computeDayRange:function computeDayRange(range){var startDay=range.start.clone().stripTime();// the beginning of the day the range starts
var end=range.end;var endDay=null;var endTimeMS;if(end){endDay=end.clone().stripTime();// the beginning of the day the range exclusively ends
endTimeMS=+end.time();// # of milliseconds into `endDay`
// If the end time is actually inclusively part of the next day and is equal to or
// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
if(endTimeMS&&endTimeMS>=this.nextDayThreshold){endDay.add(1,'days');}}// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
// assign the default duration of one day.
if(!end||endDay<=startDay){endDay=startDay.clone().add(1,'days');}return{start:startDay,end:endDay};},// Does the given event visually appear to occupy more than one day?
isMultiDayEvent:function isMultiDayEvent(event){var range=this.computeDayRange(event);// event is range-ish
return range.end.diff(range.start,'days')>1;}});;;/*
Embodies a div that has potential scrollbars
*/var Scroller=FC.Scroller=Class.extend({el:null,// the guaranteed outer element
scrollEl:null,// the element with the scrollbars
overflowX:null,overflowY:null,constructor:function constructor(options){options=options||{};this.overflowX=options.overflowX||options.overflow||'auto';this.overflowY=options.overflowY||options.overflow||'auto';},render:function render(){this.el=this.renderEl();this.applyOverflow();},renderEl:function renderEl(){return this.scrollEl=$('<div class="fc-scroller"></div>');},// sets to natural height, unlocks overflow
clear:function clear(){this.setHeight('auto');this.applyOverflow();},destroy:function destroy(){this.el.remove();},// Overflow
// -----------------------------------------------------------------------------------------------------------------
applyOverflow:function applyOverflow(){this.scrollEl.css({'overflow-x':this.overflowX,'overflow-y':this.overflowY});},// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
// Useful for preserving scrollbar widths regardless of future resizes.
// Can pass in scrollbarWidths for optimization.
lockOverflow:function lockOverflow(scrollbarWidths){var overflowX=this.overflowX;var overflowY=this.overflowY;scrollbarWidths=scrollbarWidths||this.getScrollbarWidths();if(overflowX==='auto'){overflowX=scrollbarWidths.top||scrollbarWidths.bottom||// horizontal scrollbars?
// OR scrolling pane with massless scrollbars?
this.scrollEl[0].scrollWidth-1>this.scrollEl[0].clientWidth// subtract 1 because of IE off-by-one issue
?'scroll':'hidden';}if(overflowY==='auto'){overflowY=scrollbarWidths.left||scrollbarWidths.right||// vertical scrollbars?
// OR scrolling pane with massless scrollbars?
this.scrollEl[0].scrollHeight-1>this.scrollEl[0].clientHeight// subtract 1 because of IE off-by-one issue
?'scroll':'hidden';}this.scrollEl.css({'overflow-x':overflowX,'overflow-y':overflowY});},// Getters / Setters
// -----------------------------------------------------------------------------------------------------------------
setHeight:function setHeight(height){this.scrollEl.height(height);},getScrollTop:function getScrollTop(){return this.scrollEl.scrollTop();},setScrollTop:function setScrollTop(top){this.scrollEl.scrollTop(top);},getClientWidth:function getClientWidth(){return this.scrollEl[0].clientWidth;},getClientHeight:function getClientHeight(){return this.scrollEl[0].clientHeight;},getScrollbarWidths:function getScrollbarWidths(){return _getScrollbarWidths(this.scrollEl);}});;;var Calendar=FC.Calendar=Class.extend({dirDefaults:null,// option defaults related to LTR or RTL
langDefaults:null,// option defaults related to current locale
overrides:null,// option overrides given to the fullCalendar constructor
dynamicOverrides:null,// options set with dynamic setter method. higher precedence than view overrides.
options:null,// all defaults combined with overrides
viewSpecCache:null,// cache of view definitions
view:null,// current View object
header:null,loadingLevel:0,// number of simultaneous loading tasks
// a lot of this class' OOP logic is scoped within this constructor function,
// but in the future, write individual methods on the prototype.
constructor:Calendar_constructor,// Subclasses can override this for initialization logic after the constructor has been called
initialize:function initialize(){},// Computes the flattened options hash for the calendar and assigns to `this.options`.
// Assumes this.overrides and this.dynamicOverrides have already been initialized.
populateOptionsHash:function populateOptionsHash(){var lang,langDefaults;var isRTL,dirDefaults;lang=firstDefined(// explicit lang option given?
this.dynamicOverrides.lang,this.overrides.lang);langDefaults=langOptionHash[lang];if(!langDefaults){// explicit lang option not given or invalid?
lang=Calendar.defaults.lang;langDefaults=langOptionHash[lang]||{};}isRTL=firstDefined(// based on options computed so far, is direction RTL?
this.dynamicOverrides.isRTL,this.overrides.isRTL,langDefaults.isRTL,Calendar.defaults.isRTL);dirDefaults=isRTL?Calendar.rtlDefaults:{};this.dirDefaults=dirDefaults;this.langDefaults=langDefaults;this.options=mergeOptions([// merge defaults and overrides. lowest to highest precedence
Calendar.defaults,// global defaults
dirDefaults,langDefaults,this.overrides,this.dynamicOverrides]);populateInstanceComputableOptions(this.options);// fill in gaps with computed options
},// Gets information about how to create a view. Will use a cache.
getViewSpec:function getViewSpec(viewType){var cache=this.viewSpecCache;return cache[viewType]||(cache[viewType]=this.buildViewSpec(viewType));},// Given a duration singular unit, like "week" or "day", finds a matching view spec.
// Preference is given to views that have corresponding buttons.
getUnitViewSpec:function getUnitViewSpec(unit){var viewTypes;var i;var spec;if($.inArray(unit,intervalUnits)!=-1){// put views that have buttons first. there will be duplicates, but oh well
viewTypes=this.header.getViewsWithButtons();$.each(FC.views,function(viewType){// all views
viewTypes.push(viewType);});for(i=0;i<viewTypes.length;i++){spec=this.getViewSpec(viewTypes[i]);if(spec){if(spec.singleUnit==unit){return spec;}}}}},// Builds an object with information on how to create a given view
buildViewSpec:function buildViewSpec(requestedViewType){var viewOverrides=this.overrides.views||{};var specChain=[];// for the view. lowest to highest priority
var defaultsChain=[];// for the view. lowest to highest priority
var overridesChain=[];// for the view. lowest to highest priority
var viewType=requestedViewType;var spec;// for the view
var overrides;// for the view
var duration;var unit;// iterate from the specific view definition to a more general one until we hit an actual View class
while(viewType){spec=fcViews[viewType];overrides=viewOverrides[viewType];viewType=null;// clear. might repopulate for another iteration
if(typeof spec==='function'){// TODO: deprecate
spec={'class':spec};}if(spec){specChain.unshift(spec);defaultsChain.unshift(spec.defaults||{});duration=duration||spec.duration;viewType=viewType||spec.type;}if(overrides){overridesChain.unshift(overrides);// view-specific option hashes have options at zero-level
duration=duration||overrides.duration;viewType=viewType||overrides.type;}}spec=mergeProps(specChain);spec.type=requestedViewType;if(!spec['class']){return false;}if(duration){duration=moment.duration(duration);if(duration.valueOf()){// valid?
spec.duration=duration;unit=computeIntervalUnit(duration);// view is a single-unit duration, like "week" or "day"
// incorporate options for this. lowest priority
if(duration.as(unit)===1){spec.singleUnit=unit;overridesChain.unshift(viewOverrides[unit]||{});}}}spec.defaults=mergeOptions(defaultsChain);spec.overrides=mergeOptions(overridesChain);this.buildViewSpecOptions(spec);this.buildViewSpecButtonText(spec,requestedViewType);return spec;},// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
buildViewSpecOptions:function buildViewSpecOptions(spec){spec.options=mergeOptions([// lowest to highest priority
Calendar.defaults,// global defaults
spec.defaults,// view's defaults (from ViewSubclass.defaults)
this.dirDefaults,this.langDefaults,// locale and dir take precedence over view's defaults!
this.overrides,// calendar's overrides (options given to constructor)
spec.overrides,// view's overrides (view-specific options)
this.dynamicOverrides// dynamically set via setter. highest precedence
]);populateInstanceComputableOptions(spec.options);},// Computes and assigns a view spec's buttonText-related options
buildViewSpecButtonText:function buildViewSpecButtonText(spec,requestedViewType){// given an options object with a possible `buttonText` hash, lookup the buttonText for the
// requested view, falling back to a generic unit entry like "week" or "day"
function queryButtonText(options){var buttonText=options.buttonText||{};return buttonText[requestedViewType]||(spec.singleUnit?buttonText[spec.singleUnit]:null);}// highest to lowest priority
spec.buttonTextOverride=queryButtonText(this.dynamicOverrides)||queryButtonText(this.overrides)||// constructor-specified buttonText lookup hash takes precedence
spec.overrides.buttonText;// `buttonText` for view-specific options is a string
// highest to lowest priority. mirrors buildViewSpecOptions
spec.buttonTextDefault=queryButtonText(this.langDefaults)||queryButtonText(this.dirDefaults)||spec.defaults.buttonText||// a single string. from ViewSubclass.defaults
queryButtonText(Calendar.defaults)||(spec.duration?this.humanizeDuration(spec.duration):null)||// like "3 days"
requestedViewType;// fall back to given view name
},// Given a view name for a custom view or a standard view, creates a ready-to-go View object
instantiateView:function instantiateView(viewType){var spec=this.getViewSpec(viewType);return new spec['class'](this,viewType,spec.options,spec.duration);},// Returns a boolean about whether the view is okay to instantiate at some point
isValidViewType:function isValidViewType(viewType){return Boolean(this.getViewSpec(viewType));},// Should be called when any type of async data fetching begins
pushLoading:function pushLoading(){if(!this.loadingLevel++){this.trigger('loading',null,true,this.view);}},// Should be called when any type of async data fetching completes
popLoading:function popLoading(){if(! --this.loadingLevel){this.trigger('loading',null,false,this.view);}},// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
buildSelectSpan:function buildSelectSpan(zonedStartInput,zonedEndInput){var start=this.moment(zonedStartInput).stripZone();var end;if(zonedEndInput){end=this.moment(zonedEndInput).stripZone();}else if(start.hasTime()){end=start.clone().add(this.defaultTimedEventDuration);}else{end=start.clone().add(this.defaultAllDayEventDuration);}return{start:start,end:end};}});Calendar.mixin(EmitterMixin);function Calendar_constructor(element,overrides){var t=this;// Exports
// -----------------------------------------------------------------------------------
t.render=render;t.destroy=destroy;t.refetchEvents=refetchEvents;t.refetchEventSources=refetchEventSources;t.reportEvents=reportEvents;t.reportEventChange=reportEventChange;t.rerenderEvents=renderEvents;// `renderEvents` serves as a rerender. an API method
t.changeView=renderView;// `renderView` will switch to another view
t.select=select;t.unselect=unselect;t.prev=prev;t.next=next;t.prevYear=prevYear;t.nextYear=nextYear;t.today=today;t.gotoDate=gotoDate;t.incrementDate=incrementDate;t.zoomTo=zoomTo;t.getDate=getDate;t.getCalendar=getCalendar;t.getView=getView;t.option=option;// getter/setter method
t.trigger=trigger;// Options
// -----------------------------------------------------------------------------------
t.dynamicOverrides={};t.viewSpecCache={};t.optionHandlers={};// for Calendar.options.js
// convert legacy options into non-legacy ones.
// in the future, when this is removed, don't use `overrides` reference. make a copy.
t.overrides=massageOverrides(overrides||{});t.populateOptionsHash();// sets this.options
// Language-data Internals
// -----------------------------------------------------------------------------------
// Apply overrides to the current language's data
var localeData;// Called immediately, and when any of the options change.
// Happens before any internal objects rebuild or rerender, because this is very core.
t.bindOptions(['lang','monthNames','monthNamesShort','dayNames','dayNamesShort','firstDay','weekNumberCalculation'],function(lang,monthNames,monthNamesShort,dayNames,dayNamesShort,firstDay,weekNumberCalculation){localeData=createObject(// make a cheap copy
getMomentLocaleData(lang)// will fall back to en
);if(monthNames){localeData._months=monthNames;}if(monthNamesShort){localeData._monthsShort=monthNamesShort;}if(dayNames){localeData._weekdays=dayNames;}if(dayNamesShort){localeData._weekdaysShort=dayNamesShort;}if(firstDay!=null){var _week=createObject(localeData._week);// _week: { dow: # }
_week.dow=firstDay;localeData._week=_week;}if(weekNumberCalculation==='iso'){weekNumberCalculation='ISO';// normalize
}if(// whitelist certain kinds of input
weekNumberCalculation==='ISO'||weekNumberCalculation==='local'||typeof weekNumberCalculation==='function'){localeData._fullCalendar_weekCalc=weekNumberCalculation;// moment-ext will know what to do with it
}// If the internal current date object already exists, move to new locale.
// We do NOT need to do this technique for event dates, because this happens when converting to "segments".
if(date){localizeMoment(date);// sets to localeData
}});// Calendar-specific Date Utilities
// -----------------------------------------------------------------------------------
t.defaultAllDayEventDuration=moment.duration(t.options.defaultAllDayEventDuration);t.defaultTimedEventDuration=moment.duration(t.options.defaultTimedEventDuration);// Builds a moment using the settings of the current calendar: timezone and language.
// Accepts anything the vanilla moment() constructor accepts.
t.moment=function(){var mom;if(t.options.timezone==='local'){mom=FC.moment.apply(null,arguments);// Force the moment to be local, because FC.moment doesn't guarantee it.
if(mom.hasTime()){// don't give ambiguously-timed moments a local zone
mom.local();}}else if(t.options.timezone==='UTC'){mom=FC.moment.utc.apply(null,arguments);// process as UTC
}else{mom=FC.moment.parseZone.apply(null,arguments);// let the input decide the zone
}localizeMoment(mom);return mom;};// Updates the given moment's locale settings to the current calendar locale settings.
function localizeMoment(mom){if('_locale'in mom){// moment 2.8 and above
mom._locale=localeData;}else{// pre-moment-2.8
mom._lang=localeData;}}// Returns a boolean about whether or not the calendar knows how to calculate
// the timezone offset of arbitrary dates in the current timezone.
t.getIsAmbigTimezone=function(){return t.options.timezone!=='local'&&t.options.timezone!=='UTC';};// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
t.applyTimezone=function(date){if(!date.hasTime()){return date.clone();}var zonedDate=t.moment(date.toArray());var timeAdjust=date.time()-zonedDate.time();var adjustedZonedDate;// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
if(timeAdjust){// is the time result different than expected?
adjustedZonedDate=zonedDate.clone().add(timeAdjust);// add milliseconds
if(date.time()-adjustedZonedDate.time()===0){// does it match perfectly now?
zonedDate=adjustedZonedDate;}}return zonedDate;};// Returns a moment for the current date, as defined by the client's computer or from the `now` option.
// Will return an moment with an ambiguous timezone.
t.getNow=function(){var now=t.options.now;if(typeof now==='function'){now=now();}return t.moment(now).stripZone();};// Get an event's normalized end date. If not present, calculate it from the defaults.
t.getEventEnd=function(event){if(event.end){return event.end.clone();}else{return t.getDefaultEventEnd(event.allDay,event.start);}};// Given an event's allDay status and start date, return what its fallback end date should be.
// TODO: rename to computeDefaultEventEnd
t.getDefaultEventEnd=function(allDay,zonedStart){var end=zonedStart.clone();if(allDay){end.stripTime().add(t.defaultAllDayEventDuration);}else{end.add(t.defaultTimedEventDuration);}if(t.getIsAmbigTimezone()){end.stripZone();// we don't know what the tzo should be
}return end;};// Produces a human-readable string for the given duration.
// Side-effect: changes the locale of the given duration.
t.humanizeDuration=function(duration){return(duration.locale||duration.lang).call(duration,t.options.lang)// works moment-pre-2.8
.humanize();};// Imports
// -----------------------------------------------------------------------------------
EventManager.call(t);var isFetchNeeded=t.isFetchNeeded;var fetchEvents=t.fetchEvents;var fetchEventSources=t.fetchEventSources;// Locals
// -----------------------------------------------------------------------------------
var _element=element[0];var header;var content;var tm;// for making theme classes
var currentView;// NOTE: keep this in sync with this.view
var viewsByType={};// holds all instantiated view instances, current or not
var suggestedViewHeight;var windowResizeProxy;// wraps the windowResize function
var ignoreWindowResize=0;var events=[];var date;// unzoned
// Main Rendering
// -----------------------------------------------------------------------------------
// compute the initial ambig-timezone date
if(t.options.defaultDate!=null){date=t.moment(t.options.defaultDate).stripZone();}else{date=t.getNow();// getNow already returns unzoned
}function render(){if(!content){initialRender();}else if(elementVisible()){// mainly for the public API
calcSize();renderView();}}function initialRender(){element.addClass('fc');// called immediately, and upon option change
t.bindOption('theme',function(theme){tm=theme?'ui':'fc';// affects a larger scope
element.toggleClass('ui-widget',theme);element.toggleClass('fc-unthemed',!theme);});// called immediately, and upon option change.
// HACK: lang often affects isRTL, so we explicitly listen to that too.
t.bindOptions(['isRTL','lang'],function(isRTL){element.toggleClass('fc-ltr',!isRTL);element.toggleClass('fc-rtl',isRTL);});content=$("<div class='fc-view-container'/>").prependTo(element);header=t.header=new Header(t);renderHeader();renderView(t.options.defaultView);if(t.options.handleWindowResize){windowResizeProxy=debounce(windowResize,t.options.windowResizeDelay);// prevents rapid calls
$(window).resize(windowResizeProxy);}}// can be called repeatedly and Header will rerender
function renderHeader(){header.render();if(header.el){element.prepend(header.el);}}function destroy(){if(currentView){currentView.removeElement();// NOTE: don't null-out currentView/t.view in case API methods are called after destroy.
// It is still the "current" view, just not rendered.
}header.removeElement();content.remove();element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');if(windowResizeProxy){$(window).unbind('resize',windowResizeProxy);}}function elementVisible(){return element.is(':visible');}// View Rendering
// -----------------------------------------------------------------------------------
// Renders a view because of a date change, view-type change, or for the first time.
// If not given a viewType, keep the current view but render different dates.
// Accepts an optional scroll state to restore to.
function renderView(viewType,explicitScrollState){ignoreWindowResize++;// if viewType is changing, remove the old view's rendering
if(currentView&&viewType&&currentView.type!==viewType){freezeContentHeight();// prevent a scroll jump when view element is removed
clearView();}// if viewType changed, or the view was never created, create a fresh view
if(!currentView&&viewType){currentView=t.view=viewsByType[viewType]||(viewsByType[viewType]=t.instantiateView(viewType));currentView.setElement($("<div class='fc-view fc-"+viewType+"-view' />").appendTo(content));header.activateButton(viewType);}if(currentView){// in case the view should render a period of time that is completely hidden
date=currentView.massageCurrentDate(date);// render or rerender the view
if(!currentView.displaying||!date.isWithin(currentView.intervalStart,currentView.intervalEnd)// implicit date window change
){if(elementVisible()){currentView.display(date,explicitScrollState);// will call freezeContentHeight
unfreezeContentHeight();// immediately unfreeze regardless of whether display is async
// need to do this after View::render, so dates are calculated
updateHeaderTitle();updateTodayButton();getAndRenderEvents();}}}unfreezeContentHeight();// undo any lone freezeContentHeight calls
ignoreWindowResize--;}// Unrenders the current view and reflects this change in the Header.
// Unregsiters the `currentView`, but does not remove from viewByType hash.
function clearView(){header.deactivateButton(currentView.type);currentView.removeElement();currentView=t.view=null;}// Destroys the view, including the view object. Then, re-instantiates it and renders it.
// Maintains the same scroll state.
// TODO: maintain any other user-manipulated state.
function reinitView(){ignoreWindowResize++;freezeContentHeight();var viewType=currentView.type;var scrollState=currentView.queryScroll();clearView();renderView(viewType,scrollState);unfreezeContentHeight();ignoreWindowResize--;}// Resizing
// -----------------------------------------------------------------------------------
t.getSuggestedViewHeight=function(){if(suggestedViewHeight===undefined){calcSize();}return suggestedViewHeight;};t.isHeightAuto=function(){return t.options.contentHeight==='auto'||t.options.height==='auto';};function updateSize(shouldRecalc){if(elementVisible()){if(shouldRecalc){_calcSize();}ignoreWindowResize++;currentView.updateSize(true);// isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
ignoreWindowResize--;return true;// signal success
}}function calcSize(){if(elementVisible()){_calcSize();}}function _calcSize(){// assumes elementVisible
if(typeof t.options.contentHeight==='number'){// exists and not 'auto'
suggestedViewHeight=t.options.contentHeight;}else if(typeof t.options.height==='number'){// exists and not 'auto'
suggestedViewHeight=t.options.height-(header.el?header.el.outerHeight(true):0);}else{suggestedViewHeight=Math.round(content.width()/Math.max(t.options.aspectRatio,.5));}}function windowResize(ev){if(!ignoreWindowResize&&ev.target===window&&// so we don't process jqui "resize" events that have bubbled up
currentView.start// view has already been rendered
){if(updateSize(true)){currentView.trigger('windowResize',_element);}}}/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/// TODO: going forward, most of this stuff should be directly handled by the view
function refetchEvents(){// can be called as an API method
fetchAndRenderEvents();}// TODO: move this into EventManager?
function refetchEventSources(matchInputs){fetchEventSources(t.getEventSourcesByMatchArray(matchInputs));}function renderEvents(){// destroys old events if previously rendered
if(elementVisible()){freezeContentHeight();currentView.displayEvents(events);unfreezeContentHeight();}}function getAndRenderEvents(){if(!t.options.lazyFetching||isFetchNeeded(currentView.start,currentView.end)){fetchAndRenderEvents();}else{renderEvents();}}function fetchAndRenderEvents(){fetchEvents(currentView.start,currentView.end);// ... will call reportEvents
// ... which will call renderEvents
}// called when event data arrives
function reportEvents(_events){events=_events;renderEvents();}// called when a single event's data has been changed
function reportEventChange(){renderEvents();}/* Header Updating
	-----------------------------------------------------------------------------*/function updateHeaderTitle(){header.updateTitle(currentView.title);}function updateTodayButton(){var now=t.getNow();if(now.isWithin(currentView.intervalStart,currentView.intervalEnd)){header.disableButton('today');}else{header.enableButton('today');}}/* Selection
	-----------------------------------------------------------------------------*/// this public method receives start/end dates in any format, with any timezone
function select(zonedStartInput,zonedEndInput){currentView.select(t.buildSelectSpan.apply(t,arguments));}function unselect(){// safe to be called before renderView
if(currentView){currentView.unselect();}}/* Date
	-----------------------------------------------------------------------------*/function prev(){date=currentView.computePrevDate(date);renderView();}function next(){date=currentView.computeNextDate(date);renderView();}function prevYear(){date.add(-1,'years');renderView();}function nextYear(){date.add(1,'years');renderView();}function today(){date=t.getNow();renderView();}function gotoDate(zonedDateInput){date=t.moment(zonedDateInput).stripZone();renderView();}function incrementDate(delta){date.add(moment.duration(delta));renderView();}// Forces navigation to a view for the given date.
// `viewType` can be a specific view name or a generic one like "week" or "day".
function zoomTo(newDate,viewType){var spec;viewType=viewType||'day';// day is default zoom
spec=t.getViewSpec(viewType)||t.getUnitViewSpec(viewType);date=newDate.clone();renderView(spec?spec.type:null);}// for external API
function getDate(){return t.applyTimezone(date);// infuse the calendar's timezone
}/* Height "Freezing"
	-----------------------------------------------------------------------------*/// TODO: move this into the view
t.freezeContentHeight=freezeContentHeight;t.unfreezeContentHeight=unfreezeContentHeight;function freezeContentHeight(){content.css({width:'100%',height:content.height(),overflow:'hidden'});}function unfreezeContentHeight(){content.css({width:'',height:'',overflow:''});}/* Misc
	-----------------------------------------------------------------------------*/function getCalendar(){return t;}function getView(){return currentView;}function option(name,value){var newOptionHash;if(typeof name==='string'){if(value===undefined){// getter
return t.options[name];}else{// setter for individual option
newOptionHash={};newOptionHash[name]=value;setOptions(newOptionHash);}}else if((typeof name==='undefined'?'undefined':(0,_typeof3.default)(name))==='object'){// compound setter with object input
setOptions(name);}}function setOptions(newOptionHash){var optionCnt=0;var optionName;for(optionName in newOptionHash){t.dynamicOverrides[optionName]=newOptionHash[optionName];}t.viewSpecCache={};// the dynamic override invalidates the options in this cache, so just clear it
t.populateOptionsHash();// this.options needs to be recomputed after the dynamic override
// trigger handlers after this.options has been updated
for(optionName in newOptionHash){t.triggerOptionHandlers(optionName);// recall bindOption/bindOptions
optionCnt++;}// special-case handling of single option change.
// if only one option change, `optionName` will be its name.
if(optionCnt===1){if(optionName==='height'||optionName==='contentHeight'||optionName==='aspectRatio'){updateSize(true);// true = allow recalculation of height
return;}else if(optionName==='defaultDate'){return;// can't change date this way. use gotoDate instead
}else if(optionName==='businessHours'){if(currentView){currentView.unrenderBusinessHours();currentView.renderBusinessHours();}return;}else if(optionName==='timezone'){t.rezoneArrayEventSources();refetchEvents();return;}}// catch-all. rerender the header and rebuild/rerender the current view
renderHeader();viewsByType={};// even non-current views will be affected by this option change. do before rerender
reinitView();}function trigger(name,thisObj){// overrides the Emitter's trigger method :(
var args=Array.prototype.slice.call(arguments,2);thisObj=thisObj||_element;this.triggerWith(name,thisObj,args);// Emitter's method
if(t.options[name]){return t.options[name].apply(thisObj,args);}}t.initialize();};;/*
Options binding/triggering system.
*/Calendar.mixin({// A map of option names to arrays of handler objects. Initialized to {} in Calendar.
// Format for a handler object:
// {
//   func // callback function to be called upon change
//   names // option names whose values should be given to func
// }
optionHandlers:null,// Calls handlerFunc immediately, and when the given option has changed.
// handlerFunc will be given the option value.
bindOption:function bindOption(optionName,handlerFunc){this.bindOptions([optionName],handlerFunc);},// Calls handlerFunc immediately, and when any of the given options change.
// handlerFunc will be given each option value as ordered function arguments.
bindOptions:function bindOptions(optionNames,handlerFunc){var handlerObj={func:handlerFunc,names:optionNames};var i;for(i=0;i<optionNames.length;i++){this.registerOptionHandlerObj(optionNames[i],handlerObj);}this.triggerOptionHandlerObj(handlerObj);},// Puts the given handler object into the internal hash
registerOptionHandlerObj:function registerOptionHandlerObj(optionName,handlerObj){(this.optionHandlers[optionName]||(this.optionHandlers[optionName]=[])).push(handlerObj);},// Reports that the given option has changed, and calls all appropriate handlers.
triggerOptionHandlers:function triggerOptionHandlers(optionName){var handlerObjs=this.optionHandlers[optionName]||[];var i;for(i=0;i<handlerObjs.length;i++){this.triggerOptionHandlerObj(handlerObjs[i]);}},// Calls the callback for a specific handler object, passing in the appropriate arguments.
triggerOptionHandlerObj:function triggerOptionHandlerObj(handlerObj){var optionNames=handlerObj.names;var optionValues=[];var i;for(i=0;i<optionNames.length;i++){optionValues.push(this.options[optionNames[i]]);}handlerObj.func.apply(this,optionValues);// maintain the Calendar's `this` context
}});;;Calendar.defaults={titleRangeSeparator:'  ',// en dash
monthYearFormat:'MMMM YYYY',// required for en. other languages rely on datepicker computable option
defaultTimedEventDuration:'02:00:00',defaultAllDayEventDuration:{days:1},forceEventDuration:false,nextDayThreshold:'09:00:00',// 9am
// display
defaultView:'month',aspectRatio:1.35,header:{left:'title',center:'',right:'today prev,next'},weekends:true,weekNumbers:false,weekNumberTitle:'W',weekNumberCalculation:'local',//editable: false,
//nowIndicator: false,
scrollTime:'06:00:00',// event ajax
lazyFetching:true,startParam:'start',endParam:'end',timezoneParam:'timezone',timezone:false,//allDayDefault: undefined,
// locale
isRTL:false,buttonText:{prev:"prev",next:"next",prevYear:"prev year",nextYear:"next year",year:'year',// TODO: locale files need to specify this
today:'today',month:'month',week:'week',day:'day'},buttonIcons:{prev:'left-single-arrow',next:'right-single-arrow',prevYear:'left-double-arrow',nextYear:'right-double-arrow'},// jquery-ui theming
theme:false,themeButtonIcons:{prev:'circle-triangle-w',next:'circle-triangle-e',prevYear:'seek-prev',nextYear:'seek-next'},//eventResizableFromStart: false,
dragOpacity:.75,dragRevertDuration:500,dragScroll:true,//selectable: false,
unselectAuto:true,dropAccept:'*',eventOrder:'title',eventLimit:false,eventLimitText:'more',eventLimitClick:'popover',dayPopoverFormat:'LL',handleWindowResize:true,windowResizeDelay:200,// milliseconds before an updateSize happens
longPressDelay:1000};Calendar.englishDefaults={// used by lang.js
dayPopoverFormat:'dddd, MMMM D'};Calendar.rtlDefaults={// right-to-left defaults
header:{// TODO: smarter solution (first/center/last ?)
left:'next,prev today',center:'',right:'title'},buttonIcons:{prev:'right-single-arrow',next:'left-single-arrow',prevYear:'right-double-arrow',nextYear:'left-double-arrow'},themeButtonIcons:{prev:'circle-triangle-e',next:'circle-triangle-w',nextYear:'seek-prev',prevYear:'seek-next'}};;;var langOptionHash=FC.langs={};// initialize and expose
// TODO: document the structure and ordering of a FullCalendar lang file
// TODO: rename everything "lang" to "locale", like what the moment project did
// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default language for datepicker.
FC.datepickerLang=function(langCode,dpLangCode,dpOptions){// get the FullCalendar internal option hash for this language. create if necessary
var fcOptions=langOptionHash[langCode]||(langOptionHash[langCode]={});// transfer some simple options from datepicker to fc
fcOptions.isRTL=dpOptions.isRTL;fcOptions.weekNumberTitle=dpOptions.weekHeader;// compute some more complex options from datepicker
$.each(dpComputableOptions,function(name,func){fcOptions[name]=func(dpOptions);});// is jQuery UI Datepicker is on the page?
if($.datepicker){// Register the language data.
// FullCalendar and MomentJS use language codes like "pt-br" but Datepicker
// does it like "pt-BR" or if it doesn't have the language, maybe just "pt".
// Make an alias so the language can be referenced either way.
$.datepicker.regional[dpLangCode]=$.datepicker.regional[langCode]=// alias
dpOptions;// Alias 'en' to the default language data. Do this every time.
$.datepicker.regional.en=$.datepicker.regional[''];// Set as Datepicker's global defaults.
$.datepicker.setDefaults(dpOptions);}};// Sets FullCalendar-specific translations. Will set the language as the global default.
FC.lang=function(langCode,newFcOptions){var fcOptions;var momOptions;// get the FullCalendar internal option hash for this language. create if necessary
fcOptions=langOptionHash[langCode]||(langOptionHash[langCode]={});// provided new options for this language? merge them in
if(newFcOptions){fcOptions=langOptionHash[langCode]=mergeOptions([fcOptions,newFcOptions]);}// compute language options that weren't defined.
// always do this. newFcOptions can be undefined when initializing from i18n file,
// so no way to tell if this is an initialization or a default-setting.
momOptions=getMomentLocaleData(langCode);// will fall back to en
$.each(momComputableOptions,function(name,func){if(fcOptions[name]==null){fcOptions[name]=func(momOptions,fcOptions);}});// set it as the default language for FullCalendar
Calendar.defaults.lang=langCode;};// NOTE: can't guarantee any of these computations will run because not every language has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions={buttonText:function buttonText(dpOptions){return{// the translations sometimes wrongly contain HTML entities
prev:stripHtmlEntities(dpOptions.prevText),next:stripHtmlEntities(dpOptions.nextText),today:stripHtmlEntities(dpOptions.currentText)};},// Produces format strings like "MMMM YYYY" -> "September 2014"
monthYearFormat:function monthYearFormat(dpOptions){return dpOptions.showMonthAfterYear?'YYYY['+dpOptions.yearSuffix+'] MMMM':'MMMM YYYY['+dpOptions.yearSuffix+']';}};var momComputableOptions={// Produces format strings like "ddd M/D" -> "Fri 9/15"
dayOfMonthFormat:function dayOfMonthFormat(momOptions,fcOptions){var format=momOptions.longDateFormat('l');// for the format like "M/D/YYYY"
// strip the year off the edge, as well as other misc non-whitespace chars
format=format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g,'');if(fcOptions.isRTL){format+=' ddd';// for RTL, add day-of-week to end
}else{format='ddd '+format;// for LTR, add day-of-week to beginning
}return format;},// Produces format strings like "h:mma" -> "6:00pm"
mediumTimeFormat:function mediumTimeFormat(momOptions){// can't be called `timeFormat` because collides with option
return momOptions.longDateFormat('LT').replace(/\s*a$/i,'a');// convert AM/PM/am/pm to lowercase. remove any spaces beforehand
},// Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
smallTimeFormat:function smallTimeFormat(momOptions){return momOptions.longDateFormat('LT').replace(':mm','(:mm)').replace(/(\Wmm)$/,'($1)')// like above, but for foreign langs
.replace(/\s*a$/i,'a');// convert AM/PM/am/pm to lowercase. remove any spaces beforehand
},// Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
extraSmallTimeFormat:function extraSmallTimeFormat(momOptions){return momOptions.longDateFormat('LT').replace(':mm','(:mm)').replace(/(\Wmm)$/,'($1)')// like above, but for foreign langs
.replace(/\s*a$/i,'t');// convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
},// Produces format strings like "ha" / "H" -> "6pm" / "18"
hourFormat:function hourFormat(momOptions){return momOptions.longDateFormat('LT').replace(':mm','').replace(/(\Wmm)$/,'')// like above, but for foreign langs
.replace(/\s*a$/i,'a');// convert AM/PM/am/pm to lowercase. remove any spaces beforehand
},// Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
noMeridiemTimeFormat:function noMeridiemTimeFormat(momOptions){return momOptions.longDateFormat('LT').replace(/\s*a$/i,'');// remove trailing AM/PM
}};// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to lang?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions={// Produces format strings for results like "Mo 16"
smallDayDateFormat:function smallDayDateFormat(options){return options.isRTL?'D dd':'dd D';},// Produces format strings for results like "Wk 5"
weekFormat:function weekFormat(options){return options.isRTL?'w[ '+options.weekNumberTitle+']':'['+options.weekNumberTitle+' ]w';},// Produces format strings for results like "Wk5"
smallWeekFormat:function smallWeekFormat(options){return options.isRTL?'w['+options.weekNumberTitle+']':'['+options.weekNumberTitle+']w';}};function populateInstanceComputableOptions(options){$.each(instanceComputableOptions,function(name,func){if(options[name]==null){options[name]=func(options);}});}// Returns moment's internal locale data. If doesn't exist, returns English.
// Works with moment-pre-2.8
function getMomentLocaleData(langCode){var func=moment.localeData||moment.langData;return func.call(moment,langCode)||func.call(moment,'en');// the newer localData could return null, so fall back to en
}// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
FC.lang('en',Calendar.englishDefaults);;;/* Top toolbar area with buttons and title
----------------------------------------------------------------------------------------------------------------------*/// TODO: rename all header-related things to "toolbar"
function Header(calendar){var t=this;// exports
t.render=render;t.removeElement=removeElement;t.updateTitle=updateTitle;t.activateButton=activateButton;t.deactivateButton=deactivateButton;t.disableButton=disableButton;t.enableButton=enableButton;t.getViewsWithButtons=getViewsWithButtons;t.el=null;// mirrors local `el`
// locals
var el;var viewsWithButtons=[];var tm;// can be called repeatedly and will rerender
function render(){var options=calendar.options;var sections=options.header;tm=options.theme?'ui':'fc';if(sections){if(!el){el=this.el=$("<div class='fc-toolbar'/>");}else{el.empty();}el.append(renderSection('left')).append(renderSection('right')).append(renderSection('center')).append('<div class="fc-clear"/>');}else{removeElement();}}function removeElement(){if(el){el.remove();el=t.el=null;}}function renderSection(position){var sectionEl=$('<div class="fc-'+position+'"/>');var options=calendar.options;var buttonStr=options.header[position];if(buttonStr){$.each(buttonStr.split(' '),function(i){var groupChildren=$();var isOnlyButtons=true;var groupEl;$.each(this.split(','),function(j,buttonName){var customButtonProps;var viewSpec;var buttonClick;var overrideText;// text explicitly set by calendar's constructor options. overcomes icons
var defaultText;var themeIcon;var normalIcon;var innerHtml;var classes;var button;// the element
if(buttonName=='title'){groupChildren=groupChildren.add($('<h2>&nbsp;</h2>'));// we always want it to take up height
isOnlyButtons=false;}else{if(customButtonProps=(options.customButtons||{})[buttonName]){buttonClick=function buttonClick(ev){if(customButtonProps.click){customButtonProps.click.call(button[0],ev);}};overrideText='';// icons will override text
defaultText=customButtonProps.text;}else if(viewSpec=calendar.getViewSpec(buttonName)){buttonClick=function buttonClick(){calendar.changeView(buttonName);};viewsWithButtons.push(buttonName);overrideText=viewSpec.buttonTextOverride;defaultText=viewSpec.buttonTextDefault;}else if(calendar[buttonName]){// a calendar method
buttonClick=function buttonClick(){calendar[buttonName]();};overrideText=(calendar.overrides.buttonText||{})[buttonName];defaultText=options.buttonText[buttonName];// everything else is considered default
}if(buttonClick){themeIcon=customButtonProps?customButtonProps.themeIcon:options.themeButtonIcons[buttonName];normalIcon=customButtonProps?customButtonProps.icon:options.buttonIcons[buttonName];if(overrideText){innerHtml=htmlEscape(overrideText);}else if(themeIcon&&options.theme){innerHtml="<span class='ui-icon ui-icon-"+themeIcon+"'></span>";}else if(normalIcon&&!options.theme){innerHtml="<span class='fc-icon fc-icon-"+normalIcon+"'></span>";}else{innerHtml=htmlEscape(defaultText);}classes=['fc-'+buttonName+'-button',tm+'-button',tm+'-state-default'];button=$(// type="button" so that it doesn't submit a form
'<button type="button" class="'+classes.join(' ')+'">'+innerHtml+'</button>').click(function(ev){// don't process clicks for disabled buttons
if(!button.hasClass(tm+'-state-disabled')){buttonClick(ev);// after the click action, if the button becomes the "active" tab, or disabled,
// it should never have a hover class, so remove it now.
if(button.hasClass(tm+'-state-active')||button.hasClass(tm+'-state-disabled')){button.removeClass(tm+'-state-hover');}}}).mousedown(function(){// the *down* effect (mouse pressed in).
// only on buttons that are not the "active" tab, or disabled
button.not('.'+tm+'-state-active').not('.'+tm+'-state-disabled').addClass(tm+'-state-down');}).mouseup(function(){// undo the *down* effect
button.removeClass(tm+'-state-down');}).hover(function(){// the *hover* effect.
// only on buttons that are not the "active" tab, or disabled
button.not('.'+tm+'-state-active').not('.'+tm+'-state-disabled').addClass(tm+'-state-hover');},function(){// undo the *hover* effect
button.removeClass(tm+'-state-hover').removeClass(tm+'-state-down');// if mouseleave happens before mouseup
});groupChildren=groupChildren.add(button);}}});if(isOnlyButtons){groupChildren.first().addClass(tm+'-corner-left').end().last().addClass(tm+'-corner-right').end();}if(groupChildren.length>1){groupEl=$('<div/>');if(isOnlyButtons){groupEl.addClass('fc-button-group');}groupEl.append(groupChildren);sectionEl.append(groupEl);}else{sectionEl.append(groupChildren);// 1 or 0 children
}});}return sectionEl;}function updateTitle(text){if(el){el.find('h2').text(text);}}function activateButton(buttonName){if(el){el.find('.fc-'+buttonName+'-button').addClass(tm+'-state-active');}}function deactivateButton(buttonName){if(el){el.find('.fc-'+buttonName+'-button').removeClass(tm+'-state-active');}}function disableButton(buttonName){if(el){el.find('.fc-'+buttonName+'-button').prop('disabled',true).addClass(tm+'-state-disabled');}}function enableButton(buttonName){if(el){el.find('.fc-'+buttonName+'-button').prop('disabled',false).removeClass(tm+'-state-disabled');}}function getViewsWithButtons(){return viewsWithButtons;}};;FC.sourceNormalizers=[];FC.sourceFetchers=[];var ajaxDefaults={dataType:'json',cache:false};var eventGUID=1;function EventManager(){// assumed to be a calendar
var t=this;// exports
t.isFetchNeeded=isFetchNeeded;t.fetchEvents=fetchEvents;t.fetchEventSources=fetchEventSources;t.getEventSources=getEventSources;t.getEventSourceById=getEventSourceById;t.getEventSourcesByMatchArray=getEventSourcesByMatchArray;t.getEventSourcesByMatch=getEventSourcesByMatch;t.addEventSource=addEventSource;t.removeEventSource=removeEventSource;t.removeEventSources=removeEventSources;t.updateEvent=updateEvent;t.renderEvent=renderEvent;t.removeEvents=removeEvents;t.clientEvents=clientEvents;t.mutateEvent=mutateEvent;t.normalizeEventDates=normalizeEventDates;t.normalizeEventTimes=normalizeEventTimes;// imports
var reportEvents=t.reportEvents;// locals
var stickySource={events:[]};var sources=[stickySource];var rangeStart,rangeEnd;var pendingSourceCnt=0;// outstanding fetch requests, max one per source
var cache=[];// holds events that have already been expanded
$.each((t.options.events?[t.options.events]:[]).concat(t.options.eventSources||[]),function(i,sourceInput){var source=buildEventSource(sourceInput);if(source){sources.push(source);}});/* Fetching
	-----------------------------------------------------------------------------*/// start and end are assumed to be unzoned
function isFetchNeeded(start,end){return!rangeStart||// nothing has been fetched yet?
start<rangeStart||end>rangeEnd;// is part of the new range outside of the old range?
}function fetchEvents(start,end){rangeStart=start;rangeEnd=end;fetchEventSources(sources,'reset');}// expects an array of event source objects (the originals, not copies)
// `specialFetchType` is an optimization parameter that affects purging of the event cache.
function fetchEventSources(specificSources,specialFetchType){var i,source;if(specialFetchType==='reset'){cache=[];}else if(specialFetchType!=='add'){cache=excludeEventsBySources(cache,specificSources);}for(i=0;i<specificSources.length;i++){source=specificSources[i];// already-pending sources have already been accounted for in pendingSourceCnt
if(source._status!=='pending'){pendingSourceCnt++;}source._fetchId=(source._fetchId||0)+1;source._status='pending';}for(i=0;i<specificSources.length;i++){source=specificSources[i];tryFetchEventSource(source,source._fetchId);}}// fetches an event source and processes its result ONLY if it is still the current fetch.
// caller is responsible for incrementing pendingSourceCnt first.
function tryFetchEventSource(source,fetchId){_fetchEventSource(source,function(eventInputs){var isArraySource=$.isArray(source.events);var i,eventInput;var abstractEvent;if(// is this the source's most recent fetch?
// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt
fetchId===source._fetchId&&// event source no longer valid?
source._status!=='rejected'){source._status='resolved';if(eventInputs){for(i=0;i<eventInputs.length;i++){eventInput=eventInputs[i];if(isArraySource){// array sources have already been convert to Event Objects
abstractEvent=eventInput;}else{abstractEvent=buildEventFromInput(eventInput,source);}if(abstractEvent){// not false (an invalid event)
cache.push.apply(cache,expandEvent(abstractEvent)// add individual expanded events to the cache
);}}}decrementPendingSourceCnt();}});}function rejectEventSource(source){var wasPending=source._status==='pending';source._status='rejected';if(wasPending){decrementPendingSourceCnt();}}function decrementPendingSourceCnt(){pendingSourceCnt--;if(!pendingSourceCnt){reportEvents(cache);}}function _fetchEventSource(source,callback){var i;var fetchers=FC.sourceFetchers;var res;for(i=0;i<fetchers.length;i++){res=fetchers[i].call(t,// this, the Calendar object
source,rangeStart.clone(),rangeEnd.clone(),t.options.timezone,callback);if(res===true){// the fetcher is in charge. made its own async request
return;}else if((typeof res==='undefined'?'undefined':(0,_typeof3.default)(res))=='object'){// the fetcher returned a new source. process it
_fetchEventSource(res,callback);return;}}var events=source.events;if(events){if($.isFunction(events)){t.pushLoading();events.call(t,// this, the Calendar object
rangeStart.clone(),rangeEnd.clone(),t.options.timezone,function(events){callback(events);t.popLoading();});}else if($.isArray(events)){callback(events);}else{callback();}}else{var url=source.url;if(url){var _success=source.success;var _error=source.error;var _complete=source.complete;// retrieve any outbound GET/POST $.ajax data from the options
var customData;if($.isFunction(source.data)){// supplied as a function that returns a key/value object
customData=source.data();}else{// supplied as a straight key/value object
customData=source.data;}// use a copy of the custom data so we can modify the parameters
// and not affect the passed-in object.
var data=$.extend({},customData||{});var startParam=firstDefined(source.startParam,t.options.startParam);var endParam=firstDefined(source.endParam,t.options.endParam);var timezoneParam=firstDefined(source.timezoneParam,t.options.timezoneParam);if(startParam){data[startParam]=rangeStart.format();}if(endParam){data[endParam]=rangeEnd.format();}if(t.options.timezone&&t.options.timezone!='local'){data[timezoneParam]=t.options.timezone;}t.pushLoading();$.ajax($.extend({},ajaxDefaults,source,{data:data,success:function success(events){events=events||[];var res=applyAll(_success,this,arguments);if($.isArray(res)){events=res;}callback(events);},error:function error(){applyAll(_error,this,arguments);callback();},complete:function complete(){applyAll(_complete,this,arguments);t.popLoading();}}));}else{callback();}}}/* Sources
	-----------------------------------------------------------------------------*/function addEventSource(sourceInput){var source=buildEventSource(sourceInput);if(source){sources.push(source);fetchEventSources([source],'add');// will eventually call reportEvents
}}function buildEventSource(sourceInput){// will return undefined if invalid source
var normalizers=FC.sourceNormalizers;var source;var i;if($.isFunction(sourceInput)||$.isArray(sourceInput)){source={events:sourceInput};}else if(typeof sourceInput==='string'){source={url:sourceInput};}else if((typeof sourceInput==='undefined'?'undefined':(0,_typeof3.default)(sourceInput))==='object'){source=$.extend({},sourceInput);// shallow copy
}if(source){// TODO: repeat code, same code for event classNames
if(source.className){if(typeof source.className==='string'){source.className=source.className.split(/\s+/);}// otherwise, assumed to be an array
}else{source.className=[];}// for array sources, we convert to standard Event Objects up front
if($.isArray(source.events)){source.origArray=source.events;// for removeEventSource
source.events=$.map(source.events,function(eventInput){return buildEventFromInput(eventInput,source);});}for(i=0;i<normalizers.length;i++){normalizers[i].call(t,source);}return source;}}function removeEventSource(matchInput){removeSpecificEventSources(getEventSourcesByMatch(matchInput));}// if called with no arguments, removes all.
function removeEventSources(matchInputs){if(matchInputs==null){removeSpecificEventSources(sources,true);// isAll=true
}else{removeSpecificEventSources(getEventSourcesByMatchArray(matchInputs));}}function removeSpecificEventSources(targetSources,isAll){var i;// cancel pending requests
for(i=0;i<targetSources.length;i++){rejectEventSource(targetSources[i]);}if(isAll){// an optimization
sources=[];cache=[];}else{// remove from persisted source list
sources=$.grep(sources,function(source){for(i=0;i<targetSources.length;i++){if(source===targetSources[i]){return false;// exclude
}}return true;// include
});cache=excludeEventsBySources(cache,targetSources);}reportEvents(cache);}function getEventSources(){return sources.slice(1);// returns a shallow copy of sources with stickySource removed
}function getEventSourceById(id){return $.grep(sources,function(source){return source.id&&source.id===id;})[0];}// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)
function getEventSourcesByMatchArray(matchInputs){// coerce into an array
if(!matchInputs){matchInputs=[];}else if(!$.isArray(matchInputs)){matchInputs=[matchInputs];}var matchingSources=[];var i;// resolve raw inputs to real event source objects
for(i=0;i<matchInputs.length;i++){matchingSources.push.apply(// append
matchingSources,getEventSourcesByMatch(matchInputs[i]));}return matchingSources;}// matchInput can either by a real event source object, an ID, or the function/URL for the source.
// returns an array of matching source objects.
function getEventSourcesByMatch(matchInput){var i,source;// given an proper event source object
for(i=0;i<sources.length;i++){source=sources[i];if(source===matchInput){return[source];}}// an ID match
source=getEventSourceById(matchInput);if(source){return[source];}return $.grep(sources,function(source){return isSourcesEquivalent(matchInput,source);});}function isSourcesEquivalent(source1,source2){return source1&&source2&&getSourcePrimitive(source1)==getSourcePrimitive(source2);}function getSourcePrimitive(source){return((typeof source==='undefined'?'undefined':(0,_typeof3.default)(source))==='object'?// a normalized event source?
source.origArray||source.googleCalendarId||source.url||source.events:// get the primitive
null)||source;// the given argument *is* the primitive
}// util
// returns a filtered array without events that are part of any of the given sources
function excludeEventsBySources(specificEvents,specificSources){return $.grep(specificEvents,function(event){for(var i=0;i<specificSources.length;i++){if(event.source===specificSources[i]){return false;// exclude
}}return true;// keep
});}/* Manipulation
	-----------------------------------------------------------------------------*/// Only ever called from the externally-facing API
function updateEvent(event){// massage start/end values, even if date string values
event.start=t.moment(event.start);if(event.end){event.end=t.moment(event.end);}else{event.end=null;}mutateEvent(event,getMiscEventProps(event));// will handle start/end/allDay normalization
reportEvents(cache);// reports event modifications (so we can redraw)
}// Returns a hash of misc event properties that should be copied over to related events.
function getMiscEventProps(event){var props={};$.each(event,function(name,val){if(isMiscEventPropName(name)){if(val!==undefined&&isAtomic(val)){// a defined non-object
props[name]=val;}}});return props;}// non-date-related, non-id-related, non-secret
function isMiscEventPropName(name){return!/^_|^(id|allDay|start|end)$/.test(name);}// returns the expanded events that were created
function renderEvent(eventInput,stick){var abstractEvent=buildEventFromInput(eventInput);var events;var i,event;if(abstractEvent){// not false (a valid input)
events=expandEvent(abstractEvent);for(i=0;i<events.length;i++){event=events[i];if(!event.source){if(stick){stickySource.events.push(event);event.source=stickySource;}cache.push(event);}}reportEvents(cache);return events;}return[];}function removeEvents(filter){var eventID;var i;if(filter==null){// null or undefined. remove all events
filter=function filter(){return true;};// will always match
}else if(!$.isFunction(filter)){// an event ID
eventID=filter+'';filter=function filter(event){return event._id==eventID;};}// Purge event(s) from our local cache
cache=$.grep(cache,filter,true);// inverse=true
// Remove events from array sources.
// This works because they have been converted to official Event Objects up front.
// (and as a result, event._id has been calculated).
for(i=0;i<sources.length;i++){if($.isArray(sources[i].events)){sources[i].events=$.grep(sources[i].events,filter,true);}}reportEvents(cache);}function clientEvents(filter){if($.isFunction(filter)){return $.grep(cache,filter);}else if(filter!=null){// not null, not undefined. an event ID
filter+='';return $.grep(cache,function(e){return e._id==filter;});}return cache;// else, return all
}// Makes sure all array event sources have their internal event objects
// converted over to the Calendar's current timezone.
t.rezoneArrayEventSources=function(){var i;var events;var j;for(i=0;i<sources.length;i++){events=sources[i].events;if($.isArray(events)){for(j=0;j<events.length;j++){rezoneEventDates(events[j]);}}}};function rezoneEventDates(event){event.start=t.moment(event.start);if(event.end){event.end=t.moment(event.end);}backupEventDates(event);}/* Event Normalization
	-----------------------------------------------------------------------------*/// Given a raw object with key/value properties, returns an "abstract" Event object.
// An "abstract" event is an event that, if recurring, will not have been expanded yet.
// Will return `false` when input is invalid.
// `source` is optional
function buildEventFromInput(input,source){var out={};var start,end;var allDay;if(t.options.eventDataTransform){input=t.options.eventDataTransform(input);}if(source&&source.eventDataTransform){input=source.eventDataTransform(input);}// Copy all properties over to the resulting object.
// The special-case properties will be copied over afterwards.
$.extend(out,input);if(source){out.source=source;}out._id=input._id||(input.id===undefined?'_fc'+eventGUID++:input.id+'');if(input.className){if(typeof input.className=='string'){out.className=input.className.split(/\s+/);}else{// assumed to be an array
out.className=input.className;}}else{out.className=[];}start=input.start||input.date;// "date" is an alias for "start"
end=input.end;// parse as a time (Duration) if applicable
if(isTimeString(start)){start=moment.duration(start);}if(isTimeString(end)){end=moment.duration(end);}if(input.dow||moment.isDuration(start)||moment.isDuration(end)){// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
out.start=start?moment.duration(start):null;// will be a Duration or null
out.end=end?moment.duration(end):null;// will be a Duration or null
out._recurring=true;// our internal marker
}else{if(start){start=t.moment(start);if(!start.isValid()){return false;}}if(end){end=t.moment(end);if(!end.isValid()){end=null;// let defaults take over
}}allDay=input.allDay;if(allDay===undefined){// still undefined? fallback to default
allDay=firstDefined(source?source.allDayDefault:undefined,t.options.allDayDefault);// still undefined? normalizeEventDates will calculate it
}assignDatesToEvent(start,end,allDay,out);}t.normalizeEvent(out);// hook for external use. a prototype method
return out;}// Normalizes and assigns the given dates to the given partially-formed event object.
// NOTE: mutates the given start/end moments. does not make a copy.
function assignDatesToEvent(start,end,allDay,event){event.start=start;event.end=end;event.allDay=allDay;normalizeEventDates(event);backupEventDates(event);}// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
// NOTE: Will modify the given object.
function normalizeEventDates(eventProps){normalizeEventTimes(eventProps);if(eventProps.end&&!eventProps.end.isAfter(eventProps.start)){eventProps.end=null;}if(!eventProps.end){if(t.options.forceEventDuration){eventProps.end=t.getDefaultEventEnd(eventProps.allDay,eventProps.start);}else{eventProps.end=null;}}}// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
function normalizeEventTimes(eventProps){if(eventProps.allDay==null){eventProps.allDay=!(eventProps.start.hasTime()||eventProps.end&&eventProps.end.hasTime());}if(eventProps.allDay){eventProps.start.stripTime();if(eventProps.end){// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
eventProps.end.stripTime();}}else{if(!eventProps.start.hasTime()){eventProps.start=t.applyTimezone(eventProps.start.time(0));// will assign a 00:00 time
}if(eventProps.end&&!eventProps.end.hasTime()){eventProps.end=t.applyTimezone(eventProps.end.time(0));// will assign a 00:00 time
}}}// If the given event is a recurring event, break it down into an array of individual instances.
// If not a recurring event, return an array with the single original event.
// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
function expandEvent(abstractEvent,_rangeStart,_rangeEnd){var events=[];var dowHash;var dow;var i;var date;var startTime,endTime;var start,end;var event;_rangeStart=_rangeStart||rangeStart;_rangeEnd=_rangeEnd||rangeEnd;if(abstractEvent){if(abstractEvent._recurring){// make a boolean hash as to whether the event occurs on each day-of-week
if(dow=abstractEvent.dow){dowHash={};for(i=0;i<dow.length;i++){dowHash[dow[i]]=true;}}// iterate through every day in the current range
date=_rangeStart.clone().stripTime();// holds the date of the current day
while(date.isBefore(_rangeEnd)){if(!dowHash||dowHash[date.day()]){// if everyday, or this particular day-of-week
startTime=abstractEvent.start;// the stored start and end properties are times (Durations)
endTime=abstractEvent.end;// "
start=date.clone();end=null;if(startTime){start=start.time(startTime);}if(endTime){end=date.clone().time(endTime);}event=$.extend({},abstractEvent);// make a copy of the original
assignDatesToEvent(start,end,!startTime&&!endTime,// allDay?
event);events.push(event);}date.add(1,'days');}}else{events.push(abstractEvent);// return the original event. will be a one-item array
}}return events;}/* Event Modification Math
	-----------------------------------------------------------------------------------------*/// Modifies an event and all related events by applying the given properties.
// Special date-diffing logic is used for manipulation of dates.
// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
// All date comparisons are done against the event's pristine _start and _end dates.
// Returns an object with delta information and a function to undo all operations.
// For making computations in a granularity greater than day/time, specify largeUnit.
// NOTE: The given `newProps` might be mutated for normalization purposes.
function mutateEvent(event,newProps,largeUnit){var miscProps={};var oldProps;var clearEnd;var startDelta;var endDelta;var durationDelta;var undoFunc;// diffs the dates in the appropriate way, returning a duration
function diffDates(date1,date0){// date1 - date0
if(largeUnit){return diffByUnit(date1,date0,largeUnit);}else if(newProps.allDay){return diffDay(date1,date0);}else{return diffDayTime(date1,date0);}}newProps=newProps||{};// normalize new date-related properties
if(!newProps.start){newProps.start=event.start.clone();}if(newProps.end===undefined){newProps.end=event.end?event.end.clone():null;}if(newProps.allDay==null){// is null or undefined?
newProps.allDay=event.allDay;}normalizeEventDates(newProps);// create normalized versions of the original props to compare against
// need a real end value, for diffing
oldProps={start:event._start.clone(),end:event._end?event._end.clone():t.getDefaultEventEnd(event._allDay,event._start),allDay:newProps.allDay// normalize the dates in the same regard as the new properties
};normalizeEventDates(oldProps);// need to clear the end date if explicitly changed to null
clearEnd=event._end!==null&&newProps.end===null;// compute the delta for moving the start date
startDelta=diffDates(newProps.start,oldProps.start);// compute the delta for moving the end date
if(newProps.end){endDelta=diffDates(newProps.end,oldProps.end);durationDelta=endDelta.subtract(startDelta);}else{durationDelta=null;}// gather all non-date-related properties
$.each(newProps,function(name,val){if(isMiscEventPropName(name)){if(val!==undefined){miscProps[name]=val;}}});// apply the operations to the event and all related events
undoFunc=mutateEvents(clientEvents(event._id),// get events with this ID
clearEnd,newProps.allDay,startDelta,durationDelta,miscProps);return{dateDelta:startDelta,durationDelta:durationDelta,undo:undoFunc};}// Modifies an array of events in the following ways (operations are in order):
// - clear the event's `end`
// - convert the event to allDay
// - add `dateDelta` to the start and end
// - add `durationDelta` to the event's duration
// - assign `miscProps` to the event
//
// Returns a function that can be called to undo all the operations.
//
// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
//
function mutateEvents(events,clearEnd,allDay,dateDelta,durationDelta,miscProps){var isAmbigTimezone=t.getIsAmbigTimezone();var undoFunctions=[];// normalize zero-length deltas to be null
if(dateDelta&&!dateDelta.valueOf()){dateDelta=null;}if(durationDelta&&!durationDelta.valueOf()){durationDelta=null;}$.each(events,function(i,event){var oldProps;var newProps;// build an object holding all the old values, both date-related and misc.
// for the undo function.
oldProps={start:event.start.clone(),end:event.end?event.end.clone():null,allDay:event.allDay};$.each(miscProps,function(name){oldProps[name]=event[name];});// new date-related properties. work off the original date snapshot.
// ok to use references because they will be thrown away when backupEventDates is called.
newProps={start:event._start,end:event._end,allDay:allDay// normalize the dates in the same regard as the new properties
};normalizeEventDates(newProps);// massages start/end/allDay
// strip or ensure the end date
if(clearEnd){newProps.end=null;}else if(durationDelta&&!newProps.end){// the duration translation requires an end date
newProps.end=t.getDefaultEventEnd(newProps.allDay,newProps.start);}if(dateDelta){newProps.start.add(dateDelta);if(newProps.end){newProps.end.add(dateDelta);}}if(durationDelta){newProps.end.add(durationDelta);// end already ensured above
}// if the dates have changed, and we know it is impossible to recompute the
// timezone offsets, strip the zone.
if(isAmbigTimezone&&!newProps.allDay&&(dateDelta||durationDelta)){newProps.start.stripZone();if(newProps.end){newProps.end.stripZone();}}$.extend(event,miscProps,newProps);// copy over misc props, then date-related props
backupEventDates(event);// regenerate internal _start/_end/_allDay
undoFunctions.push(function(){$.extend(event,oldProps);backupEventDates(event);// regenerate internal _start/_end/_allDay
});});return function(){for(var i=0;i<undoFunctions.length;i++){undoFunctions[i]();}};}/* Business Hours
	-----------------------------------------------------------------------------------------*/t.getBusinessHoursEvents=getBusinessHoursEvents;// Returns an array of events as to when the business hours occur in the given view.
// Abuse of our event system :(
function getBusinessHoursEvents(wholeDay){var optionVal=t.options.businessHours;var defaultVal={className:'fc-nonbusiness',start:'09:00',end:'17:00',dow:[1,2,3,4,5],// monday - friday
rendering:'inverse-background'};var view=t.getView();var eventInput;if(optionVal){// `true` (which means "use the defaults") or an override object
eventInput=$.extend({},// copy to a new object in either case
defaultVal,(typeof optionVal==='undefined'?'undefined':(0,_typeof3.default)(optionVal))==='object'?optionVal:{}// override the defaults
);}if(eventInput){// if a whole-day series is requested, clear the start/end times
if(wholeDay){eventInput.start=null;eventInput.end=null;}return expandEvent(buildEventFromInput(eventInput),view.start,view.end);}return[];}/* Overlapping / Constraining
	-----------------------------------------------------------------------------------------*/t.isEventSpanAllowed=isEventSpanAllowed;t.isExternalSpanAllowed=isExternalSpanAllowed;t.isSelectionSpanAllowed=isSelectionSpanAllowed;// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
function isEventSpanAllowed(span,event){var source=event.source||{};var constraint=firstDefined(event.constraint,source.constraint,t.options.eventConstraint);var overlap=firstDefined(event.overlap,source.overlap,t.options.eventOverlap);return isSpanAllowed(span,constraint,overlap,event);}// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
function isExternalSpanAllowed(eventSpan,eventLocation,eventProps){var eventInput;var event;// note: very similar logic is in View's reportExternalDrop
if(eventProps){eventInput=$.extend({},eventProps,eventLocation);event=expandEvent(buildEventFromInput(eventInput))[0];}if(event){return isEventSpanAllowed(eventSpan,event);}else{// treat it as a selection
return isSelectionSpanAllowed(eventSpan);}}// Determines the given span (unzoned start/end with other misc data) can be selected.
function isSelectionSpanAllowed(span){return isSpanAllowed(span,t.options.selectConstraint,t.options.selectOverlap);}// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
function isSpanAllowed(span,constraint,overlap,event){var constraintEvents;var anyContainment;var peerEvents;var i,peerEvent;var peerOverlap;// the range must be fully contained by at least one of produced constraint events
if(constraint!=null){// not treated as an event! intermediate data structure
// TODO: use ranges in the future
constraintEvents=constraintToEvents(constraint);anyContainment=false;for(i=0;i<constraintEvents.length;i++){if(eventContainsRange(constraintEvents[i],span)){anyContainment=true;break;}}if(!anyContainment){return false;}}peerEvents=t.getPeerEvents(span,event);for(i=0;i<peerEvents.length;i++){peerEvent=peerEvents[i];// there needs to be an actual intersection before disallowing anything
if(eventIntersectsRange(peerEvent,span)){// evaluate overlap for the given range and short-circuit if necessary
if(overlap===false){return false;}// if the event's overlap is a test function, pass the peer event in question as the first param
else if(typeof overlap==='function'&&!overlap(peerEvent,event)){return false;}// if we are computing if the given range is allowable for an event, consider the other event's
// EventObject-specific or Source-specific `overlap` property
if(event){peerOverlap=firstDefined(peerEvent.overlap,(peerEvent.source||{}).overlap// we already considered the global `eventOverlap`
);if(peerOverlap===false){return false;}// if the peer event's overlap is a test function, pass the subject event as the first param
if(typeof peerOverlap==='function'&&!peerOverlap(event,peerEvent)){return false;}}}}return true;}// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
function constraintToEvents(constraintInput){if(constraintInput==='businessHours'){return getBusinessHoursEvents();}if((typeof constraintInput==='undefined'?'undefined':(0,_typeof3.default)(constraintInput))==='object'){return expandEvent(buildEventFromInput(constraintInput));}return clientEvents(constraintInput);// probably an ID
}// Does the event's date range fully contain the given range?
// start/end already assumed to have stripped zones :(
function eventContainsRange(event,range){var eventStart=event.start.clone().stripZone();var eventEnd=t.getEventEnd(event).stripZone();return range.start>=eventStart&&range.end<=eventEnd;}// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
function eventIntersectsRange(event,range){var eventStart=event.start.clone().stripZone();var eventEnd=t.getEventEnd(event).stripZone();return range.start<eventEnd&&range.end>eventStart;}t.getEventCache=function(){return cache;};}// hook for external libs to manipulate event properties upon creation.
// should manipulate the event in-place.
Calendar.prototype.normalizeEvent=function(event){};// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
Calendar.prototype.getPeerEvents=function(span,event){var cache=this.getEventCache();var peerEvents=[];var i,otherEvent;for(i=0;i<cache.length;i++){otherEvent=cache[i];if(!event||event._id!==otherEvent._id// don't compare the event to itself or other related [repeating] events
){peerEvents.push(otherEvent);}}return peerEvents;};// updates the "backup" properties, which are preserved in order to compute diffs later on.
function backupEventDates(event){event._allDay=event.allDay;event._start=event.start.clone();event._end=event.end?event.end.clone():null;};;/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
var BasicView=FC.BasicView=View.extend({scroller:null,dayGridClass:DayGrid,// class the dayGrid will be instantiated from (overridable by subclasses)
dayGrid:null,// the main subcomponent that does most of the heavy lifting
dayNumbersVisible:false,// display day numbers on each day cell?
weekNumbersVisible:false,// display week numbers along the side?
weekNumberWidth:null,// width of all the week-number cells running down the side
headContainerEl:null,// div that hold's the dayGrid's rendered date header
headRowEl:null,// the fake row element of the day-of-week header
initialize:function initialize(){this.dayGrid=this.instantiateDayGrid();this.scroller=new Scroller({overflowX:'hidden',overflowY:'auto'});},// Generates the DayGrid object this view needs. Draws from this.dayGridClass
instantiateDayGrid:function instantiateDayGrid(){// generate a subclass on the fly with BasicView-specific behavior
// TODO: cache this subclass
var subclass=this.dayGridClass.extend(basicDayGridMethods);return new subclass(this);},// Sets the display range and computes all necessary dates
setRange:function setRange(range){View.prototype.setRange.call(this,range);// call the super-method
this.dayGrid.breakOnWeeks=/year|month|week/.test(this.intervalUnit);// do before setRange
this.dayGrid.setRange(range);},// Compute the value to feed into setRange. Overrides superclass.
computeRange:function computeRange(date){var range=View.prototype.computeRange.call(this,date);// get value from the super-method
// year and month views should be aligned with weeks. this is already done for week
if(/year|month/.test(range.intervalUnit)){range.start.startOf('week');range.start=this.skipHiddenDays(range.start);// make end-of-week if not already
if(range.end.weekday()){range.end.add(1,'week').startOf('week');range.end=this.skipHiddenDays(range.end,-1,true);// exclusively move backwards
}}return range;},// Renders the view into `this.el`, which should already be assigned
renderDates:function renderDates(){this.dayNumbersVisible=this.dayGrid.rowCnt>1;// TODO: make grid responsible
this.weekNumbersVisible=this.opt('weekNumbers');this.dayGrid.numbersVisible=this.dayNumbersVisible||this.weekNumbersVisible;this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());this.renderHead();this.scroller.render();var dayGridContainerEl=this.scroller.el.addClass('fc-day-grid-container');var dayGridEl=$('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);this.el.find('.fc-body > tr > td').append(dayGridContainerEl);this.dayGrid.setElement(dayGridEl);this.dayGrid.renderDates(this.hasRigidRows());},// render the day-of-week headers
renderHead:function renderHead(){this.headContainerEl=this.el.find('.fc-head-container').html(this.dayGrid.renderHeadHtml());this.headRowEl=this.headContainerEl.find('.fc-row');},// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
// always completely kill the dayGrid's rendering.
unrenderDates:function unrenderDates(){this.dayGrid.unrenderDates();this.dayGrid.removeElement();this.scroller.destroy();},renderBusinessHours:function renderBusinessHours(){this.dayGrid.renderBusinessHours();},unrenderBusinessHours:function unrenderBusinessHours(){this.dayGrid.unrenderBusinessHours();},// Builds the HTML skeleton for the view.
// The day-grid component will render inside of a container defined by this HTML.
renderSkeletonHtml:function renderSkeletonHtml(){return''+'<table>'+'<thead class="fc-head">'+'<tr>'+'<td class="fc-head-container '+this.widgetHeaderClass+'"></td>'+'</tr>'+'</thead>'+'<tbody class="fc-body">'+'<tr>'+'<td class="'+this.widgetContentClass+'"></td>'+'</tr>'+'</tbody>'+'</table>';},// Generates an HTML attribute string for setting the width of the week number column, if it is known
weekNumberStyleAttr:function weekNumberStyleAttr(){if(this.weekNumberWidth!==null){return'style="width:'+this.weekNumberWidth+'px"';}return'';},// Determines whether each row should have a constant height
hasRigidRows:function hasRigidRows(){var eventLimit=this.opt('eventLimit');return eventLimit&&typeof eventLimit!=='number';},/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/// Refreshes the horizontal dimensions of the view
updateWidth:function updateWidth(){if(this.weekNumbersVisible){// Make sure all week number cells running down the side have the same width.
// Record the width for cells created later.
this.weekNumberWidth=matchCellWidths(this.el.find('.fc-week-number'));}},// Adjusts the vertical dimensions of the view to the specified values
setHeight:function setHeight(totalHeight,isAuto){var eventLimit=this.opt('eventLimit');var scrollerHeight;var scrollbarWidths;// reset all heights to be natural
this.scroller.clear();uncompensateScroll(this.headRowEl);this.dayGrid.removeSegPopover();// kill the "more" popover if displayed
// is the event limit a constant level number?
if(eventLimit&&typeof eventLimit==='number'){this.dayGrid.limitRows(eventLimit);// limit the levels first so the height can redistribute after
}// distribute the height to the rows
// (totalHeight is a "recommended" value if isAuto)
scrollerHeight=this.computeScrollerHeight(totalHeight);this.setGridHeight(scrollerHeight,isAuto);// is the event limit dynamically calculated?
if(eventLimit&&typeof eventLimit!=='number'){this.dayGrid.limitRows(eventLimit);// limit the levels after the grid's row heights have been set
}if(!isAuto){// should we force dimensions of the scroll container?
this.scroller.setHeight(scrollerHeight);scrollbarWidths=this.scroller.getScrollbarWidths();if(scrollbarWidths.left||scrollbarWidths.right){// using scrollbars?
compensateScroll(this.headRowEl,scrollbarWidths);// doing the scrollbar compensation might have created text overflow which created more height. redo
scrollerHeight=this.computeScrollerHeight(totalHeight);this.scroller.setHeight(scrollerHeight);}// guarantees the same scrollbar widths
this.scroller.lockOverflow(scrollbarWidths);}},// given a desired total height of the view, returns what the height of the scroller should be
computeScrollerHeight:function computeScrollerHeight(totalHeight){return totalHeight-subtractInnerElHeight(this.el,this.scroller.el);// everything that's NOT the scroller
},// Sets the height of just the DayGrid component in this view
setGridHeight:function setGridHeight(height,isAuto){if(isAuto){undistributeHeight(this.dayGrid.rowEls);// let the rows be their natural height with no expanding
}else{distributeHeight(this.dayGrid.rowEls,height,true);// true = compensate for height-hogging rows
}},/* Scroll
	------------------------------------------------------------------------------------------------------------------*/queryScroll:function queryScroll(){return this.scroller.getScrollTop();},setScroll:function setScroll(top){this.scroller.setScrollTop(top);},/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/// forward all hit-related method calls to dayGrid
prepareHits:function prepareHits(){this.dayGrid.prepareHits();},releaseHits:function releaseHits(){this.dayGrid.releaseHits();},queryHit:function queryHit(left,top){return this.dayGrid.queryHit(left,top);},getHitSpan:function getHitSpan(hit){return this.dayGrid.getHitSpan(hit);},getHitEl:function getHitEl(hit){return this.dayGrid.getHitEl(hit);},/* Events
	------------------------------------------------------------------------------------------------------------------*/// Renders the given events onto the view and populates the segments array
renderEvents:function renderEvents(events){this.dayGrid.renderEvents(events);this.updateHeight();// must compensate for events that overflow the row
},// Retrieves all segment objects that are rendered in the view
getEventSegs:function getEventSegs(){return this.dayGrid.getEventSegs();},// Unrenders all event elements and clears internal segment data
unrenderEvents:function unrenderEvents(){this.dayGrid.unrenderEvents();// we DON'T need to call updateHeight() because:
// A) a renderEvents() call always happens after this, which will eventually call updateHeight()
// B) in IE8, this causes a flash whenever events are rerendered
},/* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function renderDrag(dropLocation,seg){return this.dayGrid.renderDrag(dropLocation,seg);},unrenderDrag:function unrenderDrag(){this.dayGrid.unrenderDrag();},/* Selection
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of a selection
renderSelection:function renderSelection(span){this.dayGrid.renderSelection(span);},// Unrenders a visual indications of a selection
unrenderSelection:function unrenderSelection(){this.dayGrid.unrenderSelection();}});// Methods that will customize the rendering behavior of the BasicView's dayGrid
var basicDayGridMethods={// Generates the HTML that will go before the day-of week header cells
renderHeadIntroHtml:function renderHeadIntroHtml(){var view=this.view;if(view.weekNumbersVisible){return''+'<th class="fc-week-number '+view.widgetHeaderClass+'" '+view.weekNumberStyleAttr()+'>'+'<span>'+// needed for matchCellWidths
htmlEscape(view.opt('weekNumberTitle'))+'</span>'+'</th>';}return'';},// Generates the HTML that will go before content-skeleton cells that display the day/week numbers
renderNumberIntroHtml:function renderNumberIntroHtml(row){var view=this.view;if(view.weekNumbersVisible){return''+'<td class="fc-week-number" '+view.weekNumberStyleAttr()+'>'+'<span>'+// needed for matchCellWidths
this.getCellDate(row,0).format('w')+'</span>'+'</td>';}return'';},// Generates the HTML that goes before the day bg cells for each day-row
renderBgIntroHtml:function renderBgIntroHtml(){var view=this.view;if(view.weekNumbersVisible){return'<td class="fc-week-number '+view.widgetContentClass+'" '+view.weekNumberStyleAttr()+'></td>';}return'';},// Generates the HTML that goes before every other type of row generated by DayGrid.
// Affects helper-skeleton and highlight-skeleton rows.
renderIntroHtml:function renderIntroHtml(){var view=this.view;if(view.weekNumbersVisible){return'<td class="fc-week-number" '+view.weekNumberStyleAttr()+'></td>';}return'';}};;;/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/var MonthView=FC.MonthView=BasicView.extend({// Produces information about what range to display
computeRange:function computeRange(date){var range=BasicView.prototype.computeRange.call(this,date);// get value from super-method
var rowCnt;// ensure 6 weeks
if(this.isFixedWeeks()){rowCnt=Math.ceil(range.end.diff(range.start,'weeks',true));// could be partial weeks due to hiddenDays
range.end.add(6-rowCnt,'weeks');}return range;},// Overrides the default BasicView behavior to have special multi-week auto-height logic
setGridHeight:function setGridHeight(height,isAuto){isAuto=isAuto||this.opt('weekMode')==='variable';// LEGACY: weekMode is deprecated
// if auto, make the height of each row the height that it would be if there were 6 weeks
if(isAuto){height*=this.rowCnt/6;}distributeHeight(this.dayGrid.rowEls,height,!isAuto);// if auto, don't compensate for height-hogging rows
},isFixedWeeks:function isFixedWeeks(){var weekMode=this.opt('weekMode');// LEGACY: weekMode is deprecated
if(weekMode){return weekMode==='fixed';// if any other type of weekMode, assume NOT fixed
}return this.opt('fixedWeekCount');}});;;fcViews.basic={'class':BasicView};fcViews.basicDay={type:'basic',duration:{days:1}};fcViews.basicWeek={type:'basic',duration:{weeks:1}};fcViews.month={'class':MonthView,duration:{months:1},// important for prev/next
defaults:{fixedWeekCount:true}};;;/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
var AgendaView=FC.AgendaView=View.extend({scroller:null,timeGridClass:TimeGrid,// class used to instantiate the timeGrid. subclasses can override
timeGrid:null,// the main time-grid subcomponent of this view
dayGridClass:DayGrid,// class used to instantiate the dayGrid. subclasses can override
dayGrid:null,// the "all-day" subcomponent. if all-day is turned off, this will be null
axisWidth:null,// the width of the time axis running down the side
headContainerEl:null,// div that hold's the timeGrid's rendered date header
noScrollRowEls:null,// set of fake row elements that must compensate when scroller has scrollbars
// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
bottomRuleEl:null,initialize:function initialize(){this.timeGrid=this.instantiateTimeGrid();if(this.opt('allDaySlot')){// should we display the "all-day" area?
this.dayGrid=this.instantiateDayGrid();// the all-day subcomponent of this view
}this.scroller=new Scroller({overflowX:'hidden',overflowY:'auto'});},// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
instantiateTimeGrid:function instantiateTimeGrid(){var subclass=this.timeGridClass.extend(agendaTimeGridMethods);return new subclass(this);},// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
instantiateDayGrid:function instantiateDayGrid(){var subclass=this.dayGridClass.extend(agendaDayGridMethods);return new subclass(this);},/* Rendering
	------------------------------------------------------------------------------------------------------------------*/// Sets the display range and computes all necessary dates
setRange:function setRange(range){View.prototype.setRange.call(this,range);// call the super-method
this.timeGrid.setRange(range);if(this.dayGrid){this.dayGrid.setRange(range);}},// Renders the view into `this.el`, which has already been assigned
renderDates:function renderDates(){this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());this.renderHead();this.scroller.render();var timeGridWrapEl=this.scroller.el.addClass('fc-time-grid-container');var timeGridEl=$('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);this.el.find('.fc-body > tr > td').append(timeGridWrapEl);this.timeGrid.setElement(timeGridEl);this.timeGrid.renderDates();// the <hr> that sometimes displays under the time-grid
this.bottomRuleEl=$('<hr class="fc-divider '+this.widgetHeaderClass+'"/>').appendTo(this.timeGrid.el);// inject it into the time-grid
if(this.dayGrid){this.dayGrid.setElement(this.el.find('.fc-day-grid'));this.dayGrid.renderDates();// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
this.dayGrid.bottomCoordPadding=this.dayGrid.el.next('hr').outerHeight();}this.noScrollRowEls=this.el.find('.fc-row:not(.fc-scroller *)');// fake rows not within the scroller
},// render the day-of-week headers
renderHead:function renderHead(){this.headContainerEl=this.el.find('.fc-head-container').html(this.timeGrid.renderHeadHtml());},// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
// always completely kill each grid's rendering.
unrenderDates:function unrenderDates(){this.timeGrid.unrenderDates();this.timeGrid.removeElement();if(this.dayGrid){this.dayGrid.unrenderDates();this.dayGrid.removeElement();}this.scroller.destroy();},// Builds the HTML skeleton for the view.
// The day-grid and time-grid components will render inside containers defined by this HTML.
renderSkeletonHtml:function renderSkeletonHtml(){return''+'<table>'+'<thead class="fc-head">'+'<tr>'+'<td class="fc-head-container '+this.widgetHeaderClass+'"></td>'+'</tr>'+'</thead>'+'<tbody class="fc-body">'+'<tr>'+'<td class="'+this.widgetContentClass+'">'+(this.dayGrid?'<div class="fc-day-grid"/>'+'<hr class="fc-divider '+this.widgetHeaderClass+'"/>':'')+'</td>'+'</tr>'+'</tbody>'+'</table>';},// Generates an HTML attribute string for setting the width of the axis, if it is known
axisStyleAttr:function axisStyleAttr(){if(this.axisWidth!==null){return'style="width:'+this.axisWidth+'px"';}return'';},/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/renderBusinessHours:function renderBusinessHours(){this.timeGrid.renderBusinessHours();if(this.dayGrid){this.dayGrid.renderBusinessHours();}},unrenderBusinessHours:function unrenderBusinessHours(){this.timeGrid.unrenderBusinessHours();if(this.dayGrid){this.dayGrid.unrenderBusinessHours();}},/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/getNowIndicatorUnit:function getNowIndicatorUnit(){return this.timeGrid.getNowIndicatorUnit();},renderNowIndicator:function renderNowIndicator(date){this.timeGrid.renderNowIndicator(date);},unrenderNowIndicator:function unrenderNowIndicator(){this.timeGrid.unrenderNowIndicator();},/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/updateSize:function updateSize(isResize){this.timeGrid.updateSize(isResize);View.prototype.updateSize.call(this,isResize);// call the super-method
},// Refreshes the horizontal dimensions of the view
updateWidth:function updateWidth(){// make all axis cells line up, and record the width so newly created axis cells will have it
this.axisWidth=matchCellWidths(this.el.find('.fc-axis'));},// Adjusts the vertical dimensions of the view to the specified values
setHeight:function setHeight(totalHeight,isAuto){var eventLimit;var scrollerHeight;var scrollbarWidths;// reset all dimensions back to the original state
this.bottomRuleEl.hide();// .show() will be called later if this <hr> is necessary
this.scroller.clear();// sets height to 'auto' and clears overflow
uncompensateScroll(this.noScrollRowEls);// limit number of events in the all-day area
if(this.dayGrid){this.dayGrid.removeSegPopover();// kill the "more" popover if displayed
eventLimit=this.opt('eventLimit');if(eventLimit&&typeof eventLimit!=='number'){eventLimit=AGENDA_ALL_DAY_EVENT_LIMIT;// make sure "auto" goes to a real number
}if(eventLimit){this.dayGrid.limitRows(eventLimit);}}if(!isAuto){// should we force dimensions of the scroll container?
scrollerHeight=this.computeScrollerHeight(totalHeight);this.scroller.setHeight(scrollerHeight);scrollbarWidths=this.scroller.getScrollbarWidths();if(scrollbarWidths.left||scrollbarWidths.right){// using scrollbars?
// make the all-day and header rows lines up
compensateScroll(this.noScrollRowEls,scrollbarWidths);// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
// and reapply the desired height to the scroller.
scrollerHeight=this.computeScrollerHeight(totalHeight);this.scroller.setHeight(scrollerHeight);}// guarantees the same scrollbar widths
this.scroller.lockOverflow(scrollbarWidths);// if there's any space below the slats, show the horizontal rule.
// this won't cause any new overflow, because lockOverflow already called.
if(this.timeGrid.getTotalSlatHeight()<scrollerHeight){this.bottomRuleEl.show();}}},// given a desired total height of the view, returns what the height of the scroller should be
computeScrollerHeight:function computeScrollerHeight(totalHeight){return totalHeight-subtractInnerElHeight(this.el,this.scroller.el);// everything that's NOT the scroller
},/* Scroll
	------------------------------------------------------------------------------------------------------------------*/// Computes the initial pre-configured scroll state prior to allowing the user to change it
computeInitialScroll:function computeInitialScroll(){var scrollTime=moment.duration(this.opt('scrollTime'));var top=this.timeGrid.computeTimeTop(scrollTime);// zoom can give weird floating-point values. rather scroll a little bit further
top=Math.ceil(top);if(top){top++;// to overcome top border that slots beyond the first have. looks better
}return top;},queryScroll:function queryScroll(){return this.scroller.getScrollTop();},setScroll:function setScroll(top){this.scroller.setScrollTop(top);},/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/// forward all hit-related method calls to the grids (dayGrid might not be defined)
prepareHits:function prepareHits(){this.timeGrid.prepareHits();if(this.dayGrid){this.dayGrid.prepareHits();}},releaseHits:function releaseHits(){this.timeGrid.releaseHits();if(this.dayGrid){this.dayGrid.releaseHits();}},queryHit:function queryHit(left,top){var hit=this.timeGrid.queryHit(left,top);if(!hit&&this.dayGrid){hit=this.dayGrid.queryHit(left,top);}return hit;},getHitSpan:function getHitSpan(hit){// TODO: hit.component is set as a hack to identify where the hit came from
return hit.component.getHitSpan(hit);},getHitEl:function getHitEl(hit){// TODO: hit.component is set as a hack to identify where the hit came from
return hit.component.getHitEl(hit);},/* Events
	------------------------------------------------------------------------------------------------------------------*/// Renders events onto the view and populates the View's segment array
renderEvents:function renderEvents(events){var dayEvents=[];var timedEvents=[];var daySegs=[];var timedSegs;var i;// separate the events into all-day and timed
for(i=0;i<events.length;i++){if(events[i].allDay){dayEvents.push(events[i]);}else{timedEvents.push(events[i]);}}// render the events in the subcomponents
timedSegs=this.timeGrid.renderEvents(timedEvents);if(this.dayGrid){daySegs=this.dayGrid.renderEvents(dayEvents);}// the all-day area is flexible and might have a lot of events, so shift the height
this.updateHeight();},// Retrieves all segment objects that are rendered in the view
getEventSegs:function getEventSegs(){return this.timeGrid.getEventSegs().concat(this.dayGrid?this.dayGrid.getEventSegs():[]);},// Unrenders all event elements and clears internal segment data
unrenderEvents:function unrenderEvents(){// unrender the events in the subcomponents
this.timeGrid.unrenderEvents();if(this.dayGrid){this.dayGrid.unrenderEvents();}// we DON'T need to call updateHeight() because:
// A) a renderEvents() call always happens after this, which will eventually call updateHeight()
// B) in IE8, this causes a flash whenever events are rerendered
},/* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function renderDrag(dropLocation,seg){if(dropLocation.start.hasTime()){return this.timeGrid.renderDrag(dropLocation,seg);}else if(this.dayGrid){return this.dayGrid.renderDrag(dropLocation,seg);}},unrenderDrag:function unrenderDrag(){this.timeGrid.unrenderDrag();if(this.dayGrid){this.dayGrid.unrenderDrag();}},/* Selection
	------------------------------------------------------------------------------------------------------------------*/// Renders a visual indication of a selection
renderSelection:function renderSelection(span){if(span.start.hasTime()||span.end.hasTime()){this.timeGrid.renderSelection(span);}else if(this.dayGrid){this.dayGrid.renderSelection(span);}},// Unrenders a visual indications of a selection
unrenderSelection:function unrenderSelection(){this.timeGrid.unrenderSelection();if(this.dayGrid){this.dayGrid.unrenderSelection();}}});// Methods that will customize the rendering behavior of the AgendaView's timeGrid
// TODO: move into TimeGrid
var agendaTimeGridMethods={// Generates the HTML that will go before the day-of week header cells
renderHeadIntroHtml:function renderHeadIntroHtml(){var view=this.view;var weekText;if(view.opt('weekNumbers')){weekText=this.start.format(view.opt('smallWeekFormat'));return''+'<th class="fc-axis fc-week-number '+view.widgetHeaderClass+'" '+view.axisStyleAttr()+'>'+'<span>'+// needed for matchCellWidths
htmlEscape(weekText)+'</span>'+'</th>';}else{return'<th class="fc-axis '+view.widgetHeaderClass+'" '+view.axisStyleAttr()+'></th>';}},// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
renderBgIntroHtml:function renderBgIntroHtml(){var view=this.view;return'<td class="fc-axis '+view.widgetContentClass+'" '+view.axisStyleAttr()+'></td>';},// Generates the HTML that goes before all other types of cells.
// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
renderIntroHtml:function renderIntroHtml(){var view=this.view;return'<td class="fc-axis" '+view.axisStyleAttr()+'></td>';}};// Methods that will customize the rendering behavior of the AgendaView's dayGrid
var agendaDayGridMethods={// Generates the HTML that goes before the all-day cells
renderBgIntroHtml:function renderBgIntroHtml(){var view=this.view;return''+'<td class="fc-axis '+view.widgetContentClass+'" '+view.axisStyleAttr()+'>'+'<span>'+(// needed for matchCellWidths
view.opt('allDayHtml')||htmlEscape(view.opt('allDayText')))+'</span>'+'</td>';},// Generates the HTML that goes before all other types of cells.
// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
renderIntroHtml:function renderIntroHtml(){var view=this.view;return'<td class="fc-axis" '+view.axisStyleAttr()+'></td>';}};;;var AGENDA_ALL_DAY_EVENT_LIMIT=5;// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS=[{hours:1},{minutes:30},{minutes:15},{seconds:30},{seconds:15}];fcViews.agenda={'class':AgendaView,defaults:{allDaySlot:true,allDayText:'all-day',slotDuration:'00:30:00',minTime:'00:00:00',maxTime:'24:00:00',slotEventOverlap:true// a bad name. confused with overlap/constraint system
}};fcViews.agendaDay={type:'agenda',duration:{days:1}};fcViews.agendaWeek={type:'agenda',duration:{weeks:1}};;;return FC;// export for Node/CommonJS
});/*!
 * FullCalendar v2.9.0
 * Docs & License: http://fullcalendar.io/
 * (c) 2016 Adam Shaw
 */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9jYWxlbmRhci92ZW5kb3IvZnVsbGNhbGVuZGFyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnSEFPQSw4QixnSUFFQSxDQUFDLFNBQVMsT0FBVCxDQUFrQixDQUNsQixRQUFRLE9BQU8sTUFBZixtQkFDQSxDQUZELEVBRUcsU0FBUyxDQUFULENBQVksTUFBWixDQUFvQixDQUV2QixDQUFDLENBRUQsR0FBSSxJQUFLLEVBQUUsWUFBRixDQUFpQixDQUN6QixRQUFTLE9BRGdCLENBRXpCLG1CQUFvQixDQUZLLENBQTFCLENBSUEsR0FBSSxTQUFVLEdBQUcsS0FBSCxDQUFXLEVBQXpCLENBR0EsRUFBRSxFQUFGLENBQUssWUFBTCxDQUFvQixTQUFTLE9BQVQsQ0FBa0IsQ0FDckMsR0FBSSxNQUFPLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFzQyxDQUF0QyxDQUFYLEM7QUFDQSxHQUFJLEtBQU0sSUFBVixDO0FBRUEsS0FBSyxJQUFMLENBQVUsU0FBUyxDQUFULENBQVksUUFBWixDQUFzQixDO0FBQy9CLEdBQUksU0FBVSxFQUFFLFFBQUYsQ0FBZCxDQUNBLEdBQUksVUFBVyxRQUFRLElBQVIsQ0FBYSxjQUFiLENBQWYsQztBQUNBLEdBQUksVUFBSixDOztBQUdBLEdBQUksTUFBTyxRQUFQLEdBQW1CLFFBQXZCLENBQWlDLENBQ2hDLEdBQUksVUFBWSxFQUFFLFVBQUYsQ0FBYSxTQUFTLE9BQVQsQ0FBYixDQUFoQixDQUFpRCxDQUNoRCxVQUFZLFNBQVMsT0FBVCxFQUFrQixLQUFsQixDQUF3QixRQUF4QixDQUFrQyxJQUFsQyxDQUFaLENBQ0EsR0FBSSxDQUFDLENBQUwsQ0FBUSxDQUNQLElBQU0sU0FBTixDO0FBQ0EsQ0FDRCxHQUFJLFVBQVksU0FBaEIsQ0FBMkIsQztBQUMxQixRQUFRLFVBQVIsQ0FBbUIsY0FBbkIsRUFDQSxDQUNELENBQ0QsQztBQVZELElBWUssSUFBSSxDQUFDLFFBQUwsQ0FB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ZSI6ImZ1bGxjYWxlbmRhci5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9wZXRlci93ZWJkZXYvbm9kZWJiLXBsdWdpbi1jYWxlbmRhciIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRnVsbENhbGVuZGFyIHYyLjkuMFxuICogRG9jcyAmIExpY2Vuc2U6IGh0dHA6Ly9mdWxsY2FsZW5kYXIuaW8vXG4gKiAoYykgMjAxNiBBZGFtIFNoYXdcbiAqL1xuIFxuXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG5cdGZhY3Rvcnkod2luZG93LmpRdWVyeSwgbW9tZW50KTtcbn0pKGZ1bmN0aW9uKCQsIG1vbWVudCkge1xuXG47O1xuXG52YXIgRkMgPSAkLmZ1bGxDYWxlbmRhciA9IHtcblx0dmVyc2lvbjogXCIyLjkuMFwiLFxuXHRpbnRlcm5hbEFwaVZlcnNpb246IDRcbn07XG52YXIgZmNWaWV3cyA9IEZDLnZpZXdzID0ge307XG5cblxuJC5mbi5mdWxsQ2FsZW5kYXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIGEgcG9zc2libGUgbWV0aG9kIGNhbGxcblx0dmFyIHJlcyA9IHRoaXM7IC8vIHdoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiAodGhpcyBqUXVlcnkgb2JqZWN0IGJ5IGRlZmF1bHQpXG5cblx0dGhpcy5lYWNoKGZ1bmN0aW9uKGksIF9lbGVtZW50KSB7IC8vIGxvb3AgZWFjaCBET00gZWxlbWVudCBpbnZvbHZlZFxuXHRcdHZhciBlbGVtZW50ID0gJChfZWxlbWVudCk7XG5cdFx0dmFyIGNhbGVuZGFyID0gZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInKTsgLy8gZ2V0IHRoZSBleGlzdGluZyBjYWxlbmRhciBvYmplY3QgKGlmIGFueSlcblx0XHR2YXIgc2luZ2xlUmVzOyAvLyB0aGUgcmV0dXJuZWQgdmFsdWUgb2YgdGhpcyBzaW5nbGUgbWV0aG9kIGNhbGxcblxuXHRcdC8vIGEgbWV0aG9kIGNhbGxcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAoY2FsZW5kYXIgJiYgJC5pc0Z1bmN0aW9uKGNhbGVuZGFyW29wdGlvbnNdKSkge1xuXHRcdFx0XHRzaW5nbGVSZXMgPSBjYWxlbmRhcltvcHRpb25zXS5hcHBseShjYWxlbmRhciwgYXJncyk7XG5cdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdHJlcyA9IHNpbmdsZVJlczsgLy8gcmVjb3JkIHRoZSBmaXJzdCBtZXRob2QgY2FsbCByZXN1bHRcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3B0aW9ucyA9PT0gJ2Rlc3Ryb3knKSB7IC8vIGZvciB0aGUgZGVzdHJveSBtZXRob2QsIG11c3QgcmVtb3ZlIENhbGVuZGFyIG9iamVjdCBkYXRhXG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVEYXRhKCdmdWxsQ2FsZW5kYXInKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBhIG5ldyBjYWxlbmRhciBpbml0aWFsaXphdGlvblxuXHRcdGVsc2UgaWYgKCFjYWxlbmRhcikgeyAvLyBkb24ndCBpbml0aWFsaXplIHR3aWNlXG5cdFx0XHRjYWxlbmRhciA9IG5ldyBDYWxlbmRhcihlbGVtZW50LCBvcHRpb25zKTtcblx0XHRcdGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJywgY2FsZW5kYXIpO1xuXHRcdFx0Y2FsZW5kYXIucmVuZGVyKCk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdHJldHVybiByZXM7XG59O1xuXG5cbnZhciBjb21wbGV4T3B0aW9ucyA9IFsgLy8gbmFtZXMgb2Ygb3B0aW9ucyB0aGF0IGFyZSBvYmplY3RzIHdob3NlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGNvbWJpbmVkXG5cdCdoZWFkZXInLFxuXHQnYnV0dG9uVGV4dCcsXG5cdCdidXR0b25JY29ucycsXG5cdCd0aGVtZUJ1dHRvbkljb25zJ1xuXTtcblxuXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3RcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25PYmpzKSB7XG5cdHJldHVybiBtZXJnZVByb3BzKG9wdGlvbk9ianMsIGNvbXBsZXhPcHRpb25zKTtcbn1cblxuXG4vLyBHaXZlbiBvcHRpb25zIHNwZWNpZmllZCBmb3IgdGhlIGNhbGVuZGFyJ3MgY29uc3RydWN0b3IsIG1hc3NhZ2VzIGFueSBsZWdhY3kgb3B0aW9ucyBpbnRvIGEgbm9uLWxlZ2FjeSBmb3JtLlxuLy8gQ29udmVydHMgVmlldy1PcHRpb24tSGFzaGVzIGludG8gdGhlIFZpZXctU3BlY2lmaWMtT3B0aW9ucyBmb3JtYXQuXG5mdW5jdGlvbiBtYXNzYWdlT3ZlcnJpZGVzKGlucHV0KSB7XG5cdHZhciBvdmVycmlkZXMgPSB7IHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSB9OyAvLyB0aGUgb3V0cHV0LiBlbnN1cmUgYSBgdmlld3NgIGhhc2hcblx0dmFyIHN1Yk9iajtcblxuXHQvLyBpdGVyYXRlIHRocm91Z2ggYWxsIG9wdGlvbiBvdmVycmlkZSBwcm9wZXJ0aWVzIChleGNlcHQgYHZpZXdzYClcblx0JC5lYWNoKGlucHV0LCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRpZiAobmFtZSAhPSAndmlld3MnKSB7XG5cblx0XHRcdC8vIGNvdWxkIHRoZSB2YWx1ZSBiZSBhIGxlZ2FjeSBWaWV3LU9wdGlvbi1IYXNoP1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQkLmlzUGxhaW5PYmplY3QodmFsKSAmJlxuXHRcdFx0XHQhLyh0aW1lfGR1cmF0aW9ufGludGVydmFsKSQvaS50ZXN0KG5hbWUpICYmIC8vIGV4Y2x1ZGUgZHVyYXRpb24gb3B0aW9ucy4gbWlnaHQgYmUgZ2l2ZW4gYXMgb2JqZWN0c1xuXHRcdFx0XHQkLmluQXJyYXkobmFtZSwgY29tcGxleE9wdGlvbnMpID09IC0xIC8vIGNvbXBsZXggb3B0aW9ucyBhcmVuJ3QgYWxsb3dlZCB0byBiZSBWaWV3LU9wdGlvbi1IYXNoZXNcblx0XHRcdCkge1xuXHRcdFx0XHRzdWJPYmogPSBudWxsO1xuXG5cdFx0XHRcdC8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHBvc3NpYmxlIFZpZXctT3B0aW9uLUhhc2ggdmFsdWVcblx0XHRcdFx0JC5lYWNoKHZhbCwgZnVuY3Rpb24oc3ViTmFtZSwgc3ViVmFsKSB7XG5cblx0XHRcdFx0XHQvLyBpcyB0aGUgcHJvcGVydHkgdGFyZ2V0aW5nIGEgdmlldz9cblx0XHRcdFx0XHRpZiAoL14obW9udGh8d2Vla3xkYXl8ZGVmYXVsdHxiYXNpYyhXZWVrfERheSk/fGFnZW5kYShXZWVrfERheSk/KSQvLnRlc3Qoc3ViTmFtZSkpIHtcblx0XHRcdFx0XHRcdGlmICghb3ZlcnJpZGVzLnZpZXdzW3N1Yk5hbWVdKSB7IC8vIGVuc3VyZSB0aGUgdmlldy10YXJnZXQgZW50cnkgZXhpc3RzXG5cdFx0XHRcdFx0XHRcdG92ZXJyaWRlcy52aWV3c1tzdWJOYW1lXSA9IHt9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3ZlcnJpZGVzLnZpZXdzW3N1Yk5hbWVdW25hbWVdID0gc3ViVmFsOyAvLyByZWNvcmQgdGhlIHZhbHVlIGluIHRoZSBgdmlld3NgIG9iamVjdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgLy8gYSBub24tVmlldy1PcHRpb24tSGFzaCBwcm9wZXJ0eVxuXHRcdFx0XHRcdFx0aWYgKCFzdWJPYmopIHtcblx0XHRcdFx0XHRcdFx0c3ViT2JqID0ge307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdWJPYmpbc3ViTmFtZV0gPSBzdWJWYWw7IC8vIGFjY3VtdWxhdGUgdGhlc2UgdW5yZWxhdGVkIHZhbHVlcyBmb3IgbGF0ZXJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChzdWJPYmopIHsgLy8gbm9uLVZpZXctT3B0aW9uLUhhc2ggcHJvcGVydGllcz8gdHJhbnNmZXIgdGhlbSBhcy1pc1xuXHRcdFx0XHRcdG92ZXJyaWRlc1tuYW1lXSA9IHN1Yk9iajtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG92ZXJyaWRlc1tuYW1lXSA9IHZhbDsgLy8gdHJhbnNmZXIgbm9ybWFsIG9wdGlvbnMgYXMtaXNcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBvdmVycmlkZXM7XG59XG5cbjs7XG5cbi8vIGV4cG9ydHNcbkZDLmludGVyc2VjdFJhbmdlcyA9IGludGVyc2VjdFJhbmdlcztcbkZDLmFwcGx5QWxsID0gYXBwbHlBbGw7XG5GQy5kZWJvdW5jZSA9IGRlYm91bmNlO1xuRkMuaXNJbnQgPSBpc0ludDtcbkZDLmh0bWxFc2NhcGUgPSBodG1sRXNjYXBlO1xuRkMuY3NzVG9TdHIgPSBjc3NUb1N0cjtcbkZDLnByb3h5ID0gcHJveHk7XG5GQy5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIgPSBjYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XG5cblxuLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIERPTSBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbi8vIEdpdmVuIHRoZSBzY3JvbGxiYXIgd2lkdGhzIG9mIHNvbWUgb3RoZXIgY29udGFpbmVyLCBjcmVhdGUgYm9yZGVycy9tYXJnaW5zIG9uIHJvd0VscyBpbiBvcmRlciB0byBtYXRjaCB0aGUgbGVmdFxuLy8gYW5kIHJpZ2h0IHNwYWNlIHRoYXQgd2FzIG9mZnNldCBieSB0aGUgc2Nyb2xsYmFycy4gQSAxLXBpeGVsIGJvcmRlciBmaXJzdCwgdGhlbiBtYXJnaW4gYmV5b25kIHRoYXQuXG5mdW5jdGlvbiBjb21wZW5zYXRlU2Nyb2xsKHJvd0Vscywgc2Nyb2xsYmFyV2lkdGhzKSB7XG5cdGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCkge1xuXHRcdHJvd0Vscy5jc3Moe1xuXHRcdFx0J2JvcmRlci1sZWZ0LXdpZHRoJzogMSxcblx0XHRcdCdtYXJnaW4tbGVmdCc6IHNjcm9sbGJhcldpZHRocy5sZWZ0IC0gMVxuXHRcdH0pO1xuXHR9XG5cdGlmIChzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHtcblx0XHRyb3dFbHMuY3NzKHtcblx0XHRcdCdib3JkZXItcmlnaHQtd2lkdGgnOiAxLFxuXHRcdFx0J21hcmdpbi1yaWdodCc6IHNjcm9sbGJhcldpZHRocy5yaWdodCAtIDFcblx0XHR9KTtcblx0fVxufVxuXG5cbi8vIFVuZG9lcyBjb21wZW5zYXRlU2Nyb2xsIGFuZCByZXN0b3JlcyBhbGwgYm9yZGVycy9tYXJnaW5zXG5mdW5jdGlvbiB1bmNvbXBlbnNhdGVTY3JvbGwocm93RWxzKSB7XG5cdHJvd0Vscy5jc3Moe1xuXHRcdCdtYXJnaW4tbGVmdCc6ICcnLFxuXHRcdCdtYXJnaW4tcmlnaHQnOiAnJyxcblx0XHQnYm9yZGVyLWxlZnQtd2lkdGgnOiAnJyxcblx0XHQnYm9yZGVyLXJpZ2h0LXdpZHRoJzogJydcblx0fSk7XG59XG5cblxuLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXG5mdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xuXHQkKCdib2R5JykuYWRkQ2xhc3MoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG5cblxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG5cdCQoJ2JvZHknKS5yZW1vdmVDbGFzcygnZmMtbm90LWFsbG93ZWQnKTtcbn1cblxuXG4vLyBHaXZlbiBhIHRvdGFsIGF2YWlsYWJsZSBoZWlnaHQgdG8gZmlsbCwgaGF2ZSBgZWxzYCAoZXNzZW50aWFsbHkgY2hpbGQgcm93cykgZXhwYW5kIHRvIGFjY29tb2RhdGUuXG4vLyBCeSBkZWZhdWx0LCBhbGwgZWxlbWVudHMgdGhhdCBhcmUgc2hvcnRlciB0aGFuIHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgYXJlIGV4cGFuZGVkIHVuaWZvcm1seSwgbm90IGNvbnNpZGVyaW5nXG4vLyBhbnkgb3RoZXIgZWxzIHRoYXQgYXJlIGFscmVhZHkgdG9vIHRhbGwuIGlmIGBzaG91bGRSZWRpc3RyaWJ1dGVgIGlzIG9uLCBpdCBjb25zaWRlcnMgdGhlc2UgdGFsbCByb3dzIGFuZCBcbi8vIHJlZHVjZXMgdGhlIGF2YWlsYWJsZSBoZWlnaHQuXG5mdW5jdGlvbiBkaXN0cmlidXRlSGVpZ2h0KGVscywgYXZhaWxhYmxlSGVpZ2h0LCBzaG91bGRSZWRpc3RyaWJ1dGUpIHtcblxuXHQvLyAqRkxPT1JJTkcgTk9URSo6IHdlIGZsb29yIGluIGNlcnRhaW4gcGxhY2VzIGJlY2F1c2Ugem9vbSBjYW4gZ2l2ZSBpbmFjY3VyYXRlIGZsb2F0aW5nLXBvaW50IGRpbWVuc2lvbnMsXG5cdC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgc2hvcnRlciB0aGFuIHRhbGxlciwgdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycy5cblxuXHR2YXIgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZWxzLmxlbmd0aCk7IC8vIGZvciBub24tbGFzdCBlbGVtZW50XG5cdHZhciBtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGVscy5sZW5ndGggLSAxKSk7IC8vIGZvciBsYXN0IGVsZW1lbnQgKkZMT09SSU5HIE5PVEUqXG5cdHZhciBmbGV4RWxzID0gW107IC8vIGVsZW1lbnRzIHRoYXQgYXJlIGFsbG93ZWQgdG8gZXhwYW5kLiBhcnJheSBvZiBET00gbm9kZXNcblx0dmFyIGZsZXhPZmZzZXRzID0gW107IC8vIGFtb3VudCBvZiB2ZXJ0aWNhbCBzcGFjZSBpdCB0YWtlcyB1cFxuXHR2YXIgZmxleEhlaWdodHMgPSBbXTsgLy8gYWN0dWFsIGNzcyBoZWlnaHRcblx0dmFyIHVzZWRIZWlnaHQgPSAwO1xuXG5cdHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpOyAvLyBnaXZlIGFsbCBlbGVtZW50cyB0aGVpciBuYXR1cmFsIGhlaWdodFxuXG5cdC8vIGZpbmQgZWxlbWVudHMgdGhhdCBhcmUgYmVsb3cgdGhlIHJlY29tbWVuZGVkIGhlaWdodCAoZXhwYW5kYWJsZSkuXG5cdC8vIGltcG9ydGFudCB0byBxdWVyeSBmb3IgaGVpZ2h0cyBpbiBhIHNpbmdsZSBmaXJzdCBwYXNzICh0byBhdm9pZCByZWZsb3cgb3NjaWxsYXRpb24pLlxuXHRlbHMuZWFjaChmdW5jdGlvbihpLCBlbCkge1xuXHRcdHZhciBtaW5PZmZzZXQgPSBpID09PSBlbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xuXHRcdHZhciBuYXR1cmFsT2Zmc2V0ID0gJChlbCkub3V0ZXJIZWlnaHQodHJ1ZSk7XG5cblx0XHRpZiAobmF0dXJhbE9mZnNldCA8IG1pbk9mZnNldCkge1xuXHRcdFx0ZmxleEVscy5wdXNoKGVsKTtcblx0XHRcdGZsZXhPZmZzZXRzLnB1c2gobmF0dXJhbE9mZnNldCk7XG5cdFx0XHRmbGV4SGVpZ2h0cy5wdXNoKCQoZWwpLmhlaWdodCgpKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyB0aGlzIGVsZW1lbnQgc3RyZXRjaGVzIHBhc3QgcmVjb21tZW5kZWQgaGVpZ2h0IChub24tZXhwYW5kYWJsZSkuIG1hcmsgdGhlIHNwYWNlIGFzIG9jY3VwaWVkLlxuXHRcdFx0dXNlZEhlaWdodCArPSBuYXR1cmFsT2Zmc2V0O1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gcmVhZGp1c3QgdGhlIHJlY29tbWVuZGVkIGhlaWdodCB0byBvbmx5IGNvbnNpZGVyIHRoZSBoZWlnaHQgYXZhaWxhYmxlIHRvIG5vbi1tYXhlZC1vdXQgcm93cy5cblx0aWYgKHNob3VsZFJlZGlzdHJpYnV0ZSkge1xuXHRcdGF2YWlsYWJsZUhlaWdodCAtPSB1c2VkSGVpZ2h0O1xuXHRcdG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGZsZXhFbHMubGVuZ3RoKTtcblx0XHRtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGZsZXhFbHMubGVuZ3RoIC0gMSkpOyAvLyAqRkxPT1JJTkcgTk9URSpcblx0fVxuXG5cdC8vIGFzc2lnbiBoZWlnaHRzIHRvIGFsbCBleHBhbmRhYmxlIGVsZW1lbnRzXG5cdCQoZmxleEVscykuZWFjaChmdW5jdGlvbihpLCBlbCkge1xuXHRcdHZhciBtaW5PZmZzZXQgPSBpID09PSBmbGV4RWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcblx0XHR2YXIgbmF0dXJhbE9mZnNldCA9IGZsZXhPZmZzZXRzW2ldO1xuXHRcdHZhciBuYXR1cmFsSGVpZ2h0ID0gZmxleEhlaWdodHNbaV07XG5cdFx0dmFyIG5ld0hlaWdodCA9IG1pbk9mZnNldCAtIChuYXR1cmFsT2Zmc2V0IC0gbmF0dXJhbEhlaWdodCk7IC8vIHN1YnRyYWN0IHRoZSBtYXJnaW4vcGFkZGluZ1xuXG5cdFx0aWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHsgLy8gd2UgY2hlY2sgdGhpcyBhZ2FpbiBiZWNhdXNlIHJlZGlzdHJpYnV0aW9uIG1pZ2h0IGhhdmUgY2hhbmdlZCB0aGluZ3Ncblx0XHRcdCQoZWwpLmhlaWdodChuZXdIZWlnaHQpO1xuXHRcdH1cblx0fSk7XG59XG5cblxuLy8gVW5kb2VzIGRpc3RydWJ1dGVIZWlnaHQsIHJlc3RvcmluZyBhbGwgZWxzIHRvIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XG5mdW5jdGlvbiB1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKSB7XG5cdGVscy5oZWlnaHQoJycpO1xufVxuXG5cbi8vIEdpdmVuIGBlbHNgLCBhIGpRdWVyeSBzZXQgb2YgPHRkPiBjZWxscywgZmluZCB0aGUgY2VsbCB3aXRoIHRoZSBsYXJnZXN0IG5hdHVyYWwgd2lkdGggYW5kIHNldCB0aGUgd2lkdGhzIG9mIGFsbCB0aGVcbi8vIGNlbGxzIHRvIGJlIHRoYXQgd2lkdGguXG4vLyBQUkVSRVFVSVNJVEU6IGlmIHlvdSB3YW50IGEgY2VsbCB0byB0YWtlIHVwIHdpZHRoLCBpdCBuZWVkcyB0byBoYXZlIGEgc2luZ2xlIGlubmVyIGVsZW1lbnQgdy8gZGlzcGxheTppbmxpbmVcbmZ1bmN0aW9uIG1hdGNoQ2VsbFdpZHRocyhlbHMpIHtcblx0dmFyIG1heElubmVyV2lkdGggPSAwO1xuXG5cdGVscy5maW5kKCc+IHNwYW4nKS5lYWNoKGZ1bmN0aW9uKGksIGlubmVyRWwpIHtcblx0XHR2YXIgaW5uZXJXaWR0aCA9ICQoaW5uZXJFbCkub3V0ZXJXaWR0aCgpO1xuXHRcdGlmIChpbm5lcldpZHRoID4gbWF4SW5uZXJXaWR0aCkge1xuXHRcdFx0bWF4SW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG5cdFx0fVxuXHR9KTtcblxuXHRtYXhJbm5lcldpZHRoKys7IC8vIHNvbWV0aW1lcyBub3QgYWNjdXJhdGUgb2Ygd2lkdGggdGhlIHRleHQgbmVlZHMgdG8gc3RheSBvbiBvbmUgbGluZS4gaW5zdXJhbmNlXG5cblx0ZWxzLndpZHRoKG1heElubmVyV2lkdGgpO1xuXG5cdHJldHVybiBtYXhJbm5lcldpZHRoO1xufVxuXG5cbi8vIEdpdmVuIG9uZSBlbGVtZW50IHRoYXQgcmVzaWRlcyBpbnNpZGUgYW5vdGhlcixcbi8vIFN1YnRyYWN0cyB0aGUgaGVpZ2h0IG9mIHRoZSBpbm5lciBlbGVtZW50IGZyb20gdGhlIG91dGVyIGVsZW1lbnQuXG5mdW5jdGlvbiBzdWJ0cmFjdElubmVyRWxIZWlnaHQob3V0ZXJFbCwgaW5uZXJFbCkge1xuXHR2YXIgYm90aCA9IG91dGVyRWwuYWRkKGlubmVyRWwpO1xuXHR2YXIgZGlmZjtcblxuXHQvLyBlZmZpbicgSUU4LzkvMTAvMTEgc29tZXRpbWVzIHJldHVybnMgMCBmb3IgZGltZW5zaW9ucy4gdGhpcyB3ZWlyZCBoYWNrIHdhcyB0aGUgb25seSB0aGluZyB0aGF0IHdvcmtlZFxuXHRib3RoLmNzcyh7XG5cdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsIC8vIGNhdXNlIGEgcmVmbG93LCB3aGljaCB3aWxsIGZvcmNlIGZyZXNoIGRpbWVuc2lvbiByZWNhbGN1bGF0aW9uXG5cdFx0bGVmdDogLTEgLy8gZW5zdXJlIHJlZmxvdyBpbiBjYXNlIHRoZSBlbCB3YXMgYWxyZWFkeSByZWxhdGl2ZS4gbmVnYXRpdmUgaXMgbGVzcyBsaWtlbHkgdG8gY2F1c2UgbmV3IHNjcm9sbFxuXHR9KTtcblx0ZGlmZiA9IG91dGVyRWwub3V0ZXJIZWlnaHQoKSAtIGlubmVyRWwub3V0ZXJIZWlnaHQoKTsgLy8gZ3JhYiB0aGUgZGltZW5zaW9uc1xuXHRib3RoLmNzcyh7IHBvc2l0aW9uOiAnJywgbGVmdDogJycgfSk7IC8vIHVuZG8gaGFja1xuXG5cdHJldHVybiBkaWZmO1xufVxuXG5cbi8qIEVsZW1lbnQgR2VvbSBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5GQy5nZXRPdXRlclJlY3QgPSBnZXRPdXRlclJlY3Q7XG5GQy5nZXRDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdDtcbkZDLmdldENvbnRlbnRSZWN0ID0gZ2V0Q29udGVudFJlY3Q7XG5GQy5nZXRTY3JvbGxiYXJXaWR0aHMgPSBnZXRTY3JvbGxiYXJXaWR0aHM7XG5cblxuLy8gYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iLzEuMTEuMC91aS9jb3JlLmpzI0w1MVxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsKSB7XG5cdHZhciBwb3NpdGlvbiA9IGVsLmNzcygncG9zaXRpb24nKSxcblx0XHRzY3JvbGxQYXJlbnQgPSBlbC5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBhcmVudCA9ICQodGhpcyk7XG5cdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdChcblx0XHRcdFx0cGFyZW50LmNzcygnb3ZlcmZsb3cnKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXknKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXgnKVxuXHRcdFx0KTtcblx0XHR9KS5lcSgwKTtcblxuXHRyZXR1cm4gcG9zaXRpb24gPT09ICdmaXhlZCcgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggPyAkKGVsWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpIDogc2Nyb2xsUGFyZW50O1xufVxuXG5cbi8vIFF1ZXJpZXMgdGhlIG91dGVyIGJvdW5kaW5nIGFyZWEgb2YgYSBqUXVlcnkgZWxlbWVudC5cbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxuZnVuY3Rpb24gZ2V0T3V0ZXJSZWN0KGVsLCBvcmlnaW4pIHtcblx0dmFyIG9mZnNldCA9IGVsLm9mZnNldCgpO1xuXHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0IC0gKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XG5cdHZhciB0b3AgPSBvZmZzZXQudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcblxuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IGxlZnQsXG5cdFx0cmlnaHQ6IGxlZnQgKyBlbC5vdXRlcldpZHRoKCksXG5cdFx0dG9wOiB0b3AsXG5cdFx0Ym90dG9tOiB0b3AgKyBlbC5vdXRlckhlaWdodCgpXG5cdH07XG59XG5cblxuLy8gUXVlcmllcyB0aGUgYXJlYSB3aXRoaW4gdGhlIG1hcmdpbi9ib3JkZXIvc2Nyb2xsYmFycyBvZiBhIGpRdWVyeSBlbGVtZW50LiBEb2VzIG5vdCBnbyB3aXRoaW4gdGhlIHBhZGRpbmcuXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIG9yaWdpbikge1xuXHR2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7XG5cdHZhciBzY3JvbGxiYXJXaWR0aHMgPSBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpO1xuXHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcblx0dmFyIHRvcCA9IG9mZnNldC50b3AgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci10b3Atd2lkdGgnKSArIHNjcm9sbGJhcldpZHRocy50b3AgLSAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogbGVmdCxcblx0XHRyaWdodDogbGVmdCArIGVsWzBdLmNsaWVudFdpZHRoLCAvLyBjbGllbnRXaWR0aCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xuXHRcdHRvcDogdG9wLFxuXHRcdGJvdHRvbTogdG9wICsgZWxbMF0uY2xpZW50SGVpZ2h0IC8vIGNsaWVudEhlaWdodCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xuXHR9O1xufVxuXG5cbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3BhZGRpbmcgb2YgYSBqUXVlcnkgZWxlbWVudC4gQXNzdW1lZCBub3QgdG8gaGF2ZSBzY3JvbGxiYXJzLlxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdChlbCwgb3JpZ2luKSB7XG5cdHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTsgLy8ganVzdCBvdXRzaWRlIG9mIGJvcmRlciwgbWFyZ2luIG5vdCBpbmNsdWRlZFxuXHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLWxlZnQnKSAtXG5cdFx0KG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XG5cdHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBnZXRDc3NGbG9hdChlbCwgJ3BhZGRpbmctdG9wJykgLVxuXHRcdChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdHJpZ2h0OiBsZWZ0ICsgZWwud2lkdGgoKSxcblx0XHR0b3A6IHRvcCxcblx0XHRib3R0b206IHRvcCArIGVsLmhlaWdodCgpXG5cdH07XG59XG5cblxuLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgbGVmdC9yaWdodC90b3AvYm90dG9tIHNjcm9sbGJhciB3aWR0aHMgZm9yIHRoZSBnaXZlbiBqUXVlcnkgZWxlbWVudC5cbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cbmZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocyhlbCkge1xuXHR2YXIgbGVmdFJpZ2h0V2lkdGggPSBlbC5pbm5lcldpZHRoKCkgLSBlbFswXS5jbGllbnRXaWR0aDsgLy8gdGhlIHBhZGRpbmdzIGNhbmNlbCBvdXQsIGxlYXZpbmcgdGhlIHNjcm9sbGJhcnNcblx0dmFyIHdpZHRocyA9IHtcblx0XHRsZWZ0OiAwLFxuXHRcdHJpZ2h0OiAwLFxuXHRcdHRvcDogMCxcblx0XHRib3R0b206IGVsLmlubmVySGVpZ2h0KCkgLSBlbFswXS5jbGllbnRIZWlnaHQgLy8gdGhlIHBhZGRpbmdzIGNhbmNlbCBvdXQsIGxlYXZpbmcgdGhlIGJvdHRvbSBzY3JvbGxiYXJcblx0fTtcblxuXHRpZiAoZ2V0SXNMZWZ0UnRsU2Nyb2xsYmFycygpICYmIGVsLmNzcygnZGlyZWN0aW9uJykgPT0gJ3J0bCcpIHsgLy8gaXMgdGhlIHNjcm9sbGJhciBvbiB0aGUgbGVmdCBzaWRlP1xuXHRcdHdpZHRocy5sZWZ0ID0gbGVmdFJpZ2h0V2lkdGg7XG5cdH1cblx0ZWxzZSB7XG5cdFx0d2lkdGhzLnJpZ2h0ID0gbGVmdFJpZ2h0V2lkdGg7XG5cdH1cblxuXHRyZXR1cm4gd2lkdGhzO1xufVxuXG5cbi8vIExvZ2ljIGZvciBkZXRlcm1pbmluZyBpZiwgd2hlbiB0aGUgZWxlbWVudCBpcyByaWdodC10by1sZWZ0LCB0aGUgc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgc2lkZVxuXG52YXIgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkgeyAvLyByZXNwb25zaWJsZSBmb3IgY2FjaGluZyB0aGUgY29tcHV0YXRpb25cblx0aWYgKF9pc0xlZnRSdGxTY3JvbGxiYXJzID09PSBudWxsKSB7XG5cdFx0X2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBjb21wdXRlSXNMZWZ0UnRsU2Nyb2xsYmFycygpO1xuXHR9XG5cdHJldHVybiBfaXNMZWZ0UnRsU2Nyb2xsYmFycztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzTGVmdFJ0bFNjcm9sbGJhcnMoKSB7IC8vIGNyZWF0ZXMgYW4gb2Zmc2NyZWVuIHRlc3QgZWxlbWVudCwgdGhlbiByZW1vdmVzIGl0XG5cdHZhciBlbCA9ICQoJzxkaXY+PGRpdi8+PC9kaXY+Jylcblx0XHQuY3NzKHtcblx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0dG9wOiAtMTAwMCxcblx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRib3JkZXI6IDAsXG5cdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0b3ZlcmZsb3c6ICdzY3JvbGwnLFxuXHRcdFx0ZGlyZWN0aW9uOiAncnRsJ1xuXHRcdH0pXG5cdFx0LmFwcGVuZFRvKCdib2R5Jyk7XG5cdHZhciBpbm5lckVsID0gZWwuY2hpbGRyZW4oKTtcblx0dmFyIHJlcyA9IGlubmVyRWwub2Zmc2V0KCkubGVmdCA+IGVsLm9mZnNldCgpLmxlZnQ7IC8vIGlzIHRoZSBpbm5lciBkaXYgc2hpZnRlZCB0byBhY2NvbW1vZGF0ZSBhIGxlZnQgc2Nyb2xsYmFyP1xuXHRlbC5yZW1vdmUoKTtcblx0cmV0dXJuIHJlcztcbn1cblxuXG4vLyBSZXRyaWV2ZXMgYSBqUXVlcnkgZWxlbWVudCdzIGNvbXB1dGVkIENTUyB2YWx1ZSBhcyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbi8vIElmIHRoZSBxdWVyaWVkIHZhbHVlIGlzIG5vbi1udW1lcmljIChleDogSUUgY2FuIHJldHVybiBcIm1lZGl1bVwiIGZvciBib3JkZXIgd2lkdGgpLCB3aWxsIGp1c3QgcmV0dXJuIHplcm8uXG5mdW5jdGlvbiBnZXRDc3NGbG9hdChlbCwgcHJvcCkge1xuXHRyZXR1cm4gcGFyc2VGbG9hdChlbC5jc3MocHJvcCkpIHx8IDA7XG59XG5cblxuLyogTW91c2UgLyBUb3VjaCBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5GQy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuXG5cbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcblx0cmV0dXJuIGV2LndoaWNoID09IDEgJiYgIWV2LmN0cmxLZXk7XG59XG5cblxuZnVuY3Rpb24gZ2V0RXZYKGV2KSB7XG5cdGlmIChldi5wYWdlWCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGV2LnBhZ2VYO1xuXHR9XG5cdHZhciB0b3VjaGVzID0gZXYub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuXHRpZiAodG91Y2hlcykge1xuXHRcdHJldHVybiB0b3VjaGVzWzBdLnBhZ2VYO1xuXHR9XG59XG5cblxuZnVuY3Rpb24gZ2V0RXZZKGV2KSB7XG5cdGlmIChldi5wYWdlWSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGV2LnBhZ2VZO1xuXHR9XG5cdHZhciB0b3VjaGVzID0gZXYub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuXHRpZiAodG91Y2hlcykge1xuXHRcdHJldHVybiB0b3VjaGVzWzBdLnBhZ2VZO1xuXHR9XG59XG5cblxuZnVuY3Rpb24gZ2V0RXZJc1RvdWNoKGV2KSB7XG5cdHJldHVybiAvXnRvdWNoLy50ZXN0KGV2LnR5cGUpO1xufVxuXG5cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcblx0ZWwuYWRkQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpXG5cdFx0Lm9uKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cblxuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG5cdGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG5cblxuLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cbi8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjk1NDU2NS85NjM0MlxuLy8gcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy5cbmZ1bmN0aW9uIGJpbmRBbnlTY3JvbGwoaGFuZGxlcikge1xuXHRpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyB1bmRvZXMgYmluZEFueVNjcm9sbC4gbXVzdCBwYXNzIGluIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbi8vIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuXG5mdW5jdGlvbiB1bmJpbmRBbnlTY3JvbGwoaGFuZGxlcikge1xuXHRpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vKiBHZW5lcmFsIEdlb21ldHJ5IFV0aWxzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMuaW50ZXJzZWN0UmVjdHMgPSBpbnRlcnNlY3RSZWN0cztcblxuLy8gUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmVjdGFuZ2xlcy4gSWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgZmFsc2VcbmZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xuXHR2YXIgcmVzID0ge1xuXHRcdGxlZnQ6IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLFxuXHRcdHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuXHRcdHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuXHRcdGJvdHRvbTogTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pXG5cdH07XG5cblx0aWYgKHJlcy5sZWZ0IDwgcmVzLnJpZ2h0ICYmIHJlcy50b3AgPCByZXMuYm90dG9tKSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcblx0XHR0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSlcblx0fTtcbn1cblxuXG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG5cdFx0dG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG5cdH07XG59XG5cblxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG5cdHJldHVybiB7XG5cdFx0bGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcblx0XHR0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXG5cdH07XG59XG5cblxuLyogT2JqZWN0IE9yZGVyaW5nIGJ5IEZpZWxkXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xuRkMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IGNvbXBhcmVCeUZpZWxkU3BlY3M7XG5GQy5jb21wYXJlQnlGaWVsZFNwZWMgPSBjb21wYXJlQnlGaWVsZFNwZWM7XG5GQy5mbGV4aWJsZUNvbXBhcmUgPSBmbGV4aWJsZUNvbXBhcmU7XG5cblxuZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XG5cdHZhciBzcGVjcyA9IFtdO1xuXHR2YXIgdG9rZW5zID0gW107XG5cdHZhciBpLCB0b2tlbjtcblxuXHRpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHR0b2tlbnMgPSBbIGlucHV0IF07XG5cdH1cblx0ZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdHRva2VucyA9IGlucHV0O1xuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNwZWNzLnB1c2goXG5cdFx0XHRcdHRva2VuLmNoYXJBdCgwKSA9PSAnLScgP1xuXHRcdFx0XHRcdHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxuXHRcdFx0XHRcdHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3BlY3M7XG59XG5cblxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzKSB7XG5cdHZhciBpO1xuXHR2YXIgY21wO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajEsIG9iajIsIGZpZWxkU3BlY3NbaV0pO1xuXHRcdGlmIChjbXApIHtcblx0XHRcdHJldHVybiBjbXA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIDA7XG59XG5cblxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajEsIG9iajIsIGZpZWxkU3BlYykge1xuXHRpZiAoZmllbGRTcGVjLmZ1bmMpIHtcblx0XHRyZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMSwgb2JqMik7XG5cdH1cblx0cmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmoxW2ZpZWxkU3BlYy5maWVsZF0sIG9iajJbZmllbGRTcGVjLmZpZWxkXSkgKlxuXHRcdChmaWVsZFNwZWMub3JkZXIgfHwgMSk7XG59XG5cblxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcblx0aWYgKCFhICYmICFiKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblx0aWYgKGIgPT0gbnVsbCkge1xuXHRcdHJldHVybiAtMTtcblx0fVxuXHRpZiAoYSA9PSBudWxsKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblx0aWYgKCQudHlwZShhKSA9PT0gJ3N0cmluZycgfHwgJC50eXBlKGIpID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xuXHR9XG5cdHJldHVybiBhIC0gYjtcbn1cblxuXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgTWlzYyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbi8vIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXMuIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIGludGVyc2VjdGlvbi5cbi8vIEV4cGVjdHMgYWxsIGRhdGVzIHRvIGJlIG5vcm1hbGl6ZWQgdG8gdGhlIHNhbWUgdGltZXpvbmUgYmVmb3JlaGFuZC5cbi8vIFRPRE86IG1vdmUgdG8gZGF0ZSBzZWN0aW9uP1xuZnVuY3Rpb24gaW50ZXJzZWN0UmFuZ2VzKHN1YmplY3RSYW5nZSwgY29uc3RyYWludFJhbmdlKSB7XG5cdHZhciBzdWJqZWN0U3RhcnQgPSBzdWJqZWN0UmFuZ2Uuc3RhcnQ7XG5cdHZhciBzdWJqZWN0RW5kID0gc3ViamVjdFJhbmdlLmVuZDtcblx0dmFyIGNvbnN0cmFpbnRTdGFydCA9IGNvbnN0cmFpbnRSYW5nZS5zdGFydDtcblx0dmFyIGNvbnN0cmFpbnRFbmQgPSBjb25zdHJhaW50UmFuZ2UuZW5kO1xuXHR2YXIgc2VnU3RhcnQsIHNlZ0VuZDtcblx0dmFyIGlzU3RhcnQsIGlzRW5kO1xuXG5cdGlmIChzdWJqZWN0RW5kID4gY29uc3RyYWludFN0YXJ0ICYmIHN1YmplY3RTdGFydCA8IGNvbnN0cmFpbnRFbmQpIHsgLy8gaW4gYm91bmRzIGF0IGFsbD9cblxuXHRcdGlmIChzdWJqZWN0U3RhcnQgPj0gY29uc3RyYWludFN0YXJ0KSB7XG5cdFx0XHRzZWdTdGFydCA9IHN1YmplY3RTdGFydC5jbG9uZSgpO1xuXHRcdFx0aXNTdGFydCA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2VnU3RhcnQgPSBjb25zdHJhaW50U3RhcnQuY2xvbmUoKTtcblx0XHRcdGlzU3RhcnQgPSAgZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHN1YmplY3RFbmQgPD0gY29uc3RyYWludEVuZCkge1xuXHRcdFx0c2VnRW5kID0gc3ViamVjdEVuZC5jbG9uZSgpO1xuXHRcdFx0aXNFbmQgPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNlZ0VuZCA9IGNvbnN0cmFpbnRFbmQuY2xvbmUoKTtcblx0XHRcdGlzRW5kID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBzZWdTdGFydCxcblx0XHRcdGVuZDogc2VnRW5kLFxuXHRcdFx0aXNTdGFydDogaXNTdGFydCxcblx0XHRcdGlzRW5kOiBpc0VuZFxuXHRcdH07XG5cdH1cbn1cblxuXG4vKiBEYXRlIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLmNvbXB1dGVJbnRlcnZhbFVuaXQgPSBjb21wdXRlSW50ZXJ2YWxVbml0O1xuRkMuZGl2aWRlUmFuZ2VCeUR1cmF0aW9uID0gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uO1xuRkMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uO1xuRkMubXVsdGlwbHlEdXJhdGlvbiA9IG11bHRpcGx5RHVyYXRpb247XG5GQy5kdXJhdGlvbkhhc1RpbWUgPSBkdXJhdGlvbkhhc1RpbWU7XG5cbnZhciBkYXlJRHMgPSBbICdzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnIF07XG52YXIgaW50ZXJ2YWxVbml0cyA9IFsgJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJyBdO1xuXG5cbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyBpbnRvIGEgRHVyYXRpb24gd2hlcmUgZnVsbC1kYXlzIGFyZSByZWNvcmRlZCBmaXJzdCwgdGhlbiB0aGUgcmVtYWluaW5nIHRpbWUuXG4vLyBNb21lbnRzIHdpbGwgaGF2ZSB0aGVpciB0aW1lem9uZXMgbm9ybWFsaXplZC5cbmZ1bmN0aW9uIGRpZmZEYXlUaW1lKGEsIGIpIHtcblx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XG5cdFx0ZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpLFxuXHRcdG1zOiBhLnRpbWUoKSAtIGIudGltZSgpIC8vIHRpbWUtb2YtZGF5IGZyb20gZGF5IHN0YXJ0LiBkaXNyZWdhcmRzIHRpbWV6b25lXG5cdH0pO1xufVxuXG5cbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyB2aWEgdGhlaXIgc3RhcnQtb2YtZGF5IChyZWdhcmRsZXNzIG9mIHRpbWV6b25lKS4gUHJvZHVjZXMgd2hvbGUtZGF5IGR1cmF0aW9ucy5cbmZ1bmN0aW9uIGRpZmZEYXkoYSwgYikge1xuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcblx0XHRkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJylcblx0fSk7XG59XG5cblxuLy8gRGlmZnMgdHdvIG1vbWVudHMsIHByb2R1Y2luZyBhIGR1cmF0aW9uLCBtYWRlIG9mIGEgd2hvbGUtdW5pdC1pbmNyZW1lbnQgb2YgdGhlIGdpdmVuIHVuaXQuIFVzZXMgcm91bmRpbmcuXG5mdW5jdGlvbiBkaWZmQnlVbml0KGEsIGIsIHVuaXQpIHtcblx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihcblx0XHRNYXRoLnJvdW5kKGEuZGlmZihiLCB1bml0LCB0cnVlKSksIC8vIHJldHVybkZsb2F0PXRydWVcblx0XHR1bml0XG5cdCk7XG59XG5cblxuLy8gQ29tcHV0ZXMgdGhlIHVuaXQgbmFtZSBvZiB0aGUgbGFyZ2VzdCB3aG9sZS11bml0IHBlcmlvZCBvZiB0aW1lLlxuLy8gRm9yIGV4YW1wbGUsIDQ4IGhvdXJzIHdpbGwgYmUgXCJkYXlzXCIgd2hlcmVhcyA0OSBob3VycyB3aWxsIGJlIFwiaG91cnNcIi5cbi8vIEFjY2VwdHMgc3RhcnQvZW5kLCBhIHJhbmdlIG9iamVjdCwgb3IgYW4gb3JpZ2luYWwgZHVyYXRpb24gb2JqZWN0LlxuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsVW5pdChzdGFydCwgZW5kKSB7XG5cdHZhciBpLCB1bml0O1xuXHR2YXIgdmFsO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBpbnRlcnZhbFVuaXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dW5pdCA9IGludGVydmFsVW5pdHNbaV07XG5cdFx0dmFsID0gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCk7XG5cblx0XHRpZiAodmFsID49IDEgJiYgaXNJbnQodmFsKSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHVuaXQ7IC8vIHdpbGwgYmUgXCJtaWxsaXNlY29uZHNcIiBpZiBub3RoaW5nIGVsc2UgbWF0Y2hlc1xufVxuXG5cbi8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgdW5pdHMgKGxpa2UgXCJob3Vyc1wiKSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4vLyBSYW5nZSBjYW4gYmUgYSB7c3RhcnQsZW5kfSBvYmplY3QsIHNlcGFyYXRlIHN0YXJ0L2VuZCBhcmdzLCBvciBhIER1cmF0aW9uLlxuLy8gUmVzdWx0cyBhcmUgYmFzZWQgb24gTW9tZW50J3MgLmFzKCkgYW5kIC5kaWZmKCkgbWV0aG9kcywgc28gcmVzdWx0cyBjYW4gZGVwZW5kIG9uIGludGVybmFsIGhhbmRsaW5nXG4vLyBvZiBtb250aC1kaWZmaW5nIGxvZ2ljICh3aGljaCB0ZW5kcyB0byB2YXJ5IGZyb20gdmVyc2lvbiB0byB2ZXJzaW9uKS5cbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZUFzKHVuaXQsIHN0YXJ0LCBlbmQpIHtcblxuXHRpZiAoZW5kICE9IG51bGwpIHsgLy8gZ2l2ZW4gc3RhcnQsIGVuZFxuXHRcdHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCwgdHJ1ZSk7XG5cdH1cblx0ZWxzZSBpZiAobW9tZW50LmlzRHVyYXRpb24oc3RhcnQpKSB7IC8vIGdpdmVuIGR1cmF0aW9uXG5cdFx0cmV0dXJuIHN0YXJ0LmFzKHVuaXQpO1xuXHR9XG5cdGVsc2UgeyAvLyBnaXZlbiB7IHN0YXJ0LCBlbmQgfSByYW5nZSBvYmplY3Rcblx0XHRyZXR1cm4gc3RhcnQuZW5kLmRpZmYoc3RhcnQuc3RhcnQsIHVuaXQsIHRydWUpO1xuXHR9XG59XG5cblxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIGEgcmFuZ2UgKHNwZWNpZmllZCBieSBhIHN0YXJ0L2VuZCBwYXJhbXMpIGJ5IGEgZHVyYXRpb25cbmZ1bmN0aW9uIGRpdmlkZVJhbmdlQnlEdXJhdGlvbihzdGFydCwgZW5kLCBkdXIpIHtcblx0dmFyIG1vbnRocztcblxuXHRpZiAoZHVyYXRpb25IYXNUaW1lKGR1cikpIHtcblx0XHRyZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cjtcblx0fVxuXHRtb250aHMgPSBkdXIuYXNNb250aHMoKTtcblx0aWYgKE1hdGguYWJzKG1vbnRocykgPj0gMSAmJiBpc0ludChtb250aHMpKSB7XG5cdFx0cmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnbW9udGhzJywgdHJ1ZSkgLyBtb250aHM7XG5cdH1cblx0cmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnZGF5cycsIHRydWUpIC8gZHVyLmFzRGF5cygpO1xufVxuXG5cbi8vIEludGVsbGlnZW50bHkgZGl2aWRlcyBvbmUgZHVyYXRpb24gYnkgYW5vdGhlclxuZnVuY3Rpb24gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKGR1cjEsIGR1cjIpIHtcblx0dmFyIG1vbnRoczEsIG1vbnRoczI7XG5cblx0aWYgKGR1cmF0aW9uSGFzVGltZShkdXIxKSB8fCBkdXJhdGlvbkhhc1RpbWUoZHVyMikpIHtcblx0XHRyZXR1cm4gZHVyMSAvIGR1cjI7XG5cdH1cblx0bW9udGhzMSA9IGR1cjEuYXNNb250aHMoKTtcblx0bW9udGhzMiA9IGR1cjIuYXNNb250aHMoKTtcblx0aWYgKFxuXHRcdE1hdGguYWJzKG1vbnRoczEpID49IDEgJiYgaXNJbnQobW9udGhzMSkgJiZcblx0XHRNYXRoLmFicyhtb250aHMyKSA+PSAxICYmIGlzSW50KG1vbnRoczIpXG5cdCkge1xuXHRcdHJldHVybiBtb250aHMxIC8gbW9udGhzMjtcblx0fVxuXHRyZXR1cm4gZHVyMS5hc0RheXMoKSAvIGR1cjIuYXNEYXlzKCk7XG59XG5cblxuLy8gSW50ZWxsaWdlbnRseSBtdWx0aXBsaWVzIGEgZHVyYXRpb24gYnkgYSBudW1iZXJcbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZHVyLCBuKSB7XG5cdHZhciBtb250aHM7XG5cblx0aWYgKGR1cmF0aW9uSGFzVGltZShkdXIpKSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihkdXIgKiBuKTtcblx0fVxuXHRtb250aHMgPSBkdXIuYXNNb250aHMoKTtcblx0aWYgKE1hdGguYWJzKG1vbnRocykgPj0gMSAmJiBpc0ludChtb250aHMpKSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IG1vbnRoczogbW9udGhzICogbiB9KTtcblx0fVxuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogZHVyLmFzRGF5cygpICogbiB9KTtcbn1cblxuXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBkdXJhdGlvbiBoYXMgYW55IHRpbWUgcGFydHMgKGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcylcbmZ1bmN0aW9uIGR1cmF0aW9uSGFzVGltZShkdXIpIHtcblx0cmV0dXJuIEJvb2xlYW4oZHVyLmhvdXJzKCkgfHwgZHVyLm1pbnV0ZXMoKSB8fCBkdXIuc2Vjb25kcygpIHx8IGR1ci5taWxsaXNlY29uZHMoKSk7XG59XG5cblxuZnVuY3Rpb24gaXNOYXRpdmVEYXRlKGlucHV0KSB7XG5cdHJldHVybiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nIHx8IGlucHV0IGluc3RhbmNlb2YgRGF0ZTtcbn1cblxuXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBpbnB1dCBpcyBhIHRpbWUgc3RyaW5nLCBsaWtlIFwiMDY6NDA6MDBcIiBvciBcIjA2OjAwXCJcbmZ1bmN0aW9uIGlzVGltZVN0cmluZyhzdHIpIHtcblx0cmV0dXJuIC9eXFxkK1xcOlxcZCsoPzpcXDpcXGQrXFwuPyg/OlxcZHszfSk/KT8kLy50ZXN0KHN0cik7XG59XG5cblxuLyogTG9nZ2luZyBhbmQgRGVidWdcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5GQy5sb2cgPSBmdW5jdGlvbigpIHtcblx0dmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcblxuXHRpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuXHRcdHJldHVybiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuXHR9XG59O1xuXG5GQy53YXJuID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cblx0aWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG5cdFx0cmV0dXJuIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHJldHVybiBGQy5sb2cuYXBwbHkoRkMsIGFyZ3VtZW50cyk7XG5cdH1cbn07XG5cblxuLyogR2VuZXJhbCBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgaGFzT3duUHJvcE1ldGhvZCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHMpIHtcblx0dmFyIGRlc3QgPSB7fTtcblx0dmFyIGksIG5hbWU7XG5cdHZhciBjb21wbGV4T2Jqcztcblx0dmFyIGosIHZhbDtcblx0dmFyIHByb3BzO1xuXG5cdGlmIChjb21wbGV4UHJvcHMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgY29tcGxleFByb3BzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRuYW1lID0gY29tcGxleFByb3BzW2ldO1xuXHRcdFx0Y29tcGxleE9ianMgPSBbXTtcblxuXHRcdFx0Ly8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuXHRcdFx0Zm9yIChqID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0dmFsID0gcHJvcE9ianNbal1bbmFtZV07XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0Y29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGVzdFtuYW1lXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSB0cmFpbGluZyB2YWx1ZXMgd2VyZSBvYmplY3RzLCB1c2UgdGhlIG1lcmdlZCB2YWx1ZVxuXHRcdFx0aWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xuXHRcdFx0XHRkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuXHRmb3IgKGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdHByb3BzID0gcHJvcE9ianNbaV07XG5cblx0XHRmb3IgKG5hbWUgaW4gcHJvcHMpIHtcblx0XHRcdGlmICghKG5hbWUgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxuXHRcdFx0XHRkZXN0W25hbWVdID0gcHJvcHNbbmFtZV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRlc3Q7XG59XG5cblxuLy8gQ3JlYXRlIGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgZ2l2ZW4gcHJvdG90eXBlLiBKdXN0IGxpa2UgT2JqZWN0LmNyZWF0ZVxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0KHByb3RvKSB7XG5cdHZhciBmID0gZnVuY3Rpb24oKSB7fTtcblx0Zi5wcm90b3R5cGUgPSBwcm90bztcblx0cmV0dXJuIG5ldyBmKCk7XG59XG5cblxuZnVuY3Rpb24gY29weU93blByb3BzKHNyYywgZGVzdCkge1xuXHRmb3IgKHZhciBuYW1lIGluIHNyYykge1xuXHRcdGlmIChoYXNPd25Qcm9wKHNyYywgbmFtZSkpIHtcblx0XHRcdGRlc3RbbmFtZV0gPSBzcmNbbmFtZV07XG5cdFx0fVxuXHR9XG59XG5cblxuLy8gQ29waWVzIG92ZXIgY2VydGFpbiBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZXMgYXMgT2JqZWN0LnByb3RvdHlwZSBtZXRob2RzLiBPdmVyY29tZXMgYW4gSUU8PTggYnVnOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9FQ01BU2NyaXB0X0RvbnRFbnVtX2F0dHJpYnV0ZSNKU2NyaXB0X0RvbnRFbnVtX0J1Z1xuZnVuY3Rpb24gY29weU5hdGl2ZU1ldGhvZHMoc3JjLCBkZXN0KSB7XG5cdHZhciBuYW1lcyA9IFsgJ2NvbnN0cnVjdG9yJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnIF07XG5cdHZhciBpLCBuYW1lO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdG5hbWUgPSBuYW1lc1tpXTtcblxuXHRcdGlmIChzcmNbbmFtZV0gIT09IE9iamVjdC5wcm90b3R5cGVbbmFtZV0pIHtcblx0XHRcdGRlc3RbbmFtZV0gPSBzcmNbbmFtZV07XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIG5hbWUpIHtcblx0cmV0dXJuIGhhc093blByb3BNZXRob2QuY2FsbChvYmosIG5hbWUpO1xufVxuXG5cbi8vIElzIHRoZSBnaXZlbiB2YWx1ZSBhIG5vbi1vYmplY3Qgbm9uLWZ1bmN0aW9uIHZhbHVlP1xuZnVuY3Rpb24gaXNBdG9taWModmFsKSB7XG5cdHJldHVybiAvdW5kZWZpbmVkfG51bGx8Ym9vbGVhbnxudW1iZXJ8c3RyaW5nLy50ZXN0KCQudHlwZSh2YWwpKTtcbn1cblxuXG5mdW5jdGlvbiBhcHBseUFsbChmdW5jdGlvbnMsIHRoaXNPYmosIGFyZ3MpIHtcblx0aWYgKCQuaXNGdW5jdGlvbihmdW5jdGlvbnMpKSB7XG5cdFx0ZnVuY3Rpb25zID0gWyBmdW5jdGlvbnMgXTtcblx0fVxuXHRpZiAoZnVuY3Rpb25zKSB7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHJldDtcblx0XHRmb3IgKGk9MDsgaTxmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJldCA9IGZ1bmN0aW9uc1tpXS5hcHBseSh0aGlzT2JqLCBhcmdzKSB8fCByZXQ7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBmaXJzdERlZmluZWQoKSB7XG5cdGZvciAodmFyIGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHNbaV07XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gaHRtbEVzY2FwZShzKSB7XG5cdHJldHVybiAocyArICcnKS5yZXBsYWNlKC8mL2csICcmYW1wOycpXG5cdFx0LnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuXHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHQucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jylcblx0XHQucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG5cdFx0LnJlcGxhY2UoL1xcbi9nLCAnPGJyIC8+Jyk7XG59XG5cblxuZnVuY3Rpb24gc3RyaXBIdG1sRW50aXRpZXModGV4dCkge1xuXHRyZXR1cm4gdGV4dC5yZXBsYWNlKC8mLio/Oy9nLCAnJyk7XG59XG5cblxuLy8gR2l2ZW4gYSBoYXNoIG9mIENTUyBwcm9wZXJ0aWVzLCByZXR1cm5zIGEgc3RyaW5nIG9mIENTUy5cbi8vIFVzZXMgcHJvcGVydHkgbmFtZXMgYXMtaXMgKG5vIGNhbWVsLWNhc2UgY29udmVyc2lvbikuIFdpbGwgbm90IG1ha2Ugc3RhdGVtZW50cyBmb3IgbnVsbC91bmRlZmluZWQgdmFsdWVzLlxuZnVuY3Rpb24gY3NzVG9TdHIoY3NzUHJvcHMpIHtcblx0dmFyIHN0YXRlbWVudHMgPSBbXTtcblxuXHQkLmVhY2goY3NzUHJvcHMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuXHRcdGlmICh2YWwgIT0gbnVsbCkge1xuXHRcdFx0c3RhdGVtZW50cy5wdXNoKG5hbWUgKyAnOicgKyB2YWwpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHN0YXRlbWVudHMuam9pbignOycpO1xufVxuXG5cbmZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcblx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7IC8vIGZvciAuc29ydCgpXG5cdHJldHVybiBhIC0gYjtcbn1cblxuXG5mdW5jdGlvbiBpc0ludChuKSB7XG5cdHJldHVybiBuICUgMSA9PT0gMDtcbn1cblxuXG4vLyBSZXR1cm5zIGEgbWV0aG9kIGJvdW5kIHRvIHRoZSBnaXZlbiBvYmplY3QgY29udGV4dC5cbi8vIEp1c3QgbGlrZSBvbmUgb2YgdGhlIGpRdWVyeS5wcm94eSBzaWduYXR1cmVzLCBidXQgd2l0aG91dCB0aGUgdW5kZXNpcmVkIGJlaGF2aW9yIG9mIHRyZWF0aW5nIHRoZSBzYW1lIG1ldGhvZCB3aXRoXG4vLyBkaWZmZXJlbnQgY29udGV4dHMgYXMgaWRlbnRpY2FsIHdoZW4gYmluZGluZy91bmJpbmRpbmcgZXZlbnRzLlxuZnVuY3Rpb24gcHJveHkob2JqLCBtZXRob2ROYW1lKSB7XG5cdHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuXHR9O1xufVxuXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG5cdHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuXHR2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpIC0gdGltZXN0YW1wO1xuXHRcdGlmIChsYXN0IDwgd2FpdCkge1xuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdFx0XHRcdGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGNvbnRleHQgPSB0aGlzO1xuXHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0dGltZXN0YW1wID0gK25ldyBEYXRlKCk7XG5cdFx0dmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cdFx0aWYgKCF0aW1lb3V0KSB7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsTm93KSB7XG5cdFx0XHRyZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdFx0Y29udGV4dCA9IGFyZ3MgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufVxuXG5cbi8vIEhBQ0sgYXJvdW5kIGpRdWVyeSdzIG5vdyBBKyBwcm9taXNlczogZXhlY3V0ZSBjYWxsYmFjayBzeW5jaHJvbm91c2x5IGlmIGFscmVhZHkgcmVzb2x2ZWQuXG4vLyB0aGVuRnVuYyBzaG91bGRuJ3QgYWNjZXB0IGFyZ3MuXG4vLyBzaW1pbGFyIHRvIHdoZW5SZXNvdXJjZXMgaW4gU2NoZWR1bGVyIHBsdWdpbi5cbmZ1bmN0aW9uIHN5bmNUaGVuKHByb21pc2UsIHRoZW5GdW5jKSB7XG5cdC8vIG5vdCBhIHByb21pc2UsIG9yIGFuIGFscmVhZHktcmVzb2x2ZWQgcHJvbWlzZT9cblx0aWYgKCFwcm9taXNlIHx8ICFwcm9taXNlLnRoZW4gfHwgcHJvbWlzZS5zdGF0ZSgpID09PSAncmVzb2x2ZWQnKSB7XG5cdFx0cmV0dXJuICQud2hlbih0aGVuRnVuYygpKTsgLy8gcmVzb2x2ZSBpbW1lZGlhdGVseVxuXHR9XG5cdGVsc2UgaWYgKHRoZW5GdW5jKSB7XG5cdFx0cmV0dXJuIHByb21pc2UudGhlbih0aGVuRnVuYyk7XG5cdH1cbn1cblxuOztcblxudmFyIGFtYmlnRGF0ZU9mTW9udGhSZWdleCA9IC9eXFxzKlxcZHs0fS1cXGRcXGQkLztcbnZhciBhbWJpZ1RpbWVPclpvbmVSZWdleCA9XG5cdC9eXFxzKlxcZHs0fS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyk/JC87XG52YXIgbmV3TW9tZW50UHJvdG8gPSBtb21lbnQuZm47IC8vIHdoZXJlIHdlIHdpbGwgYXR0YWNoIG91ciBuZXcgbWV0aG9kc1xudmFyIG9sZE1vbWVudFByb3RvID0gJC5leHRlbmQoe30sIG5ld01vbWVudFByb3RvKTsgLy8gY29weSBvZiBvcmlnaW5hbCBtb21lbnQgbWV0aG9kc1xudmFyIGFsbG93VmFsdWVPcHRpbWl6YXRpb247XG52YXIgc2V0VVRDVmFsdWVzOyAvLyBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XG52YXIgc2V0TG9jYWxWYWx1ZXM7IC8vIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblxuXG4vLyBDcmVhdGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDcmVhdGVzIGEgbmV3IG1vbWVudCwgc2ltaWxhciB0byB0aGUgdmFuaWxsYSBtb21lbnQoLi4uKSBjb25zdHJ1Y3RvciwgYnV0IHdpdGhcbi8vIGV4dHJhIGZlYXR1cmVzIChhbWJpZ3VvdXMgdGltZSwgZW5oYW5jZWQgZm9ybWF0dGluZykuIFdoZW4gZ2l2ZW4gYW4gZXhpc3RpbmcgbW9tZW50LFxuLy8gaXQgd2lsbCBmdW5jdGlvbiBhcyBhIGNsb25lIChhbmQgcmV0YWluIHRoZSB6b25lIG9mIHRoZSBtb21lbnQpLiBBbnl0aGluZyBlbHNlIHdpbGxcbi8vIHJlc3VsdCBpbiBhIG1vbWVudCBpbiB0aGUgbG9jYWwgem9uZS5cbkZDLm1vbWVudCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMpO1xufTtcblxuLy8gU2FtZXMgYXMgRkMubW9tZW50LCBidXQgZm9yY2VzIHRoZSByZXN1bHRpbmcgbW9tZW50IHRvIGJlIGluIHRoZSBVVEMgdGltZXpvbmUuXG5GQy5tb21lbnQudXRjID0gZnVuY3Rpb24oKSB7XG5cdHZhciBtb20gPSBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSk7XG5cblx0Ly8gRm9yY2UgaXQgaW50byBVVEMgYmVjYXVzZSBtYWtlTW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0XG5cdC8vIChpZiBnaXZlbiBhIHByZS1leGlzdGluZyBtb21lbnQgZm9yIGV4YW1wbGUpXG5cdGlmIChtb20uaGFzVGltZSgpKSB7IC8vIGRvbid0IGdpdmUgYW1iaWd1b3VzbHktdGltZWQgbW9tZW50cyBhIFVUQyB6b25lXG5cdFx0bW9tLnV0YygpO1xuXHR9XG5cblx0cmV0dXJuIG1vbTtcbn07XG5cbi8vIFNhbWUgYXMgRkMubW9tZW50LCBidXQgd2hlbiBnaXZlbiBhbiBJU084NjAxIHN0cmluZywgdGhlIHRpbWV6b25lIG9mZnNldCBpcyBwcmVzZXJ2ZWQuXG4vLyBJU084NjAxIHN0cmluZ3Mgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgd2lsbCBiZWNvbWUgYW1iaWd1b3VzbHkgem9uZWQuXG5GQy5tb21lbnQucGFyc2Vab25lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSk7XG59O1xuXG4vLyBCdWlsZHMgYW4gZW5oYW5jZWQgbW9tZW50IGZyb20gYXJncy4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsIGl0IGNsb25lcy4gV2hlbiBnaXZlbiBhXG4vLyBuYXRpdmUgRGF0ZSwgb3IgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzICh0aGUgY3VycmVudCB0aW1lKSwgdGhlIHJlc3VsdGluZyBtb21lbnQgd2lsbCBiZSBsb2NhbC5cbi8vIEFueXRoaW5nIGVsc2UgbmVlZHMgdG8gYmUgXCJwYXJzZWRcIiAoYSBzdHJpbmcgb3IgYW4gYXJyYXkpLCBhbmQgd2lsbCBiZSBhZmZlY3RlZCBieTpcbi8vICAgIHBhcnNlQXNVVEMgLSBpZiB0aGVyZSBpcyBubyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgcGFyc2UgdGhlIGlucHV0IGluIFVUQz9cbi8vICAgIHBhcnNlWm9uZSAtIGlmIHRoZXJlIGlzIHpvbmUgaW5mb3JtYXRpb24sIHNob3VsZCB3ZSBmb3JjZSB0aGUgem9uZSBvZiB0aGUgbW9tZW50P1xuZnVuY3Rpb24gbWFrZU1vbWVudChhcmdzLCBwYXJzZUFzVVRDLCBwYXJzZVpvbmUpIHtcblx0dmFyIGlucHV0ID0gYXJnc1swXTtcblx0dmFyIGlzU2luZ2xlU3RyaW5nID0gYXJncy5sZW5ndGggPT0gMSAmJiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xuXHR2YXIgaXNBbWJpZ1RpbWU7XG5cdHZhciBpc0FtYmlnWm9uZTtcblx0dmFyIGFtYmlnTWF0Y2g7XG5cdHZhciBtb207XG5cblx0aWYgKG1vbWVudC5pc01vbWVudChpbnB1dCkpIHtcblx0XHRtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7IC8vIGNsb25lIGl0XG5cdFx0dHJhbnNmZXJBbWJpZ3MoaW5wdXQsIG1vbSk7IC8vIHRoZSBhbWJpZyBmbGFncyB3ZXJlbid0IHRyYW5zZmVyZWQgd2l0aCB0aGUgY2xvbmVcblx0fVxuXHRlbHNlIGlmIChpc05hdGl2ZURhdGUoaW5wdXQpIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcblx0XHRtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7IC8vIHdpbGwgYmUgbG9jYWxcblx0fVxuXHRlbHNlIHsgLy8gXCJwYXJzaW5nXCIgaXMgcmVxdWlyZWRcblx0XHRpc0FtYmlnVGltZSA9IGZhbHNlO1xuXHRcdGlzQW1iaWdab25lID0gZmFsc2U7XG5cblx0XHRpZiAoaXNTaW5nbGVTdHJpbmcpIHtcblx0XHRcdGlmIChhbWJpZ0RhdGVPZk1vbnRoUmVnZXgudGVzdChpbnB1dCkpIHtcblx0XHRcdFx0Ly8gYWNjZXB0IHN0cmluZ3MgbGlrZSAnMjAxNC0wNScsIGJ1dCBjb252ZXJ0IHRvIHRoZSBmaXJzdCBvZiB0aGUgbW9udGhcblx0XHRcdFx0aW5wdXQgKz0gJy0wMSc7XG5cdFx0XHRcdGFyZ3MgPSBbIGlucHV0IF07IC8vIGZvciB3aGVuIHdlIHBhc3MgaXQgb24gdG8gbW9tZW50J3MgY29uc3RydWN0b3Jcblx0XHRcdFx0aXNBbWJpZ1RpbWUgPSB0cnVlO1xuXHRcdFx0XHRpc0FtYmlnWm9uZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoYW1iaWdNYXRjaCA9IGFtYmlnVGltZU9yWm9uZVJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuXHRcdFx0XHRpc0FtYmlnVGltZSA9ICFhbWJpZ01hdGNoWzVdOyAvLyBubyB0aW1lIHBhcnQ/XG5cdFx0XHRcdGlzQW1iaWdab25lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdFx0Ly8gYXJyYXlzIGhhdmUgbm8gdGltZXpvbmUgaW5mb3JtYXRpb24sIHNvIGFzc3VtZSBhbWJpZ3VvdXMgem9uZVxuXHRcdFx0aXNBbWJpZ1pvbmUgPSB0cnVlO1xuXHRcdH1cblx0XHQvLyBvdGhlcndpc2UsIHByb2JhYmx5IGEgc3RyaW5nIHdpdGggYSBmb3JtYXRcblxuXHRcdGlmIChwYXJzZUFzVVRDIHx8IGlzQW1iaWdUaW1lKSB7XG5cdFx0XHRtb20gPSBtb21lbnQudXRjLmFwcGx5KG1vbWVudCwgYXJncyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bW9tID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGlmIChpc0FtYmlnVGltZSkge1xuXHRcdFx0bW9tLl9hbWJpZ1RpbWUgPSB0cnVlO1xuXHRcdFx0bW9tLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBhbWJpZ3VvdXMgdGltZSBhbHdheXMgbWVhbnMgYW1iaWd1b3VzIHpvbmVcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGFyc2Vab25lKSB7IC8vIGxldCdzIHJlY29yZCB0aGUgaW5wdXR0ZWQgem9uZSBzb21laG93XG5cdFx0XHRpZiAoaXNBbWJpZ1pvbmUpIHtcblx0XHRcdFx0bW9tLl9hbWJpZ1pvbmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXNTaW5nbGVTdHJpbmcpIHtcblx0XHRcdFx0aWYgKG1vbS51dGNPZmZzZXQpIHtcblx0XHRcdFx0XHRtb20udXRjT2Zmc2V0KGlucHV0KTsgLy8gaWYgbm90IGEgdmFsaWQgem9uZSwgd2lsbCBhc3NpZ24gVVRDXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bW9tLnpvbmUoaW5wdXQpOyAvLyBmb3IgbW9tZW50LXByZS0yLjlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdG1vbS5fZnVsbENhbGVuZGFyID0gdHJ1ZTsgLy8gZmxhZyBmb3IgZXh0ZW5kZWQgZnVuY3Rpb25hbGl0eVxuXG5cdHJldHVybiBtb207XG59XG5cblxuLy8gQSBjbG9uZSBtZXRob2QgdGhhdCB3b3JrcyB3aXRoIHRoZSBmbGFncyByZWxhdGVkIHRvIG91ciBlbmhhbmNlZCBmdW5jdGlvbmFsaXR5LlxuLy8gSW4gdGhlIGZ1dHVyZSwgdXNlIG1vbWVudC5tb21lbnRQcm9wZXJ0aWVzXG5uZXdNb21lbnRQcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbW9tID0gb2xkTW9tZW50UHJvdG8uY2xvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHQvLyB0aGVzZSBmbGFncyB3ZXJlbid0IHRyYW5zZmVyZWQgd2l0aCB0aGUgY2xvbmVcblx0dHJhbnNmZXJBbWJpZ3ModGhpcywgbW9tKTtcblx0aWYgKHRoaXMuX2Z1bGxDYWxlbmRhcikge1xuXHRcdG1vbS5fZnVsbENhbGVuZGFyID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBtb207XG59O1xuXG5cbi8vIFdlZWsgTnVtYmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gUmV0dXJucyB0aGUgd2VlayBudW1iZXIsIGNvbnNpZGVyaW5nIHRoZSBsb2NhbGUncyBjdXN0b20gd2VlayBudW1iZXIgY2FsY3VhdGlvblxuLy8gYHdlZWtzYCBpcyBhbiBhbGlhcyBmb3IgYHdlZWtgXG5uZXdNb21lbnRQcm90by53ZWVrID0gbmV3TW9tZW50UHJvdG8ud2Vla3MgPSBmdW5jdGlvbihpbnB1dCkge1xuXHR2YXIgd2Vla0NhbGMgPSAodGhpcy5fbG9jYWxlIHx8IHRoaXMuX2xhbmcpIC8vIHdvcmtzIHByZS1tb21lbnQtMi44XG5cdFx0Ll9mdWxsQ2FsZW5kYXJfd2Vla0NhbGM7XG5cblx0aWYgKGlucHV0ID09IG51bGwgJiYgdHlwZW9mIHdlZWtDYWxjID09PSAnZnVuY3Rpb24nKSB7IC8vIGN1c3RvbSBmdW5jdGlvbiBvbmx5IHdvcmtzIGZvciBnZXR0ZXJcblx0XHRyZXR1cm4gd2Vla0NhbGModGhpcyk7XG5cdH1cblx0ZWxzZSBpZiAod2Vla0NhbGMgPT09ICdJU08nKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudFByb3RvLmlzb1dlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gSVNPIGdldHRlci9zZXR0ZXJcblx0fVxuXG5cdHJldHVybiBvbGRNb21lbnRQcm90by53ZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGxvY2FsIGdldHRlci9zZXR0ZXJcbn07XG5cblxuLy8gVGltZS1vZi1kYXlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR0VUVEVSXG4vLyBSZXR1cm5zIGEgRHVyYXRpb24gd2l0aCB0aGUgaG91cnMvbWludXRlcy9zZWNvbmRzL21zIHZhbHVlcyBvZiB0aGUgbW9tZW50LlxuLy8gSWYgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGEgZHVyYXRpb24gb2YgMDA6MDAgd2lsbCBiZSByZXR1cm5lZC5cbi8vXG4vLyBTRVRURVJcbi8vIFlvdSBjYW4gc3VwcGx5IGEgRHVyYXRpb24sIGEgTW9tZW50LCBvciBhIER1cmF0aW9uLWxpa2UgYXJndW1lbnQuXG4vLyBXaGVuIHNldHRpbmcgdGhlIHRpbWUsIGFuZCB0aGUgbW9tZW50IGhhcyBhbiBhbWJpZ3VvdXMgdGltZSwgaXQgdGhlbiBiZWNvbWVzIHVuYW1iaWd1b3VzLlxubmV3TW9tZW50UHJvdG8udGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblxuXHQvLyBGYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgbWV0aG9kIChpZiB0aGVyZSBpcyBvbmUpIGlmIHRoaXMgbW9tZW50IHdhc24ndCBjcmVhdGVkIHZpYSBGdWxsQ2FsZW5kYXIuXG5cdC8vIGB0aW1lYCBpcyBhIGdlbmVyaWMgZW5vdWdoIG1ldGhvZCBuYW1lIHdoZXJlIHRoaXMgcHJlY2F1dGlvbiBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgY29sbGlzaW9ucyB3LyBvdGhlciBwbHVnaW5zLlxuXHRpZiAoIXRoaXMuX2Z1bGxDYWxlbmRhcikge1xuXHRcdHJldHVybiBvbGRNb21lbnRQcm90by50aW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHRpZiAodGltZSA9PSBudWxsKSB7IC8vIGdldHRlclxuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xuXHRcdFx0aG91cnM6IHRoaXMuaG91cnMoKSxcblx0XHRcdG1pbnV0ZXM6IHRoaXMubWludXRlcygpLFxuXHRcdFx0c2Vjb25kczogdGhpcy5zZWNvbmRzKCksXG5cdFx0XHRtaWxsaXNlY29uZHM6IHRoaXMubWlsbGlzZWNvbmRzKClcblx0XHR9KTtcblx0fVxuXHRlbHNlIHsgLy8gc2V0dGVyXG5cblx0XHR0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTsgLy8gbWFyayB0aGF0IHRoZSBtb21lbnQgbm93IGhhcyBhIHRpbWVcblxuXHRcdGlmICghbW9tZW50LmlzRHVyYXRpb24odGltZSkgJiYgIW1vbWVudC5pc01vbWVudCh0aW1lKSkge1xuXHRcdFx0dGltZSA9IG1vbWVudC5kdXJhdGlvbih0aW1lKTtcblx0XHR9XG5cblx0XHQvLyBUaGUgZGF5IHZhbHVlIHNob3VsZCBjYXVzZSBvdmVyZmxvdyAoc28gMjQgaG91cnMgYmVjb21lcyAwMDowMDowMCBvZiBuZXh0IGRheSkuXG5cdFx0Ly8gT25seSBmb3IgRHVyYXRpb24gdGltZXMsIG5vdCBNb21lbnQgdGltZXMuXG5cdFx0dmFyIGRheUhvdXJzID0gMDtcblx0XHRpZiAobW9tZW50LmlzRHVyYXRpb24odGltZSkpIHtcblx0XHRcdGRheUhvdXJzID0gTWF0aC5mbG9vcih0aW1lLmFzRGF5cygpKSAqIDI0O1xuXHRcdH1cblxuXHRcdC8vIFdlIG5lZWQgdG8gc2V0IHRoZSBpbmRpdmlkdWFsIGZpZWxkcy5cblx0XHQvLyBDYW4ndCB1c2Ugc3RhcnRPZignZGF5JykgdGhlbiBhZGQgZHVyYXRpb24uIEluIGNhc2Ugb2YgRFNUIGF0IHN0YXJ0IG9mIGRheS5cblx0XHRyZXR1cm4gdGhpcy5ob3VycyhkYXlIb3VycyArIHRpbWUuaG91cnMoKSlcblx0XHRcdC5taW51dGVzKHRpbWUubWludXRlcygpKVxuXHRcdFx0LnNlY29uZHModGltZS5zZWNvbmRzKCkpXG5cdFx0XHQubWlsbGlzZWNvbmRzKHRpbWUubWlsbGlzZWNvbmRzKCkpO1xuXHR9XG59O1xuXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZS1vZi1kYXkgYW5kIHRpbWV6b25lIG9mZnNldCxcbi8vIGJ1dCBwcmVzZXJ2aW5nIGl0cyBZTUQuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lIHdpbGwgZGlzcGxheSBubyB0aW1lXG4vLyBub3IgdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cbm5ld01vbWVudFByb3RvLnN0cmlwVGltZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYTtcblxuXHRpZiAoIXRoaXMuX2FtYmlnVGltZSkge1xuXG5cdFx0Ly8gZ2V0IHRoZSB2YWx1ZXMgYmVmb3JlIGFueSBjb252ZXJzaW9uIGhhcHBlbnNcblx0XHRhID0gdGhpcy50b0FycmF5KCk7IC8vIGFycmF5IG9mIHkvbS9kL2gvbS9zL21zXG5cblx0XHQvLyBUT0RPOiB1c2Uga2VlcExvY2FsVGltZSBpbiB0aGUgZnV0dXJlXG5cdFx0dGhpcy51dGMoKTsgLy8gc2V0IHRoZSBpbnRlcm5hbCBVVEMgZmxhZyAod2lsbCBjbGVhciB0aGUgYW1iaWcgZmxhZ3MpXG5cdFx0c2V0VVRDVmFsdWVzKHRoaXMsIGEuc2xpY2UoMCwgMykpOyAvLyBzZXQgdGhlIHllYXIvbW9udGgvZGF0ZS4gdGltZSB3aWxsIGJlIHplcm9cblxuXHRcdC8vIE1hcmsgdGhlIHRpbWUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxuXHRcdC8vIHdoaWNoIGNsZWFycyBhbGwgYW1iaWcgZmxhZ3MuIFNhbWUgd2l0aCBzZXRVVENWYWx1ZXMgd2l0aCBtb21lbnQtdGltZXpvbmUuXG5cdFx0dGhpcy5fYW1iaWdUaW1lID0gdHJ1ZTtcblx0XHR0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBpZiBhbWJpZ3VvdXMgdGltZSwgYWxzbyBhbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0XG5cdH1cblxuXHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vLyBSZXR1cm5zIGlmIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lIChib29sZWFuKVxubmV3TW9tZW50UHJvdG8uaGFzVGltZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gIXRoaXMuX2FtYmlnVGltZTtcbn07XG5cblxuLy8gVGltZXpvbmVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWV6b25lIG9mZnNldCwgYnV0IHByZXNlcnZpbmcgaXRzXG4vLyBZTUQgYW5kIHRpbWUtb2YtZGF5LiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZXpvbmUgb2Zmc2V0IHdpbGwgZGlzcGxheSBub1xuLy8gdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cbi8vIFRPRE86IGxvb2sgaW50byBNb21lbnQncyBrZWVwTG9jYWxUaW1lIGZ1bmN0aW9uYWxpdHlcbm5ld01vbWVudFByb3RvLnN0cmlwWm9uZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYSwgd2FzQW1iaWdUaW1lO1xuXG5cdGlmICghdGhpcy5fYW1iaWdab25lKSB7XG5cblx0XHQvLyBnZXQgdGhlIHZhbHVlcyBiZWZvcmUgYW55IGNvbnZlcnNpb24gaGFwcGVuc1xuXHRcdGEgPSB0aGlzLnRvQXJyYXkoKTsgLy8gYXJyYXkgb2YgeS9tL2QvaC9tL3MvbXNcblx0XHR3YXNBbWJpZ1RpbWUgPSB0aGlzLl9hbWJpZ1RpbWU7XG5cblx0XHR0aGlzLnV0YygpOyAvLyBzZXQgdGhlIGludGVybmFsIFVUQyBmbGFnIChtaWdodCBjbGVhciB0aGUgYW1iaWcgZmxhZ3MsIGRlcGVuZGluZyBvbiBNb21lbnQgaW50ZXJuYWxzKVxuXHRcdHNldFVUQ1ZhbHVlcyh0aGlzLCBhKTsgLy8gd2lsbCBzZXQgdGhlIHllYXIvbW9udGgvZGF0ZS9ob3Vycy9taW51dGVzL3NlY29uZHMvbXNcblxuXHRcdC8vIHRoZSBhYm92ZSBjYWxsIHRvIC51dGMoKS8udXRjT2Zmc2V0KCkgdW5mb3J0dW5hdGVseSBtaWdodCBjbGVhciB0aGUgYW1iaWcgZmxhZ3MsIHNvIHJlc3RvcmVcblx0XHR0aGlzLl9hbWJpZ1RpbWUgPSB3YXNBbWJpZ1RpbWUgfHwgZmFsc2U7XG5cblx0XHQvLyBNYXJrIHRoZSB6b25lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcblx0XHQvLyB3aGljaCBjbGVhcnMgdGhlIGFtYmlnIGZsYWdzLiBTYW1lIHdpdGggc2V0VVRDVmFsdWVzIHdpdGggbW9tZW50LXRpbWV6b25lLlxuXHRcdHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vLyBSZXR1cm5zIG9mIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lem9uZSBvZmZzZXQgKGJvb2xlYW4pXG5uZXdNb21lbnRQcm90by5oYXNab25lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAhdGhpcy5fYW1iaWdab25lO1xufTtcblxuXG4vLyB0aGlzIG1ldGhvZCBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxubmV3TW9tZW50UHJvdG8ubG9jYWwgPSBmdW5jdGlvbigpIHtcblx0dmFyIGEgPSB0aGlzLnRvQXJyYXkoKTsgLy8geWVhcixtb250aCxkYXRlLGhvdXJzLG1pbnV0ZXMsc2Vjb25kcyxtcyBhcyBhbiBhcnJheVxuXHR2YXIgd2FzQW1iaWdab25lID0gdGhpcy5fYW1iaWdab25lO1xuXG5cdG9sZE1vbWVudFByb3RvLmxvY2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0Ly8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcblx0Ly8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSBsb2NhbCgpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcblx0dGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XG5cdHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xuXG5cdGlmICh3YXNBbWJpZ1pvbmUpIHtcblx0XHQvLyBJZiB0aGUgbW9tZW50IHdhcyBhbWJpZ3VvdXNseSB6b25lZCwgdGhlIGRhdGUgZmllbGRzIHdlcmUgc3RvcmVkIGFzIFVUQy5cblx0XHQvLyBXZSB3YW50IHRvIHByZXNlcnZlIHRoZXNlLCBidXQgaW4gbG9jYWwgdGltZS5cblx0XHQvLyBUT0RPOiBsb29rIGludG8gTW9tZW50J3Mga2VlcExvY2FsVGltZSBmdW5jdGlvbmFsaXR5XG5cdFx0c2V0TG9jYWxWYWx1ZXModGhpcywgYSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG5cbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXG5uZXdNb21lbnRQcm90by51dGMgPSBmdW5jdGlvbigpIHtcblx0b2xkTW9tZW50UHJvdG8udXRjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0Ly8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcblx0Ly8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSB1dGMoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXG5cdHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xuXHR0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLy8gbWV0aG9kcyBmb3IgYXJiaXRyYXJpbHkgbWFuaXB1bGF0aW5nIHRpbWV6b25lIG9mZnNldC5cbi8vIHNob3VsZCBjbGVhciB0aW1lL3pvbmUgYW1iaWd1aXR5IHdoZW4gY2FsbGVkLlxuJC5lYWNoKFtcblx0J3pvbmUnLCAvLyBvbmx5IGluIG1vbWVudC1wcmUtMi45LiBkZXByZWNhdGVkIGFmdGVyd2FyZHNcblx0J3V0Y09mZnNldCdcbl0sIGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0aWYgKG9sZE1vbWVudFByb3RvW25hbWVdKSB7IC8vIG9yaWdpbmFsIG1ldGhvZCBleGlzdHM/XG5cblx0XHQvLyB0aGlzIG1ldGhvZCBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZSAod2lsbCBwcm9iYWJseSBnZXQgY2FsbGVkIHVwb24gLnV0YygpIGFuZCAubG9jYWwoKSlcblx0XHRuZXdNb21lbnRQcm90b1tuYW1lXSA9IGZ1bmN0aW9uKHR6bykge1xuXG5cdFx0XHRpZiAodHpvICE9IG51bGwpIHsgLy8gc2V0dGVyXG5cdFx0XHRcdC8vIHRoZXNlIGFzc2lnbm1lbnRzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIG9yaWdpbmFsIHpvbmUgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHRcdFx0Ly8gSSBmb3JnZXQgd2h5LCBzb21ldGhpbmcgdG8gZG8gd2l0aCBhIGJyb3dzZXIgY3Jhc2guXG5cdFx0XHRcdHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9sZE1vbWVudFByb3RvW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fVxufSk7XG5cblxuLy8gRm9ybWF0dGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5uZXdNb21lbnRQcm90by5mb3JtYXQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX2Z1bGxDYWxlbmRhciAmJiBhcmd1bWVudHNbMF0pIHsgLy8gYW4gZW5oYW5jZWQgbW9tZW50PyBhbmQgYSBmb3JtYXQgc3RyaW5nIHByb3ZpZGVkP1xuXHRcdHJldHVybiBmb3JtYXREYXRlKHRoaXMsIGFyZ3VtZW50c1swXSk7IC8vIG91ciBleHRlbmRlZCBmb3JtYXR0aW5nXG5cdH1cblx0aWYgKHRoaXMuX2FtYmlnVGltZSkge1xuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQodGhpcywgJ1lZWVktTU0tREQnKTtcblx0fVxuXHRpZiAodGhpcy5fYW1iaWdab25lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdCh0aGlzLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XG5cdH1cblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxubmV3TW9tZW50UHJvdG8udG9JU09TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX2FtYmlnVGltZSkge1xuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQodGhpcywgJ1lZWVktTU0tREQnKTtcblx0fVxuXHRpZiAodGhpcy5fYW1iaWdab25lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdCh0aGlzLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XG5cdH1cblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8vIFF1ZXJ5aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIElzIHRoZSBtb21lbnQgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2U/IGBlbmRgIGlzIGV4Y2x1c2l2ZS5cbi8vIEZZSSwgdGhpcyBtZXRob2QgaXMgbm90IGEgc3RhbmRhcmQgTW9tZW50IG1ldGhvZCwgc28gYWx3YXlzIGRvIG91ciBlbmhhbmNlZCBsb2dpYy5cbm5ld01vbWVudFByb3RvLmlzV2l0aGluID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuXHR2YXIgYSA9IGNvbW1vbmx5QW1iaWd1YXRlKFsgdGhpcywgc3RhcnQsIGVuZCBdKTtcblx0cmV0dXJuIGFbMF0gPj0gYVsxXSAmJiBhWzBdIDwgYVsyXTtcbn07XG5cbi8vIFdoZW4gaXNTYW1lIGlzIGNhbGxlZCB3aXRoIHVuaXRzLCB0aW1lem9uZSBhbWJpZ3VpdHkgaXMgbm9ybWFsaXplZCBiZWZvcmUgdGhlIGNvbXBhcmlzb24gaGFwcGVucy5cbi8vIElmIG5vIHVuaXRzIHNwZWNpZmllZCwgdGhlIHR3byBtb21lbnRzIG11c3QgYmUgaWRlbnRpY2FsbHkgdGhlIHNhbWUsIHdpdGggbWF0Y2hpbmcgYW1iaWcgZmxhZ3MuXG5uZXdNb21lbnRQcm90by5pc1NhbWUgPSBmdW5jdGlvbihpbnB1dCwgdW5pdHMpIHtcblx0dmFyIGE7XG5cblx0Ly8gb25seSBkbyBjdXN0b20gbG9naWMgaWYgdGhpcyBpcyBhbiBlbmhhbmNlZCBtb21lbnRcblx0aWYgKCF0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50UHJvdG8uaXNTYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHRpZiAodW5pdHMpIHtcblx0XHRhID0gY29tbW9ubHlBbWJpZ3VhdGUoWyB0aGlzLCBpbnB1dCBdLCB0cnVlKTsgLy8gbm9ybWFsaXplIHRpbWV6b25lcyBidXQgZG9uJ3QgZXJhc2UgdGltZXNcblx0XHRyZXR1cm4gb2xkTW9tZW50UHJvdG8uaXNTYW1lLmNhbGwoYVswXSwgYVsxXSwgdW5pdHMpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGlucHV0ID0gRkMubW9tZW50LnBhcnNlWm9uZShpbnB1dCk7IC8vIG5vcm1hbGl6ZSBpbnB1dFxuXHRcdHJldHVybiBvbGRNb21lbnRQcm90by5pc1NhbWUuY2FsbCh0aGlzLCBpbnB1dCkgJiZcblx0XHRcdEJvb2xlYW4odGhpcy5fYW1iaWdUaW1lKSA9PT0gQm9vbGVhbihpbnB1dC5fYW1iaWdUaW1lKSAmJlxuXHRcdFx0Qm9vbGVhbih0aGlzLl9hbWJpZ1pvbmUpID09PSBCb29sZWFuKGlucHV0Ll9hbWJpZ1pvbmUpO1xuXHR9XG59O1xuXG4vLyBNYWtlIHRoZXNlIHF1ZXJ5IG1ldGhvZHMgd29yayB3aXRoIGFtYmlndW91cyBtb21lbnRzXG4kLmVhY2goW1xuXHQnaXNCZWZvcmUnLFxuXHQnaXNBZnRlcidcbl0sIGZ1bmN0aW9uKGksIG1ldGhvZE5hbWUpIHtcblx0bmV3TW9tZW50UHJvdG9bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpbnB1dCwgdW5pdHMpIHtcblx0XHR2YXIgYTtcblxuXHRcdC8vIG9ubHkgZG8gY3VzdG9tIGxvZ2ljIGlmIHRoaXMgaXMgYW4gZW5oYW5jZWQgbW9tZW50XG5cdFx0aWYgKCF0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcblx0XHRcdHJldHVybiBvbGRNb21lbnRQcm90b1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdGEgPSBjb21tb25seUFtYmlndWF0ZShbIHRoaXMsIGlucHV0IF0pO1xuXHRcdHJldHVybiBvbGRNb21lbnRQcm90b1ttZXRob2ROYW1lXS5jYWxsKGFbMF0sIGFbMV0sIHVuaXRzKTtcblx0fTtcbn0pO1xuXG5cbi8vIE1pc2MgSW50ZXJuYWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGdpdmVuIGFuIGFycmF5IG9mIG1vbWVudC1saWtlIGlucHV0cywgcmV0dXJuIGEgcGFyYWxsZWwgYXJyYXkgdy8gbW9tZW50cyBzaW1pbGFybHkgYW1iaWd1YXRlZC5cbi8vIGZvciBleGFtcGxlLCBvZiBvbmUgbW9tZW50IGhhcyBhbWJpZyB0aW1lLCBidXQgbm90IG90aGVycywgYWxsIG1vbWVudHMgd2lsbCBoYXZlIHRoZWlyIHRpbWUgc3RyaXBwZWQuXG4vLyBzZXQgYHByZXNlcnZlVGltZWAgdG8gYHRydWVgIHRvIGtlZXAgdGltZXMsIGJ1dCBvbmx5IG5vcm1hbGl6ZSB6b25lIGFtYmlndWl0eS5cbi8vIHJldHVybnMgdGhlIG9yaWdpbmFsIG1vbWVudHMgaWYgbm8gbW9kaWZpY2F0aW9ucyBhcmUgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gY29tbW9ubHlBbWJpZ3VhdGUoaW5wdXRzLCBwcmVzZXJ2ZVRpbWUpIHtcblx0dmFyIGFueUFtYmlnVGltZSA9IGZhbHNlO1xuXHR2YXIgYW55QW1iaWdab25lID0gZmFsc2U7XG5cdHZhciBsZW4gPSBpbnB1dHMubGVuZ3RoO1xuXHR2YXIgbW9tcyA9IFtdO1xuXHR2YXIgaSwgbW9tO1xuXG5cdC8vIHBhcnNlIGlucHV0cyBpbnRvIHJlYWwgbW9tZW50cyBhbmQgcXVlcnkgdGhlaXIgYW1iaWcgZmxhZ3Ncblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0bW9tID0gaW5wdXRzW2ldO1xuXHRcdGlmICghbW9tZW50LmlzTW9tZW50KG1vbSkpIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC5wYXJzZVpvbmUobW9tKTtcblx0XHR9XG5cdFx0YW55QW1iaWdUaW1lID0gYW55QW1iaWdUaW1lIHx8IG1vbS5fYW1iaWdUaW1lO1xuXHRcdGFueUFtYmlnWm9uZSA9IGFueUFtYmlnWm9uZSB8fCBtb20uX2FtYmlnWm9uZTtcblx0XHRtb21zLnB1c2gobW9tKTtcblx0fVxuXG5cdC8vIHN0cmlwIGVhY2ggbW9tZW50IGRvd24gdG8gbG93ZXN0IGNvbW1vbiBhbWJpZ3VpdHlcblx0Ly8gdXNlIGNsb25lcyB0byBhdm9pZCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG1vbWVudHNcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0bW9tID0gbW9tc1tpXTtcblx0XHRpZiAoIXByZXNlcnZlVGltZSAmJiBhbnlBbWJpZ1RpbWUgJiYgIW1vbS5fYW1iaWdUaW1lKSB7XG5cdFx0XHRtb21zW2ldID0gbW9tLmNsb25lKCkuc3RyaXBUaW1lKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGFueUFtYmlnWm9uZSAmJiAhbW9tLl9hbWJpZ1pvbmUpIHtcblx0XHRcdG1vbXNbaV0gPSBtb20uY2xvbmUoKS5zdHJpcFpvbmUoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbW9tcztcbn1cblxuLy8gVHJhbnNmZXJzIGFsbCB0aGUgZmxhZ3MgcmVsYXRlZCB0byBhbWJpZ3VvdXMgdGltZS96b25lIGZyb20gdGhlIGBzcmNgIG1vbWVudCB0byB0aGUgYGRlc3RgIG1vbWVudFxuLy8gVE9ETzogbG9vayBpbnRvIG1vbWVudC5tb21lbnRQcm9wZXJ0aWVzIGZvciB0aGlzLlxuZnVuY3Rpb24gdHJhbnNmZXJBbWJpZ3Moc3JjLCBkZXN0KSB7XG5cdGlmIChzcmMuX2FtYmlnVGltZSkge1xuXHRcdGRlc3QuX2FtYmlnVGltZSA9IHRydWU7XG5cdH1cblx0ZWxzZSBpZiAoZGVzdC5fYW1iaWdUaW1lKSB7XG5cdFx0ZGVzdC5fYW1iaWdUaW1lID0gZmFsc2U7XG5cdH1cblxuXHRpZiAoc3JjLl9hbWJpZ1pvbmUpIHtcblx0XHRkZXN0Ll9hbWJpZ1pvbmUgPSB0cnVlO1xuXHR9XG5cdGVsc2UgaWYgKGRlc3QuX2FtYmlnWm9uZSkge1xuXHRcdGRlc3QuX2FtYmlnWm9uZSA9IGZhbHNlO1xuXHR9XG59XG5cblxuLy8gU2V0cyB0aGUgeWVhci9tb250aC9kYXRlL2V0YyB2YWx1ZXMgb2YgdGhlIG1vbWVudCBmcm9tIHRoZSBnaXZlbiBhcnJheS5cbi8vIEluZWZmaWNpZW50IGJlY2F1c2UgaXQgY2FsbHMgZWFjaCBpbmRpdmlkdWFsIHNldHRlci5cbmZ1bmN0aW9uIHNldE1vbWVudFZhbHVlcyhtb20sIGEpIHtcblx0bW9tLnllYXIoYVswXSB8fCAwKVxuXHRcdC5tb250aChhWzFdIHx8IDApXG5cdFx0LmRhdGUoYVsyXSB8fCAwKVxuXHRcdC5ob3VycyhhWzNdIHx8IDApXG5cdFx0Lm1pbnV0ZXMoYVs0XSB8fCAwKVxuXHRcdC5zZWNvbmRzKGFbNV0gfHwgMClcblx0XHQubWlsbGlzZWNvbmRzKGFbNl0gfHwgMCk7XG59XG5cbi8vIENhbiB3ZSBzZXQgdGhlIG1vbWVudCdzIGludGVybmFsIGRhdGUgZGlyZWN0bHk/XG5hbGxvd1ZhbHVlT3B0aW1pemF0aW9uID0gJ19kJyBpbiBtb21lbnQoKSAmJiAndXBkYXRlT2Zmc2V0JyBpbiBtb21lbnQ7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24uIEFjY2VwdHMgYSBtb21lbnQgYW5kIGFuIGFycmF5IG9mIHRoZSBVVEMgeWVhci9tb250aC9kYXRlL2V0YyB2YWx1ZXMgdG8gc2V0LlxuLy8gQXNzdW1lcyB0aGUgZ2l2ZW4gbW9tZW50IGlzIGFscmVhZHkgaW4gVVRDIG1vZGUuXG5zZXRVVENWYWx1ZXMgPSBhbGxvd1ZhbHVlT3B0aW1pemF0aW9uID8gZnVuY3Rpb24obW9tLCBhKSB7XG5cdC8vIHNpbWxhdGUgd2hhdCBtb21lbnQncyBhY2Nlc3NvcnMgZG9cblx0bW9tLl9kLnNldFRpbWUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpO1xuXHRtb21lbnQudXBkYXRlT2Zmc2V0KG1vbSwgZmFsc2UpOyAvLyBrZWVwVGltZT1mYWxzZVxufSA6IHNldE1vbWVudFZhbHVlcztcblxuLy8gVXRpbGl0eSBmdW5jdGlvbi4gQWNjZXB0cyBhIG1vbWVudCBhbmQgYW4gYXJyYXkgb2YgdGhlIGxvY2FsIHllYXIvbW9udGgvZGF0ZS9ldGMgdmFsdWVzIHRvIHNldC5cbi8vIEFzc3VtZXMgdGhlIGdpdmVuIG1vbWVudCBpcyBhbHJlYWR5IGluIGxvY2FsIG1vZGUuXG5zZXRMb2NhbFZhbHVlcyA9IGFsbG93VmFsdWVPcHRpbWl6YXRpb24gPyBmdW5jdGlvbihtb20sIGEpIHtcblx0Ly8gc2ltbGF0ZSB3aGF0IG1vbWVudCdzIGFjY2Vzc29ycyBkb1xuXHRtb20uX2Quc2V0VGltZSgrbmV3IERhdGUoIC8vIEZZSSwgdGhlcmUgaXMgbm93IHdheSB0byBhcHBseSBhbiBhcnJheSBvZiBhcmdzIHRvIGEgY29uc3RydWN0b3Jcblx0XHRhWzBdIHx8IDAsXG5cdFx0YVsxXSB8fCAwLFxuXHRcdGFbMl0gfHwgMCxcblx0XHRhWzNdIHx8IDAsXG5cdFx0YVs0XSB8fCAwLFxuXHRcdGFbNV0gfHwgMCxcblx0XHRhWzZdIHx8IDBcblx0KSk7XG5cdG1vbWVudC51cGRhdGVPZmZzZXQobW9tLCBmYWxzZSk7IC8vIGtlZXBUaW1lPWZhbHNlXG59IDogc2V0TW9tZW50VmFsdWVzO1xuXG47O1xuXG4vLyBTaW5nbGUgRGF0ZSBGb3JtYXR0aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gY2FsbCB0aGlzIGlmIHlvdSB3YW50IE1vbWVudCdzIG9yaWdpbmFsIGZvcm1hdCBtZXRob2QgdG8gYmUgdXNlZFxuZnVuY3Rpb24gb2xkTW9tZW50Rm9ybWF0KG1vbSwgZm9ybWF0U3RyKSB7XG5cdHJldHVybiBvbGRNb21lbnRQcm90by5mb3JtYXQuY2FsbChtb20sIGZvcm1hdFN0cik7IC8vIG9sZE1vbWVudFByb3RvIGRlZmluZWQgaW4gbW9tZW50LWV4dC5qc1xufVxuXG5cbi8vIEZvcm1hdHMgYGRhdGVgIHdpdGggYSBNb21lbnQgZm9ybWF0dGluZyBzdHJpbmcsIGJ1dCBhbGxvdyBvdXIgbm9uLXplcm8gYXJlYXMgYW5kXG4vLyBhZGRpdGlvbmFsIHRva2VuLlxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXRTdHIpIHtcblx0cmV0dXJuIGZvcm1hdERhdGVXaXRoQ2h1bmtzKGRhdGUsIGdldEZvcm1hdFN0cmluZ0NodW5rcyhmb3JtYXRTdHIpKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXREYXRlV2l0aENodW5rcyhkYXRlLCBjaHVua3MpIHtcblx0dmFyIHMgPSAnJztcblx0dmFyIGk7XG5cblx0Zm9yIChpPTA7IGk8Y2h1bmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cyArPSBmb3JtYXREYXRlV2l0aENodW5rKGRhdGUsIGNodW5rc1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gcztcbn1cblxuXG4vLyBhZGRpdGlvbiBmb3JtYXR0aW5nIHRva2VucyB3ZSB3YW50IHJlY29nbml6ZWRcbnZhciB0b2tlbk92ZXJyaWRlcyA9IHtcblx0dDogZnVuY3Rpb24oZGF0ZSkgeyAvLyBcImFcIiBvciBcInBcIlxuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZGF0ZSwgJ2EnKS5jaGFyQXQoMCk7XG5cdH0sXG5cdFQ6IGZ1bmN0aW9uKGRhdGUpIHsgLy8gXCJBXCIgb3IgXCJQXCJcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGRhdGUsICdBJykuY2hhckF0KDApO1xuXHR9XG59O1xuXG5cbmZ1bmN0aW9uIGZvcm1hdERhdGVXaXRoQ2h1bmsoZGF0ZSwgY2h1bmspIHtcblx0dmFyIHRva2VuO1xuXHR2YXIgbWF5YmVTdHI7XG5cblx0aWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsgLy8gYSBsaXRlcmFsIHN0cmluZ1xuXHRcdHJldHVybiBjaHVuaztcblx0fVxuXHRlbHNlIGlmICgodG9rZW4gPSBjaHVuay50b2tlbikpIHsgLy8gYSB0b2tlbiwgbGlrZSBcIllZWVlcIlxuXHRcdGlmICh0b2tlbk92ZXJyaWRlc1t0b2tlbl0pIHtcblx0XHRcdHJldHVybiB0b2tlbk92ZXJyaWRlc1t0b2tlbl0oZGF0ZSk7IC8vIHVzZSBvdXIgY3VzdG9tIHRva2VuXG5cdFx0fVxuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZGF0ZSwgdG9rZW4pO1xuXHR9XG5cdGVsc2UgaWYgKGNodW5rLm1heWJlKSB7IC8vIGEgZ3JvdXBpbmcgb2Ygb3RoZXIgY2h1bmtzIHRoYXQgbXVzdCBiZSBub24temVyb1xuXHRcdG1heWJlU3RyID0gZm9ybWF0RGF0ZVdpdGhDaHVua3MoZGF0ZSwgY2h1bmsubWF5YmUpO1xuXHRcdGlmIChtYXliZVN0ci5tYXRjaCgvWzEtOV0vKSkge1xuXHRcdFx0cmV0dXJuIG1heWJlU3RyO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAnJztcbn1cblxuXG4vLyBEYXRlIFJhbmdlIEZvcm1hdHRpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE86IG1ha2UgaXQgd29yayB3aXRoIHRpbWV6b25lIG9mZnNldFxuXG4vLyBVc2luZyBhIGZvcm1hdHRpbmcgc3RyaW5nIG1lYW50IGZvciBhIHNpbmdsZSBkYXRlLCBnZW5lcmF0ZSBhIHJhbmdlIHN0cmluZywgbGlrZVxuLy8gXCJTZXAgMiAtIDkgMjAxM1wiLCB0aGF0IGludGVsbGlnZW50bHkgaW5zZXJ0cyBhIHNlcGFyYXRvciB3aGVyZSB0aGUgZGF0ZXMgZGlmZmVyLlxuLy8gSWYgdGhlIGRhdGVzIGFyZSB0aGUgc2FtZSBhcyBmYXIgYXMgdGhlIGZvcm1hdCBzdHJpbmcgaXMgY29uY2VybmVkLCBqdXN0IHJldHVybiBhIHNpbmdsZVxuLy8gcmVuZGVyaW5nIG9mIG9uZSBkYXRlLCB3aXRob3V0IGFueSBzZXBhcmF0b3IuXG5mdW5jdGlvbiBmb3JtYXRSYW5nZShkYXRlMSwgZGF0ZTIsIGZvcm1hdFN0ciwgc2VwYXJhdG9yLCBpc1JUTCkge1xuXHR2YXIgbG9jYWxlRGF0YTtcblxuXHRkYXRlMSA9IEZDLm1vbWVudC5wYXJzZVpvbmUoZGF0ZTEpO1xuXHRkYXRlMiA9IEZDLm1vbWVudC5wYXJzZVpvbmUoZGF0ZTIpO1xuXG5cdGxvY2FsZURhdGEgPSAoZGF0ZTEubG9jYWxlRGF0YSB8fCBkYXRlMS5sYW5nKS5jYWxsKGRhdGUxKTsgLy8gd29ya3Mgd2l0aCBtb21lbnQtcHJlLTIuOFxuXG5cdC8vIEV4cGFuZCBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MsIGxpa2UgXCJMTFwiIC0+IFwiTU1NTSBEIFlZWVlcIlxuXHRmb3JtYXRTdHIgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KGZvcm1hdFN0cikgfHwgZm9ybWF0U3RyO1xuXHQvLyBCVFcsIHRoaXMgaXMgbm90IGltcG9ydGFudCBmb3IgYGZvcm1hdERhdGVgIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSB0byBwdXQgY3VzdG9tIHRva2Vuc1xuXHQvLyBvciBub24temVybyBhcmVhcyBpbiBNb21lbnQncyBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MuXG5cblx0c2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcgLSAnO1xuXG5cdHJldHVybiBmb3JtYXRSYW5nZVdpdGhDaHVua3MoXG5cdFx0ZGF0ZTEsXG5cdFx0ZGF0ZTIsXG5cdFx0Z2V0Rm9ybWF0U3RyaW5nQ2h1bmtzKGZvcm1hdFN0ciksXG5cdFx0c2VwYXJhdG9yLFxuXHRcdGlzUlRMXG5cdCk7XG59XG5GQy5mb3JtYXRSYW5nZSA9IGZvcm1hdFJhbmdlOyAvLyBleHBvc2VcblxuXG5mdW5jdGlvbiBmb3JtYXRSYW5nZVdpdGhDaHVua3MoZGF0ZTEsIGRhdGUyLCBjaHVua3MsIHNlcGFyYXRvciwgaXNSVEwpIHtcblx0dmFyIHVuem9uZWREYXRlMSA9IGRhdGUxLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIGZvciBmb3JtYXRTaW1pbGFyQ2h1bmtcblx0dmFyIHVuem9uZWREYXRlMiA9IGRhdGUyLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIFwiXG5cdHZhciBjaHVua1N0cjsgLy8gdGhlIHJlbmRlcmluZyBvZiB0aGUgY2h1bmtcblx0dmFyIGxlZnRJO1xuXHR2YXIgbGVmdFN0ciA9ICcnO1xuXHR2YXIgcmlnaHRJO1xuXHR2YXIgcmlnaHRTdHIgPSAnJztcblx0dmFyIG1pZGRsZUk7XG5cdHZhciBtaWRkbGVTdHIxID0gJyc7XG5cdHZhciBtaWRkbGVTdHIyID0gJyc7XG5cdHZhciBtaWRkbGVTdHIgPSAnJztcblxuXHQvLyBTdGFydCBhdCB0aGUgbGVmdG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHlvdSBoaXQgYSB0b2tlblxuXHQvLyB0aGF0IGlzIG5vdCB0aGUgc2FtZSBiZXR3ZWVuIGRhdGVzLlxuXHRmb3IgKGxlZnRJPTA7IGxlZnRJPGNodW5rcy5sZW5ndGg7IGxlZnRJKyspIHtcblx0XHRjaHVua1N0ciA9IGZvcm1hdFNpbWlsYXJDaHVuayhkYXRlMSwgZGF0ZTIsIHVuem9uZWREYXRlMSwgdW56b25lZERhdGUyLCBjaHVua3NbbGVmdEldKTtcblx0XHRpZiAoY2h1bmtTdHIgPT09IGZhbHNlKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0bGVmdFN0ciArPSBjaHVua1N0cjtcblx0fVxuXG5cdC8vIFNpbWlsYXJseSwgc3RhcnQgYXQgdGhlIHJpZ2h0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgbW92ZSBsZWZ0XG5cdGZvciAocmlnaHRJPWNodW5rcy5sZW5ndGgtMTsgcmlnaHRJPmxlZnRJOyByaWdodEktLSkge1xuXHRcdGNodW5rU3RyID0gZm9ybWF0U2ltaWxhckNodW5rKGRhdGUxLCBkYXRlMiwgdW56b25lZERhdGUxLCB1bnpvbmVkRGF0ZTIsICBjaHVua3NbcmlnaHRJXSk7XG5cdFx0aWYgKGNodW5rU3RyID09PSBmYWxzZSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHJpZ2h0U3RyID0gY2h1bmtTdHIgKyByaWdodFN0cjtcblx0fVxuXG5cdC8vIFRoZSBhcmVhIGluIHRoZSBtaWRkbGUgaXMgZGlmZmVyZW50IGZvciBib3RoIG9mIHRoZSBkYXRlcy5cblx0Ly8gQ29sbGVjdCB0aGVtIGRpc3RpbmN0bHkgc28gd2UgY2FuIGphbSB0aGVtIHRvZ2V0aGVyIGxhdGVyLlxuXHRmb3IgKG1pZGRsZUk9bGVmdEk7IG1pZGRsZUk8PXJpZ2h0STsgbWlkZGxlSSsrKSB7XG5cdFx0bWlkZGxlU3RyMSArPSBmb3JtYXREYXRlV2l0aENodW5rKGRhdGUxLCBjaHVua3NbbWlkZGxlSV0pO1xuXHRcdG1pZGRsZVN0cjIgKz0gZm9ybWF0RGF0ZVdpdGhDaHVuayhkYXRlMiwgY2h1bmtzW21pZGRsZUldKTtcblx0fVxuXG5cdGlmIChtaWRkbGVTdHIxIHx8IG1pZGRsZVN0cjIpIHtcblx0XHRpZiAoaXNSVEwpIHtcblx0XHRcdG1pZGRsZVN0ciA9IG1pZGRsZVN0cjIgKyBzZXBhcmF0b3IgKyBtaWRkbGVTdHIxO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG1pZGRsZVN0ciA9IG1pZGRsZVN0cjEgKyBzZXBhcmF0b3IgKyBtaWRkbGVTdHIyO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBsZWZ0U3RyICsgbWlkZGxlU3RyICsgcmlnaHRTdHI7XG59XG5cblxudmFyIHNpbWlsYXJVbml0TWFwID0ge1xuXHRZOiAneWVhcicsXG5cdE06ICdtb250aCcsXG5cdEQ6ICdkYXknLCAvLyBkYXkgb2YgbW9udGhcblx0ZDogJ2RheScsIC8vIGRheSBvZiB3ZWVrXG5cdC8vIHByZXZlbnRzIGEgc2VwYXJhdG9yIGJldHdlZW4gYW55dGhpbmcgdGltZS1yZWxhdGVkLi4uXG5cdEE6ICdzZWNvbmQnLCAvLyBBTS9QTVxuXHRhOiAnc2Vjb25kJywgLy8gYW0vcG1cblx0VDogJ3NlY29uZCcsIC8vIEEvUFxuXHR0OiAnc2Vjb25kJywgLy8gYS9wXG5cdEg6ICdzZWNvbmQnLCAvLyBob3VyICgyNClcblx0aDogJ3NlY29uZCcsIC8vIGhvdXIgKDEyKVxuXHRtOiAnc2Vjb25kJywgLy8gbWludXRlXG5cdHM6ICdzZWNvbmQnIC8vIHNlY29uZFxufTtcbi8vIFRPRE86IHdlZWsgbWF5YmU/XG5cblxuLy8gR2l2ZW4gYSBmb3JtYXR0aW5nIGNodW5rLCBhbmQgZ2l2ZW4gdGhhdCBib3RoIGRhdGVzIGFyZSBzaW1pbGFyIGluIHRoZSByZWdhcmQgdGhlXG4vLyBmb3JtYXR0aW5nIGNodW5rIGlzIGNvbmNlcm5lZCwgZm9ybWF0IGRhdGUxIGFnYWluc3QgYGNodW5rYC4gT3RoZXJ3aXNlLCByZXR1cm4gYGZhbHNlYC5cbmZ1bmN0aW9uIGZvcm1hdFNpbWlsYXJDaHVuayhkYXRlMSwgZGF0ZTIsIHVuem9uZWREYXRlMSwgdW56b25lZERhdGUyLCBjaHVuaykge1xuXHR2YXIgdG9rZW47XG5cdHZhciB1bml0O1xuXG5cdGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7IC8vIGEgbGl0ZXJhbCBzdHJpbmdcblx0XHRyZXR1cm4gY2h1bms7XG5cdH1cblx0ZWxzZSBpZiAoKHRva2VuID0gY2h1bmsudG9rZW4pKSB7XG5cdFx0dW5pdCA9IHNpbWlsYXJVbml0TWFwW3Rva2VuLmNoYXJBdCgwKV07XG5cblx0XHQvLyBhcmUgdGhlIGRhdGVzIHRoZSBzYW1lIGZvciB0aGlzIHVuaXQgb2YgbWVhc3VyZW1lbnQ/XG5cdFx0Ly8gdXNlIHRoZSB1bnpvbmVkIGRhdGVzIGZvciB0aGlzIGNhbGN1bGF0aW9uIGJlY2F1c2UgdW5yZWxpYWJsZSB3aGVuIG5lYXIgRFNUIChidWcgIzIzOTYpXG5cdFx0aWYgKHVuaXQgJiYgdW56b25lZERhdGUxLmlzU2FtZSh1bnpvbmVkRGF0ZTIsIHVuaXQpKSB7XG5cdFx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGRhdGUxLCB0b2tlbik7IC8vIHdvdWxkIGJlIHRoZSBzYW1lIGlmIHdlIHVzZWQgYGRhdGUyYFxuXHRcdFx0Ly8gQlRXLCBkb24ndCBzdXBwb3J0IGN1c3RvbSB0b2tlbnNcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7IC8vIHRoZSBjaHVuayBpcyBOT1QgdGhlIHNhbWUgZm9yIHRoZSB0d28gZGF0ZXNcblx0Ly8gQlRXLCBkb24ndCBzdXBwb3J0IHNwbGl0dGluZyBvbiBub24temVybyBhcmVhc1xufVxuXG5cbi8vIENodW5raW5nIFV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxudmFyIGZvcm1hdFN0cmluZ0NodW5rQ2FjaGUgPSB7fTtcblxuXG5mdW5jdGlvbiBnZXRGb3JtYXRTdHJpbmdDaHVua3MoZm9ybWF0U3RyKSB7XG5cdGlmIChmb3JtYXRTdHIgaW4gZm9ybWF0U3RyaW5nQ2h1bmtDYWNoZSkge1xuXHRcdHJldHVybiBmb3JtYXRTdHJpbmdDaHVua0NhY2hlW2Zvcm1hdFN0cl07XG5cdH1cblx0cmV0dXJuIChmb3JtYXRTdHJpbmdDaHVua0NhY2hlW2Zvcm1hdFN0cl0gPSBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpKTtcbn1cblxuXG4vLyBCcmVhayB0aGUgZm9ybWF0dGluZyBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBjaHVua3NcbmZ1bmN0aW9uIGNodW5rRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikge1xuXHR2YXIgY2h1bmtzID0gW107XG5cdHZhciBjaHVua2VyID0gL1xcWyhbXlxcXV0qKVxcXXxcXCgoW15cXCldKilcXCl8KExUU3xMVHwoXFx3KVxcNCpvPyl8KFteXFx3XFxbXFwoXSspL2c7IC8vIFRPRE86IG1vcmUgZGVzY3JpbWluYXRpb25cblx0dmFyIG1hdGNoO1xuXG5cdHdoaWxlICgobWF0Y2ggPSBjaHVua2VyLmV4ZWMoZm9ybWF0U3RyKSkpIHtcblx0XHRpZiAobWF0Y2hbMV0pIHsgLy8gYSBsaXRlcmFsIHN0cmluZyBpbnNpZGUgWyAuLi4gXVxuXHRcdFx0Y2h1bmtzLnB1c2gobWF0Y2hbMV0pO1xuXHRcdH1cblx0XHRlbHNlIGlmIChtYXRjaFsyXSkgeyAvLyBub24temVybyBmb3JtYXR0aW5nIGluc2lkZSAoIC4uLiApXG5cdFx0XHRjaHVua3MucHVzaCh7IG1heWJlOiBjaHVua0Zvcm1hdFN0cmluZyhtYXRjaFsyXSkgfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdKSB7IC8vIGEgZm9ybWF0dGluZyB0b2tlblxuXHRcdFx0Y2h1bmtzLnB1c2goeyB0b2tlbjogbWF0Y2hbM10gfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG1hdGNoWzVdKSB7IC8vIGFuIHVuZW5jbG9zZWQgbGl0ZXJhbCBzdHJpbmdcblx0XHRcdGNodW5rcy5wdXNoKG1hdGNoWzVdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2h1bmtzO1xufVxuXG47O1xuXG5GQy5DbGFzcyA9IENsYXNzOyAvLyBleHBvcnRcblxuLy8gQ2xhc3MgdGhhdCBhbGwgb3RoZXIgY2xhc3NlcyB3aWxsIGluaGVyaXQgZnJvbVxuZnVuY3Rpb24gQ2xhc3MoKSB7IH1cblxuXG4vLyBDYWxsZWQgb24gYSBjbGFzcyB0byBjcmVhdGUgYSBzdWJjbGFzcy5cbi8vIExhc3QgYXJndW1lbnQgY29udGFpbnMgaW5zdGFuY2UgbWV0aG9kcy4gQW55IGFyZ3VtZW50IGJlZm9yZSB0aGUgbGFzdCBhcmUgY29uc2lkZXJlZCBtaXhpbnMuXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdHZhciBpO1xuXHR2YXIgbWVtYmVycztcblxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRtZW1iZXJzID0gYXJndW1lbnRzW2ldO1xuXHRcdGlmIChpIDwgbGVuIC0gMSkgeyAvLyBub3QgdGhlIGxhc3QgYXJndW1lbnQ/XG5cdFx0XHRtaXhJbnRvQ2xhc3ModGhpcywgbWVtYmVycyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGV4dGVuZENsYXNzKHRoaXMsIG1lbWJlcnMgfHwge30pOyAvLyBtZW1iZXJzIHdpbGwgYmUgdW5kZWZpbmVkIGlmIG5vIGFyZ3VtZW50c1xufTtcblxuXG4vLyBBZGRzIG5ldyBtZW1iZXIgdmFyaWFibGVzL21ldGhvZHMgdG8gdGhlIGNsYXNzJ3MgcHJvdG90eXBlLlxuLy8gQ2FuIGJlIGNhbGxlZCB3aXRoIGFub3RoZXIgY2xhc3MsIG9yIGEgcGxhaW4gb2JqZWN0IGhhc2ggY29udGFpbmluZyBuZXcgbWVtYmVycy5cbkNsYXNzLm1peGluID0gZnVuY3Rpb24obWVtYmVycykge1xuXHRtaXhJbnRvQ2xhc3ModGhpcywgbWVtYmVycyk7XG59O1xuXG5cbmZ1bmN0aW9uIGV4dGVuZENsYXNzKHN1cGVyQ2xhc3MsIG1lbWJlcnMpIHtcblx0dmFyIHN1YkNsYXNzO1xuXG5cdC8vIGVuc3VyZSBhIGNvbnN0cnVjdG9yIGZvciB0aGUgc3ViY2xhc3MsIGZvcndhcmRpbmcgYWxsIGFyZ3VtZW50cyB0byB0aGUgc3VwZXItY29uc3RydWN0b3IgaWYgaXQgZG9lc24ndCBleGlzdFxuXHRpZiAoaGFzT3duUHJvcChtZW1iZXJzLCAnY29uc3RydWN0b3InKSkge1xuXHRcdHN1YkNsYXNzID0gbWVtYmVycy5jb25zdHJ1Y3Rvcjtcblx0fVxuXHRpZiAodHlwZW9mIHN1YkNsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0c3ViQ2xhc3MgPSBtZW1iZXJzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXBlckNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fVxuXG5cdC8vIGJ1aWxkIHRoZSBiYXNlIHByb3RvdHlwZSBmb3IgdGhlIHN1YmNsYXNzLCB3aGljaCBpcyBhbiBuZXcgb2JqZWN0IGNoYWluZWQgdG8gdGhlIHN1cGVyY2xhc3MncyBwcm90b3R5cGVcblx0c3ViQ2xhc3MucHJvdG90eXBlID0gY3JlYXRlT2JqZWN0KHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcblxuXHQvLyBjb3B5IGVhY2ggbWVtYmVyIHZhcmlhYmxlL21ldGhvZCBvbnRvIHRoZSB0aGUgc3ViY2xhc3MncyBwcm90b3R5cGVcblx0Y29weU93blByb3BzKG1lbWJlcnMsIHN1YkNsYXNzLnByb3RvdHlwZSk7XG5cdGNvcHlOYXRpdmVNZXRob2RzKG1lbWJlcnMsIHN1YkNsYXNzLnByb3RvdHlwZSk7IC8vIGhhY2sgZm9yIElFOFxuXG5cdC8vIGNvcHkgb3ZlciBhbGwgY2xhc3MgdmFyaWFibGVzL21ldGhvZHMgdG8gdGhlIHN1YmNsYXNzLCBzdWNoIGFzIGBleHRlbmRgIGFuZCBgbWl4aW5gXG5cdGNvcHlPd25Qcm9wcyhzdXBlckNsYXNzLCBzdWJDbGFzcyk7XG5cblx0cmV0dXJuIHN1YkNsYXNzO1xufVxuXG5cbmZ1bmN0aW9uIG1peEludG9DbGFzcyh0aGVDbGFzcywgbWVtYmVycykge1xuXHRjb3B5T3duUHJvcHMobWVtYmVycywgdGhlQ2xhc3MucHJvdG90eXBlKTsgLy8gVE9ETzogY29weU5hdGl2ZU1ldGhvZHM/XG59XG47O1xuXG52YXIgRW1pdHRlck1peGluID0gRkMuRW1pdHRlck1peGluID0ge1xuXG5cdC8vIGpRdWVyeS1pZmljYXRpb24gdmlhICQodGhpcykgYWxsb3dzIGEgbm9uLURPTSBvYmplY3QgdG8gaGF2ZVxuXHQvLyB0aGUgc2FtZSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMgKGluY2x1ZGluZyBuYW1lc3BhY2VzKS5cblxuXG5cdG9uOiBmdW5jdGlvbih0eXBlcywgaGFuZGxlcikge1xuXG5cdFx0Ly8gaGFuZGxlcnMgYXJlIGFsd2F5cyBjYWxsZWQgd2l0aCBhbiBcImV2ZW50XCIgb2JqZWN0IGFzIHRoZWlyIGZpcnN0IHBhcmFtLlxuXHRcdC8vIHNuZWFrIHRoZSBgdGhpc2AgY29udGV4dCBhbmQgYXJndW1lbnRzIGludG8gdGhlIGV4dHJhIHBhcmFtZXRlciBvYmplY3Rcblx0XHQvLyBhbmQgZm9yd2FyZCB0aGVtIG9uIHRvIHRoZSBvcmlnaW5hbCBoYW5kbGVyLlxuXHRcdHZhciBpbnRlcmNlcHQgPSBmdW5jdGlvbihldiwgZXh0cmEpIHtcblx0XHRcdHJldHVybiBoYW5kbGVyLmFwcGx5KFxuXHRcdFx0XHRleHRyYS5jb250ZXh0IHx8IHRoaXMsXG5cdFx0XHRcdGV4dHJhLmFyZ3MgfHwgW11cblx0XHRcdCk7XG5cdFx0fTtcblxuXHRcdC8vIG1pbWljayBqUXVlcnkncyBpbnRlcm5hbCBcInByb3h5XCIgc3lzdGVtIChyaXNreSwgSSBrbm93KVxuXHRcdC8vIGNhdXNpbmcgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIC5ndWlkIHRvIGFwcGVhciB0byBiZSB0aGUgc2FtZS5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMi40L3NyYy9jb3JlLmpzI0w0NDhcblx0XHQvLyB0aGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyAub2ZmIHdpdGggdGhlIG9yaWdpbmFsIG5vbi1pbnRlcmNlcHQgaGFuZGxlci5cblx0XHRpZiAoIWhhbmRsZXIuZ3VpZCkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0gJC5ndWlkKys7XG5cdFx0fVxuXHRcdGludGVyY2VwdC5ndWlkID0gaGFuZGxlci5ndWlkO1xuXG5cdFx0JCh0aGlzKS5vbih0eXBlcywgaW50ZXJjZXB0KTtcblxuXHRcdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcblx0fSxcblxuXG5cdG9mZjogZnVuY3Rpb24odHlwZXMsIGhhbmRsZXIpIHtcblx0XHQkKHRoaXMpLm9mZih0eXBlcywgaGFuZGxlcik7XG5cblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH0sXG5cblxuXHR0cmlnZ2VyOiBmdW5jdGlvbih0eXBlcykge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gYXJndW1lbnRzIGFmdGVyIHRoZSBmaXJzdFxuXG5cdFx0Ly8gcGFzcyBpbiBcImV4dHJhXCIgaW5mbyB0byB0aGUgaW50ZXJjZXB0XG5cdFx0JCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBhcmdzOiBhcmdzIH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuXHR9LFxuXG5cblx0dHJpZ2dlcldpdGg6IGZ1bmN0aW9uKHR5cGVzLCBjb250ZXh0LCBhcmdzKSB7XG5cblx0XHQvLyBgdHJpZ2dlckhhbmRsZXJgIGlzIGxlc3MgcmVsaWFudCBvbiB0aGUgRE9NIGNvbXBhcmVkIHRvIGB0cmlnZ2VyYC5cblx0XHQvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHQuXG5cdFx0JCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBjb250ZXh0OiBjb250ZXh0LCBhcmdzOiBhcmdzIH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuXHR9XG5cbn07XG5cbjs7XG5cbi8qXG5VdGlsaXR5IG1ldGhvZHMgZm9yIGVhc2lseSBsaXN0ZW5pbmcgdG8gZXZlbnRzIG9uIGFub3RoZXIgb2JqZWN0LFxuYW5kIG1vcmUgaW1wb3J0YW50bHksIGVhc2lseSB1bmxpc3RlbmluZyBmcm9tIHRoZW0uXG4qL1xudmFyIExpc3RlbmVyTWl4aW4gPSBGQy5MaXN0ZW5lck1peGluID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgZ3VpZCA9IDA7XG5cdHZhciBMaXN0ZW5lck1peGluID0ge1xuXG5cdFx0bGlzdGVuZXJJZDogbnVsbCxcblxuXHRcdC8qXG5cdFx0R2l2ZW4gYW4gYG90aGVyYCBvYmplY3QgdGhhdCBoYXMgb24vb2ZmIG1ldGhvZHMsIGJpbmQgdGhlIGdpdmVuIGBjYWxsYmFja2AgdG8gYW4gZXZlbnQgYnkgdGhlIGdpdmVuIG5hbWUuXG5cdFx0VGhlIGBjYWxsYmFja2Agd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIG9iamVjdCB0aGF0IC5saXN0ZW5UbyBpcyBiZWluZyBjYWxsZWQgb24uXG5cdFx0Q2FuIGJlIGNhbGxlZDpcblx0XHRcdC5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBjYWxsYmFjaylcblx0XHRPUlxuXHRcdFx0Lmxpc3RlblRvKG90aGVyLCB7XG5cdFx0XHRcdGV2ZW50TmFtZTE6IGNhbGxiYWNrMSxcblx0XHRcdFx0ZXZlbnROYW1lMjogY2FsbGJhY2syXG5cdFx0XHR9KVxuXHRcdCovXG5cdFx0bGlzdGVuVG86IGZ1bmN0aW9uKG90aGVyLCBhcmcsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHsgLy8gZ2l2ZW4gZGljdGlvbmFyeSBvZiBjYWxsYmFja3Ncblx0XHRcdFx0Zm9yICh2YXIgZXZlbnROYW1lIGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChhcmcuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBhcmdbZXZlbnROYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRvdGhlci5vbihcblx0XHRcdFx0XHRhcmcgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCksIC8vIHVzZSBldmVudCBuYW1lc3BhY2luZyB0byBpZGVudGlmeSB0aGlzIG9iamVjdFxuXHRcdFx0XHRcdCQucHJveHkoY2FsbGJhY2ssIHRoaXMpIC8vIGFsd2F5cyB1c2UgYHRoaXNgIGNvbnRleHRcblx0XHRcdFx0XHRcdC8vIHRoZSB1c3VhbGx5LXVuZGVzaXJlZCBqUXVlcnkgZ3VpZCBiZWhhdmlvciBkb2Vzbid0IG1hdHRlcixcblx0XHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgYWx3YXlzIHVuYmluZCB2aWEgbmFtZXNwYWNlXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0Q2F1c2VzIHRoZSBjdXJyZW50IG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBldmVudHMgb24gdGhlIGBvdGhlcmAgb2JqZWN0LlxuXHRcdGBldmVudE5hbWVgIGlzIG9wdGlvbmFsLiBJZiBvbWl0dGVkLCB3aWxsIHN0b3AgbGlzdGVuaW5nIHRvIEFMTCBldmVudHMgb24gYG90aGVyYC5cblx0XHQqL1xuXHRcdHN0b3BMaXN0ZW5pbmdUbzogZnVuY3Rpb24ob3RoZXIsIGV2ZW50TmFtZSkge1xuXHRcdFx0b3RoZXIub2ZmKChldmVudE5hbWUgfHwgJycpICsgJy4nICsgdGhpcy5nZXRMaXN0ZW5lck5hbWVzcGFjZSgpKTtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHRSZXR1cm5zIGEgc3RyaW5nLCB1bmlxdWUgdG8gdGhpcyBvYmplY3QsIHRvIGJlIHVzZWQgZm9yIGV2ZW50IG5hbWVzcGFjaW5nXG5cdFx0Ki9cblx0XHRnZXRMaXN0ZW5lck5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5saXN0ZW5lcklkID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5lcklkID0gZ3VpZCsrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdfbGlzdGVuZXInICsgdGhpcy5saXN0ZW5lcklkO1xuXHRcdH1cblxuXHR9O1xuXHRyZXR1cm4gTGlzdGVuZXJNaXhpbjtcbn0pKCk7XG47O1xuXG4vLyBzaW1wbGUgY2xhc3MgZm9yIHRvZ2dsZSBhIGBpc0lnbm9yaW5nTW91c2VgIGZsYWcgb24gZGVsYXlcbi8vIGluaXRNb3VzZUlnbm9yaW5nIG11c3QgZmlyc3QgYmUgY2FsbGVkLCB3aXRoIGEgbWlsbGlzZWNvbmQgZGVsYXkgc2V0dGluZy5cbnZhciBNb3VzZUlnbm9yZXJNaXhpbiA9IHtcblxuXHRpc0lnbm9yaW5nTW91c2U6IGZhbHNlLCAvLyBib29sXG5cdGRlbGF5VW5pZ25vcmVNb3VzZTogbnVsbCwgLy8gbWV0aG9kXG5cblxuXHRpbml0TW91c2VJZ25vcmluZzogZnVuY3Rpb24oZGVsYXkpIHtcblx0XHR0aGlzLmRlbGF5VW5pZ25vcmVNb3VzZSA9IGRlYm91bmNlKHByb3h5KHRoaXMsICd1bmlnbm9yZU1vdXNlJyksIGRlbGF5IHx8IDEwMDApO1xuXHR9LFxuXG5cblx0Ly8gdGVtcG9yYXJpbHkgaWdub3JlIG1vdXNlIGFjdGlvbnMgb24gc2VnbWVudHNcblx0dGVtcElnbm9yZU1vdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzSWdub3JpbmdNb3VzZSA9IHRydWU7XG5cdFx0dGhpcy5kZWxheVVuaWdub3JlTW91c2UoKTtcblx0fSxcblxuXG5cdC8vIGRlbGF5VW5pZ25vcmVNb3VzZSBldmVudHVhbGx5IGNhbGxzIHRoaXNcblx0dW5pZ25vcmVNb3VzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0lnbm9yaW5nTW91c2UgPSBmYWxzZTtcblx0fVxuXG59O1xuXG47O1xuXG4vKiBBIHJlY3Rhbmd1bGFyIHBhbmVsIHRoYXQgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIG92ZXIgb3RoZXIgY29udGVudFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5PcHRpb25zOlxuXHQtIGNsYXNzTmFtZSAoc3RyaW5nKVxuXHQtIGNvbnRlbnQgKEhUTUwgc3RyaW5nIG9yIGpRdWVyeSBlbGVtZW50IHNldClcblx0LSBwYXJlbnRFbFxuXHQtIHRvcFxuXHQtIGxlZnRcblx0LSByaWdodCAodGhlIHggY29vcmQgb2Ygd2hlcmUgdGhlIHJpZ2h0IGVkZ2Ugc2hvdWxkIGJlLiBub3QgYSBcIkNTU1wiIHJpZ2h0KVxuXHQtIGF1dG9IaWRlIChib29sZWFuKVxuXHQtIHNob3cgKGNhbGxiYWNrKVxuXHQtIGhpZGUgKGNhbGxiYWNrKVxuKi9cblxudmFyIFBvcG92ZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwge1xuXG5cdGlzSGlkZGVuOiB0cnVlLFxuXHRvcHRpb25zOiBudWxsLFxuXHRlbDogbnVsbCwgLy8gdGhlIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgcG9wb3Zlci4gZ2VuZXJhdGVkIGJ5IHRoaXMgb2JqZWN0XG5cdG1hcmdpbjogMTAsIC8vIHRoZSBzcGFjZSByZXF1aXJlZCBiZXR3ZWVuIHRoZSBwb3BvdmVyIGFuZCB0aGUgZWRnZXMgb2YgdGhlIHNjcm9sbCBjb250YWluZXJcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0fSxcblxuXG5cdC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdGlmICghdGhpcy5lbCkge1xuXHRcdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbC5zaG93KCk7XG5cdFx0XHR0aGlzLnBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBIaWRlcyB0aGUgcG9wb3ZlciwgdGhyb3VnaCBDU1MsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy5lbC5oaWRlKCk7XG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZScpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENyZWF0ZXMgYHRoaXMuZWxgIGFuZCByZW5kZXJzIGNvbnRlbnQgaW5zaWRlIG9mIGl0XG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuZWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtcG9wb3ZlclwiLz4nKVxuXHRcdFx0LmFkZENsYXNzKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdC8vIHBvc2l0aW9uIGluaXRpYWxseSB0byB0aGUgdG9wIGxlZnQgdG8gYXZvaWQgY3JlYXRpbmcgc2Nyb2xsYmFyc1xuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDBcblx0XHRcdH0pXG5cdFx0XHQuYXBwZW5kKG9wdGlvbnMuY29udGVudClcblx0XHRcdC5hcHBlbmRUbyhvcHRpb25zLnBhcmVudEVsKTtcblxuXHRcdC8vIHdoZW4gYSBjbGljayBoYXBwZW5zIG9uIGFueXRoaW5nIGluc2lkZSB3aXRoIGEgJ2ZjLWNsb3NlJyBjbGFzc05hbWUsIGhpZGUgdGhlIHBvcG92ZXJcblx0XHR0aGlzLmVsLm9uKCdjbGljaycsICcuZmMtY2xvc2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLmhpZGUoKTtcblx0XHR9KTtcblxuXHRcdGlmIChvcHRpb25zLmF1dG9IaWRlKSB7XG5cdFx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vkb3duJywgdGhpcy5kb2N1bWVudE1vdXNlZG93bik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcblx0ZG9jdW1lbnRNb3VzZWRvd246IGZ1bmN0aW9uKGV2KSB7XG5cdFx0Ly8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG5cdFx0aWYgKHRoaXMuZWwgJiYgISQoZXYudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWwpLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gSGlkZXMgYW5kIHVucmVnaXN0ZXJzIGFueSBoYW5kbGVyc1xuXHRyZW1vdmVFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhpZGUoKTtcblxuXHRcdGlmICh0aGlzLmVsKSB7XG5cdFx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5lbCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nKTtcblx0fSxcblxuXG5cdC8vIFBvc2l0aW9ucyB0aGUgcG9wb3ZlciBvcHRpbWFsbHksIHVzaW5nIHRoZSB0b3AvbGVmdC9yaWdodCBvcHRpb25zXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR2YXIgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcblx0XHR2YXIgd2lkdGggPSB0aGlzLmVsLm91dGVyV2lkdGgoKTtcblx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5lbC5vdXRlckhlaWdodCgpO1xuXHRcdHZhciB3aW5kb3dFbCA9ICQod2luZG93KTtcblx0XHR2YXIgdmlld3BvcnRFbCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLmVsKTtcblx0XHR2YXIgdmlld3BvcnRUb3A7XG5cdFx0dmFyIHZpZXdwb3J0TGVmdDtcblx0XHR2YXIgdmlld3BvcnRPZmZzZXQ7XG5cdFx0dmFyIHRvcDsgLy8gdGhlIFwicG9zaXRpb25cIiAobm90IFwib2Zmc2V0XCIpIHZhbHVlcyBmb3IgdGhlIHBvcG92ZXJcblx0XHR2YXIgbGVmdDsgLy9cblxuXHRcdC8vIGNvbXB1dGUgdG9wIGFuZCBsZWZ0XG5cdFx0dG9wID0gb3B0aW9ucy50b3AgfHwgMDtcblx0XHRpZiAob3B0aW9ucy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGxlZnQgPSBvcHRpb25zLmxlZnQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9wdGlvbnMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGVmdCA9IG9wdGlvbnMucmlnaHQgLSB3aWR0aDsgLy8gZGVyaXZlIHRoZSBsZWZ0IHZhbHVlIGZyb20gdGhlIHJpZ2h0IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bGVmdCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHZpZXdwb3J0RWwuaXMod2luZG93KSB8fCB2aWV3cG9ydEVsLmlzKGRvY3VtZW50KSkgeyAvLyBub3JtYWxpemUgZ2V0U2Nyb2xsUGFyZW50J3MgcmVzdWx0XG5cdFx0XHR2aWV3cG9ydEVsID0gd2luZG93RWw7XG5cdFx0XHR2aWV3cG9ydFRvcCA9IDA7IC8vIHRoZSB3aW5kb3cgaXMgYWx3YXlzIGF0IHRoZSB0b3AgbGVmdFxuXHRcdFx0dmlld3BvcnRMZWZ0ID0gMDsgLy8gKGFuZCAub2Zmc2V0KCkgd29uJ3Qgd29yayBpZiBjYWxsZWQgaGVyZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2aWV3cG9ydE9mZnNldCA9IHZpZXdwb3J0RWwub2Zmc2V0KCk7XG5cdFx0XHR2aWV3cG9ydFRvcCA9IHZpZXdwb3J0T2Zmc2V0LnRvcDtcblx0XHRcdHZpZXdwb3J0TGVmdCA9IHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIHdpbmRvdyBpcyBzY3JvbGxlZCwgaXQgY2F1c2VzIHRoZSB2aXNpYmxlIGFyZWEgdG8gYmUgZnVydGhlciBkb3duXG5cdFx0dmlld3BvcnRUb3AgKz0gd2luZG93RWwuc2Nyb2xsVG9wKCk7XG5cdFx0dmlld3BvcnRMZWZ0ICs9IHdpbmRvd0VsLnNjcm9sbExlZnQoKTtcblxuXHRcdC8vIGNvbnN0cmFpbiB0byB0aGUgdmlldyBwb3J0LiBpZiBjb25zdHJhaW5lZCBieSB0d28gZWRnZXMsIGdpdmUgcHJlY2VkZW5jZSB0byB0b3AvbGVmdFxuXHRcdGlmIChvcHRpb25zLnZpZXdwb3J0Q29uc3RyYWluICE9PSBmYWxzZSkge1xuXHRcdFx0dG9wID0gTWF0aC5taW4odG9wLCB2aWV3cG9ydFRvcCArIHZpZXdwb3J0RWwub3V0ZXJIZWlnaHQoKSAtIGhlaWdodCAtIHRoaXMubWFyZ2luKTtcblx0XHRcdHRvcCA9IE1hdGgubWF4KHRvcCwgdmlld3BvcnRUb3AgKyB0aGlzLm1hcmdpbik7XG5cdFx0XHRsZWZ0ID0gTWF0aC5taW4obGVmdCwgdmlld3BvcnRMZWZ0ICsgdmlld3BvcnRFbC5vdXRlcldpZHRoKCkgLSB3aWR0aCAtIHRoaXMubWFyZ2luKTtcblx0XHRcdGxlZnQgPSBNYXRoLm1heChsZWZ0LCB2aWV3cG9ydExlZnQgKyB0aGlzLm1hcmdpbik7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbC5jc3Moe1xuXHRcdFx0dG9wOiB0b3AgLSBvcmlnaW4udG9wLFxuXHRcdFx0bGVmdDogbGVmdCAtIG9yaWdpbi5sZWZ0XG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxuXHQvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cblx0Ly8gVE9ETzogYmV0dGVyIGNvZGUgcmV1c2UgZm9yIHRoaXMuIFJlcGVhdCBjb2RlXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG47O1xuXG4vKlxuQSBjYWNoZSBmb3IgdGhlIGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQgdmFsdWVzIGZvciBvbmUgb3IgbW9yZSBlbGVtZW50cy5cbldvcmtzIHdpdGggYm90aCBvZmZzZXQgKGZyb20gdG9wbGVmdCBkb2N1bWVudCkgYW5kIHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCkuXG5cbm9wdGlvbnM6XG4tIGVsc1xuLSBpc0hvcml6b250YWxcbi0gaXNWZXJ0aWNhbFxuKi9cbnZhciBDb29yZENhY2hlID0gRkMuQ29vcmRDYWNoZSA9IENsYXNzLmV4dGVuZCh7XG5cblx0ZWxzOiBudWxsLCAvLyBqUXVlcnkgc2V0IChhc3N1bWVkIHRvIGJlIHNpYmxpbmdzKVxuXHRmb3JjZWRPZmZzZXRQYXJlbnRFbDogbnVsbCwgLy8gb3B0aW9ucyBjYW4gb3ZlcnJpZGUgdGhlIG5hdHVyYWwgb2Zmc2V0UGFyZW50XG5cdG9yaWdpbjogbnVsbCwgLy8ge2xlZnQsdG9wfSBwb3NpdGlvbiBvZiBvZmZzZXRQYXJlbnQgb2YgZWxzXG5cdGJvdW5kaW5nUmVjdDogbnVsbCwgLy8gY29uc3RyYWluIGNvcmRpbmF0ZXMgdG8gdGhpcyByZWN0YW5nbGUuIHtsZWZ0LHJpZ2h0LHRvcCxib3R0b219IG9yIG51bGxcblx0aXNIb3Jpem9udGFsOiBmYWxzZSwgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgbGVmdC9yaWdodC93aWR0aFxuXHRpc1ZlcnRpY2FsOiBmYWxzZSwgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgdG9wL2JvdHRvbS9oZWlnaHRcblxuXHQvLyBhcnJheXMgb2YgY29vcmRpbmF0ZXMgKG9mZnNldHMgZnJvbSB0b3BsZWZ0IG9mIGRvY3VtZW50KVxuXHRsZWZ0czogbnVsbCxcblx0cmlnaHRzOiBudWxsLFxuXHR0b3BzOiBudWxsLFxuXHRib3R0b21zOiBudWxsLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLmVscyA9ICQob3B0aW9ucy5lbHMpO1xuXHRcdHRoaXMuaXNIb3Jpem9udGFsID0gb3B0aW9ucy5pc0hvcml6b250YWw7XG5cdFx0dGhpcy5pc1ZlcnRpY2FsID0gb3B0aW9ucy5pc1ZlcnRpY2FsO1xuXHRcdHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWwgPSBvcHRpb25zLm9mZnNldFBhcmVudCA/ICQob3B0aW9ucy5vZmZzZXRQYXJlbnQpIDogbnVsbDtcblx0fSxcblxuXG5cdC8vIFF1ZXJpZXMgdGhlIGVscyBmb3IgY29vcmRpbmF0ZXMgYW5kIHN0b3JlcyB0aGVtLlxuXHQvLyBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyBhbmQgb2YgdGhlIGdldCogbWV0aG9kcyBiZWxvdy5cblx0YnVpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvZmZzZXRQYXJlbnRFbCA9IHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWwgfHwgdGhpcy5lbHMuZXEoMCkub2Zmc2V0UGFyZW50KCk7XG5cblx0XHR0aGlzLm9yaWdpbiA9IG9mZnNldFBhcmVudEVsLm9mZnNldCgpO1xuXHRcdHRoaXMuYm91bmRpbmdSZWN0ID0gdGhpcy5xdWVyeUJvdW5kaW5nUmVjdCgpO1xuXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG5cdFx0XHR0aGlzLmJ1aWxkRWxIb3Jpem9udGFscygpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG5cdFx0XHR0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBEZXN0cm95cyBhbGwgaW50ZXJuYWwgZGF0YSBhYm91dCBjb29yZGluYXRlcywgZnJlZWluZyBtZW1vcnlcblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZ2luID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nUmVjdCA9IG51bGw7XG5cdFx0dGhpcy5sZWZ0cyA9IG51bGw7XG5cdFx0dGhpcy5yaWdodHMgPSBudWxsO1xuXHRcdHRoaXMudG9wcyA9IG51bGw7XG5cdFx0dGhpcy5ib3R0b21zID0gbnVsbDtcblx0fSxcblxuXG5cdC8vIFdoZW4gY2FsbGVkLCBpZiBjb29yZCBjYWNoZXMgYXJlbid0IGJ1aWx0LCBidWlsZHMgdGhlbVxuXHRlbnN1cmVCdWlsdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLm9yaWdpbikge1xuXHRcdFx0dGhpcy5idWlsZCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENvbXB1dGUgYW5kIHJldHVybiB3aGF0IHRoZSBlbGVtZW50cycgYm91bmRpbmcgcmVjdGFuZ2xlIGlzLCBmcm9tIHRoZSB1c2VyJ3MgcGVyc3BlY3RpdmUuXG5cdC8vIFJpZ2h0IG5vdywgb25seSByZXR1cm5zIGEgcmVjdGFuZ2xlIGlmIGNvbnN0cmFpbmVkIGJ5IGFuIG92ZXJmbG93OnNjcm9sbCBlbGVtZW50LlxuXHRxdWVyeUJvdW5kaW5nUmVjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudEVsID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWxzLmVxKDApKTtcblxuXHRcdGlmICghc2Nyb2xsUGFyZW50RWwuaXMoZG9jdW1lbnQpKSB7XG5cdFx0XHRyZXR1cm4gZ2V0Q2xpZW50UmVjdChzY3JvbGxQYXJlbnRFbCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG5cdGJ1aWxkRWxIb3Jpem9udGFsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlZnRzID0gW107XG5cdFx0dmFyIHJpZ2h0cyA9IFtdO1xuXG5cdFx0dGhpcy5lbHMuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHR2YXIgZWwgPSAkKG5vZGUpO1xuXHRcdFx0dmFyIGxlZnQgPSBlbC5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dmFyIHdpZHRoID0gZWwub3V0ZXJXaWR0aCgpO1xuXG5cdFx0XHRsZWZ0cy5wdXNoKGxlZnQpO1xuXHRcdFx0cmlnaHRzLnB1c2gobGVmdCArIHdpZHRoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMubGVmdHMgPSBsZWZ0cztcblx0XHR0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcblx0fSxcblxuXG5cdC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuXHRidWlsZEVsVmVydGljYWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG9wcyA9IFtdO1xuXHRcdHZhciBib3R0b21zID0gW107XG5cblx0XHR0aGlzLmVscy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpIHtcblx0XHRcdHZhciBlbCA9ICQobm9kZSk7XG5cdFx0XHR2YXIgdG9wID0gZWwub2Zmc2V0KCkudG9wO1xuXHRcdFx0dmFyIGhlaWdodCA9IGVsLm91dGVySGVpZ2h0KCk7XG5cblx0XHRcdHRvcHMucHVzaCh0b3ApO1xuXHRcdFx0Ym90dG9tcy5wdXNoKHRvcCArIGhlaWdodCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnRvcHMgPSB0b3BzO1xuXHRcdHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cblx0Ly8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIG9yIG91dHNpZGUgb2YgdGhlIGJvdW5kaW5nUmVjdCwgcmV0dXJucyB1bmRlZmluZWQuXG5cdGdldEhvcml6b250YWxJbmRleDogZnVuY3Rpb24obGVmdE9mZnNldCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblxuXHRcdHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmJvdW5kaW5nUmVjdDtcblx0XHR2YXIgbGVmdHMgPSB0aGlzLmxlZnRzO1xuXHRcdHZhciByaWdodHMgPSB0aGlzLnJpZ2h0cztcblx0XHR2YXIgbGVuID0gbGVmdHMubGVuZ3RoO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCFib3VuZGluZ1JlY3QgfHwgKGxlZnRPZmZzZXQgPj0gYm91bmRpbmdSZWN0LmxlZnQgJiYgbGVmdE9mZnNldCA8IGJvdW5kaW5nUmVjdC5yaWdodCkpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAobGVmdE9mZnNldCA+PSBsZWZ0c1tpXSAmJiBsZWZ0T2Zmc2V0IDwgcmlnaHRzW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuXHQvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgb3Igb3V0c2lkZSBvZiB0aGUgYm91bmRpbmdSZWN0LCByZXR1cm5zIHVuZGVmaW5lZC5cblx0Z2V0VmVydGljYWxJbmRleDogZnVuY3Rpb24odG9wT2Zmc2V0KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuYm91bmRpbmdSZWN0O1xuXHRcdHZhciB0b3BzID0gdGhpcy50b3BzO1xuXHRcdHZhciBib3R0b21zID0gdGhpcy5ib3R0b21zO1xuXHRcdHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcblx0XHR2YXIgaTtcblxuXHRcdGlmICghYm91bmRpbmdSZWN0IHx8ICh0b3BPZmZzZXQgPj0gYm91bmRpbmdSZWN0LnRvcCAmJiB0b3BPZmZzZXQgPCBib3VuZGluZ1JlY3QuYm90dG9tKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmICh0b3BPZmZzZXQgPj0gdG9wc1tpXSAmJiB0b3BPZmZzZXQgPCBib3R0b21zW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0TGVmdE9mZnNldDogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0TGVmdFBvc2l0aW9uOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSByaWdodCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXG5cdGdldFJpZ2h0T2Zmc2V0OiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSByaWdodCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgcmlnaHQgZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJyaWdodFwiIHdvdWxkIGJlLlxuXHRnZXRSaWdodFBvc2l0aW9uOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldFdpZHRoOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldFRvcE9mZnNldDogZnVuY3Rpb24odG9wSW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0b3AgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG5cdGdldFRvcFBvc2l0aW9uOiBmdW5jdGlvbih0b3BJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy50b3BzW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcblx0fSxcblxuXHQvLyBHZXRzIHRoZSBib3R0b20gb2Zmc2V0IChmcm9tIHRoZSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cblx0Ly8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxuXHRnZXRCb3R0b21PZmZzZXQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgYm90dG9tIHBvc2l0aW9uIChmcm9tIHRoZSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyBib3R0b20gZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJib3R0b21cIiB3b3VsZCBiZS5cblx0Z2V0Qm90dG9tUG9zaXRpb246IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcblx0fVxuXG59KTtcblxuOztcblxuLyogVHJhY2tzIGEgZHJhZydzIG1vdXNlIG1vdmVtZW50LCBmaXJpbmcgdmFyaW91cyBoYW5kbGVyc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBUT0RPOiB1c2UgRW1pdHRlclxuXG52YXIgRHJhZ0xpc3RlbmVyID0gRkMuRHJhZ0xpc3RlbmVyID0gQ2xhc3MuZXh0ZW5kKExpc3RlbmVyTWl4aW4sIE1vdXNlSWdub3Jlck1peGluLCB7XG5cblx0b3B0aW9uczogbnVsbCxcblxuXHQvLyBmb3IgSUU4IGJ1Zy1maWdodGluZyBiZWhhdmlvclxuXHRzdWJqZWN0RWw6IG51bGwsXG5cdHN1YmplY3RIcmVmOiBudWxsLFxuXG5cdC8vIGNvb3JkaW5hdGVzIG9mIHRoZSBpbml0aWFsIG1vdXNlZG93blxuXHRvcmlnaW5YOiBudWxsLFxuXHRvcmlnaW5ZOiBudWxsLFxuXG5cdC8vIHRoZSB3cmFwcGluZyBlbGVtZW50IHRoYXQgc2Nyb2xscywgb3IgTUlHSFQgc2Nyb2xsIGlmIHRoZXJlJ3Mgb3ZlcmZsb3cuXG5cdC8vIFRPRE86IGRvIHRoaXMgZm9yIHdyYXBwZXJzIHRoYXQgaGF2ZSBvdmVyZmxvdzpoaWRkZW4gYXMgd2VsbC5cblx0c2Nyb2xsRWw6IG51bGwsXG5cblx0aXNJbnRlcmFjdGluZzogZmFsc2UsXG5cdGlzRGlzdGFuY2VTdXJwYXNzZWQ6IGZhbHNlLFxuXHRpc0RlbGF5RW5kZWQ6IGZhbHNlLFxuXHRpc0RyYWdnaW5nOiBmYWxzZSxcblx0aXNUb3VjaDogZmFsc2UsXG5cblx0ZGVsYXk6IG51bGwsXG5cdGRlbGF5VGltZW91dElkOiBudWxsLFxuXHRtaW5EaXN0YW5jZTogbnVsbCxcblxuXHRoYW5kbGVUb3VjaFNjcm9sbFByb3h5OiBudWxsLCAvLyBjYWxscyBoYW5kbGVUb3VjaFNjcm9sbCwgYWx3YXlzIGJvdW5kIHRvIGB0aGlzYFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHRoaXMuaGFuZGxlVG91Y2hTY3JvbGxQcm94eSA9IHByb3h5KHRoaXMsICdoYW5kbGVUb3VjaFNjcm9sbCcpO1xuXHRcdHRoaXMuaW5pdE1vdXNlSWdub3JpbmcoNTAwKTtcblx0fSxcblxuXG5cdC8vIEludGVyYWN0aW9uIChoaWdoLWxldmVsKVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0c3RhcnRJbnRlcmFjdGlvbjogZnVuY3Rpb24oZXYsIGV4dHJhT3B0aW9ucykge1xuXHRcdHZhciBpc1RvdWNoID0gZ2V0RXZJc1RvdWNoKGV2KTtcblxuXHRcdGlmIChldi50eXBlID09PSAnbW91c2Vkb3duJykge1xuXHRcdFx0aWYgKHRoaXMuaXNJZ25vcmluZ01vdXNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCFpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIG5hdGl2ZSBzZWxlY3Rpb24gaW4gbW9zdCBicm93c2Vyc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc0ludGVyYWN0aW5nKSB7XG5cblx0XHRcdC8vIHByb2Nlc3Mgb3B0aW9uc1xuXHRcdFx0ZXh0cmFPcHRpb25zID0gZXh0cmFPcHRpb25zIHx8IHt9O1xuXHRcdFx0dGhpcy5kZWxheSA9IGZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGVsYXksIHRoaXMub3B0aW9ucy5kZWxheSwgMCk7XG5cdFx0XHR0aGlzLm1pbkRpc3RhbmNlID0gZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kaXN0YW5jZSwgdGhpcy5vcHRpb25zLmRpc3RhbmNlLCAwKTtcblx0XHRcdHRoaXMuc3ViamVjdEVsID0gdGhpcy5vcHRpb25zLnN1YmplY3RFbDtcblxuXHRcdFx0dGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuaXNUb3VjaCA9IGlzVG91Y2g7XG5cdFx0XHR0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG5cblx0XHRcdHRoaXMub3JpZ2luWCA9IGdldEV2WChldik7XG5cdFx0XHR0aGlzLm9yaWdpblkgPSBnZXRFdlkoZXYpO1xuXHRcdFx0dGhpcy5zY3JvbGxFbCA9IGdldFNjcm9sbFBhcmVudCgkKGV2LnRhcmdldCkpO1xuXG5cdFx0XHR0aGlzLmJpbmRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5pbml0QXV0b1Njcm9sbCgpO1xuXHRcdFx0dGhpcy5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0KGV2KTtcblx0XHRcdHRoaXMuc3RhcnREZWxheShldik7XG5cblx0XHRcdGlmICghdGhpcy5taW5EaXN0YW5jZSkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVJbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25TdGFydCcsIGV2KTtcblx0fSxcblxuXG5cdGVuZEludGVyYWN0aW9uOiBmdW5jdGlvbihldiwgaXNDYW5jZWxsZWQpIHtcblx0XHRpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XG5cdFx0XHR0aGlzLmVuZERyYWcoZXYpO1xuXG5cdFx0XHRpZiAodGhpcy5kZWxheVRpbWVvdXRJZCkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG5cdFx0XHRcdHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmRlc3Ryb3lBdXRvU2Nyb2xsKCk7XG5cdFx0XHR0aGlzLnVuYmluZEhhbmRsZXJzKCk7XG5cblx0XHRcdHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldiwgaXNDYW5jZWxsZWQpO1xuXG5cdFx0XHQvLyBhIHRvdWNoc3RhcnQrdG91Y2hlbmQgb24gdGhlIHNhbWUgZWxlbWVudCB3aWxsIHJlc3VsdCBpbiB0aGUgZm9sbG93aW5nIGFkZGl0aW9uIHNpbXVsYXRlZCBldmVudHM6XG5cdFx0XHQvLyBtb3VzZW92ZXIgKyBtb3VzZW91dCArIGNsaWNrXG5cdFx0XHQvLyBsZXQncyBpZ25vcmUgdGhlc2UgYm9ndXMgZXZlbnRzXG5cdFx0XHRpZiAodGhpcy5pc1RvdWNoKSB7XG5cdFx0XHRcdHRoaXMudGVtcElnbm9yZU1vdXNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlSW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25FbmQnLCBldiwgaXNDYW5jZWxsZWQgfHwgZmFsc2UpO1xuXHR9LFxuXG5cblx0Ly8gQmluZGluZyBUbyBET01cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGJpbmRIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdG91Y2hTdGFydElnbm9yZXMgPSAxO1xuXG5cdFx0aWYgKHRoaXMuaXNUb3VjaCkge1xuXHRcdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xuXHRcdFx0XHR0b3VjaG1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuXHRcdFx0XHR0b3VjaGVuZDogdGhpcy5lbmRJbnRlcmFjdGlvbixcblx0XHRcdFx0dG91Y2hjYW5jZWw6IHRoaXMuZW5kSW50ZXJhY3Rpb24sXG5cblx0XHRcdFx0Ly8gU29tZXRpbWVzIHRvdWNoZW5kIGRvZXNuJ3QgZmlyZVxuXHRcdFx0XHQvLyAoY2FuJ3QgZmlndXJlIG91dCB3aHkuIHRvdWNoY2FuY2VsIGRvZXNuJ3QgZmlyZSBlaXRoZXIuIGhhcyB0byBkbyB3aXRoIHNjcm9sbGluZz8pXG5cdFx0XHRcdC8vIElmIGFub3RoZXIgdG91Y2hzdGFydCBoYXBwZW5zLCB3ZSBrbm93IGl0J3MgYm9ndXMsIHNvIGNhbmNlbCB0aGUgZHJhZy5cblx0XHRcdFx0Ly8gdG91Y2hlbmQgd2lsbCBjb250aW51ZSB0byBiZSBicm9rZW4gdW50aWwgdXNlciBkb2VzIGEgc2hvcnR0YXAvc2Nyb2xsLCBidXQgdGhpcyBpcyBiZXN0IHdlIGNhbiBkby5cblx0XHRcdFx0dG91Y2hzdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRpZiAodG91Y2hTdGFydElnbm9yZXMpIHsgLy8gYmluZEhhbmRsZXJzIGlzIGNhbGxlZCBmcm9tIHdpdGhpbiBhIHRvdWNoc3RhcnQsXG5cdFx0XHRcdFx0XHR0b3VjaFN0YXJ0SWdub3Jlcy0tOyAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0aGlzIHRvIGZpcmUgaW1tZWRpYXRlbHksIHNvIGlnbm9yZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5lbmRJbnRlcmFjdGlvbihldiwgdHJ1ZSk7IC8vIGlzQ2FuY2VsbGVkPXRydWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBsaXN0ZW4gdG8gQUxMIHNjcm9sbCBhY3Rpb25zIG9uIHRoZSBwYWdlXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFiaW5kQW55U2Nyb2xsKHRoaXMuaGFuZGxlVG91Y2hTY3JvbGxQcm94eSkgJiYgLy8gaG9wZWZ1bGx5IHRoaXMgd29ya3MgYW5kIHNob3J0LWNpcmN1aXRzIHRoZSByZXN0XG5cdFx0XHRcdHRoaXMuc2Nyb2xsRWwgLy8gb3RoZXJ3aXNlLCBhdHRhY2ggYSBzaW5nbGUgaGFuZGxlciB0byB0aGlzXG5cdFx0XHQpIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLnNjcm9sbEVsLCAnc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xuXHRcdFx0XHRtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxuXHRcdFx0XHRtb3VzZXVwOiB0aGlzLmVuZEludGVyYWN0aW9uXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XG5cdFx0XHRzZWxlY3RzdGFydDogcHJldmVudERlZmF1bHQsIC8vIGRvbid0IGFsbG93IHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZ1xuXHRcdFx0Y29udGV4dG1lbnU6IHByZXZlbnREZWZhdWx0IC8vIGxvbmcgdGFwcyB3b3VsZCBvcGVuIG1lbnUgb24gQ2hyb21lIGRldiB0b29sc1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0dW5iaW5kSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcblxuXHRcdC8vIHVuYmluZCBzY3JvbGwgbGlzdGVuaW5nXG5cdFx0dW5iaW5kQW55U2Nyb2xsKHRoaXMuaGFuZGxlVG91Y2hTY3JvbGxQcm94eSk7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsRWwpIHtcblx0XHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuc2Nyb2xsRWwsICdzY3JvbGwnKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBEcmFnIChoaWdoLWxldmVsKVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gZXh0cmFPcHRpb25zIGlnbm9yZWQgaWYgZHJhZyBhbHJlYWR5IHN0YXJ0ZWRcblx0c3RhcnREcmFnOiBmdW5jdGlvbihldiwgZXh0cmFPcHRpb25zKSB7XG5cdFx0dGhpcy5zdGFydEludGVyYWN0aW9uKGV2LCBleHRyYU9wdGlvbnMpOyAvLyBlbnN1cmUgaW50ZXJhY3Rpb24gYmVnYW5cblxuXHRcdGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5oYW5kbGVEcmFnU3RhcnQoZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZURyYWdTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWdTdGFydCcsIGV2KTtcblx0XHR0aGlzLmluaXRIcmVmSGFjaygpO1xuXHR9LFxuXG5cblx0aGFuZGxlTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgZHggPSBnZXRFdlgoZXYpIC0gdGhpcy5vcmlnaW5YO1xuXHRcdHZhciBkeSA9IGdldEV2WShldikgLSB0aGlzLm9yaWdpblk7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcblx0XHR2YXIgZGlzdGFuY2VTcTsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcblxuXHRcdGlmICghdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG5cdFx0XHRkaXN0YW5jZVNxID0gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0XHRpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7IC8vIHVzZSBweXRoYWdvcmVhbiB0aGVvcmVtXG5cdFx0XHRcdHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuaGFuZGxlRHJhZyhkeCwgZHksIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hpbGUgdGhlIG1vdXNlIGlzIGJlaW5nIG1vdmVkIGFuZCB3aGVuIHdlIGtub3cgYSBsZWdpdGltYXRlIGRyYWcgaXMgdGFraW5nIHBsYWNlXG5cdGhhbmRsZURyYWc6IGZ1bmN0aW9uKGR4LCBkeSwgZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWcnLCBkeCwgZHksIGV2KTtcblx0XHR0aGlzLnVwZGF0ZUF1dG9TY3JvbGwoZXYpOyAvLyB3aWxsIHBvc3NpYmx5IGNhdXNlIHNjcm9sbGluZ1xuXHR9LFxuXG5cblx0ZW5kRHJhZzogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFuZGxlRHJhZ0VuZChldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlRHJhZ0VuZDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWdFbmQnLCBldik7XG5cdFx0dGhpcy5kZXN0cm95SHJlZkhhY2soKTtcblx0fSxcblxuXG5cdC8vIERlbGF5XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzdGFydERlbGF5OiBmdW5jdGlvbihpbml0aWFsRXYpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMuZGVsYXkpIHtcblx0XHRcdHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xuXHRcdFx0fSwgdGhpcy5kZWxheSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZURlbGF5RW5kOiBmdW5jdGlvbihpbml0aWFsRXYpIHtcblx0XHR0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG5cdFx0XHR0aGlzLnN0YXJ0RHJhZyhpbml0aWFsRXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIERpc3RhbmNlXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMuaXNEZWxheUVuZGVkKSB7XG5cdFx0XHR0aGlzLnN0YXJ0RHJhZyhldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gTW91c2UgLyBUb3VjaFxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aGFuZGxlVG91Y2hNb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdC8vIHByZXZlbnQgaW5lcnRpYSBhbmQgdG91Y2htb3ZlLXNjcm9sbGluZyB3aGlsZSBkcmFnZ2luZ1xuXHRcdGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYW5kbGVNb3ZlKGV2KTtcblx0fSxcblxuXG5cdGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLmhhbmRsZU1vdmUoZXYpO1xuXHR9LFxuXG5cblx0Ly8gU2Nyb2xsaW5nICh1bnJlbGF0ZWQgdG8gYXV0by1zY3JvbGwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRoYW5kbGVUb3VjaFNjcm9sbDogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBpZiB0aGUgZHJhZyBpcyBiZWluZyBpbml0aWF0ZWQgYnkgdG91Y2gsIGJ1dCBhIHNjcm9sbCBoYXBwZW5zIGJlZm9yZVxuXHRcdC8vIHRoZSBkcmFnLWluaXRpYXRpbmcgZGVsYXkgaXMgb3ZlciwgY2FuY2VsIHRoZSBkcmFnXG5cdFx0aWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuZW5kSW50ZXJhY3Rpb24oZXYsIHRydWUpOyAvLyBpc0NhbmNlbGxlZD10cnVlXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gPEE+IEhSRUYgSGFja1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aW5pdEhyZWZIYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3ViamVjdEVsID0gdGhpcy5zdWJqZWN0RWw7XG5cblx0XHQvLyByZW1vdmUgYSBtb3VzZWRvd24nZCA8YT4ncyBocmVmIHNvIGl0IGlzIG5vdCB2aXNpdGVkIChJRTggYnVnKVxuXHRcdGlmICgodGhpcy5zdWJqZWN0SHJlZiA9IHN1YmplY3RFbCA/IHN1YmplY3RFbC5hdHRyKCdocmVmJykgOiBudWxsKSkge1xuXHRcdFx0c3ViamVjdEVsLnJlbW92ZUF0dHIoJ2hyZWYnKTtcblx0XHR9XG5cdH0sXG5cblxuXHRkZXN0cm95SHJlZkhhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdWJqZWN0RWwgPSB0aGlzLnN1YmplY3RFbDtcblx0XHR2YXIgc3ViamVjdEhyZWYgPSB0aGlzLnN1YmplY3RIcmVmO1xuXG5cdFx0Ly8gcmVzdG9yZSBhIG1vdXNlZG93bidkIDxhPidzIGhyZWYgKGZvciBJRTggYnVnKVxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IC8vIG11c3QgYmUgb3V0c2lkZSBvZiB0aGUgY2xpY2sncyBleGVjdXRpb25cblx0XHRcdGlmIChzdWJqZWN0SHJlZikge1xuXHRcdFx0XHRzdWJqZWN0RWwuYXR0cignaHJlZicsIHN1YmplY3RIcmVmKTtcblx0XHRcdH1cblx0XHR9LCAwKTtcblx0fSxcblxuXG5cdC8vIFV0aWxzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxuXHQvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cblx0dHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcblx0XHRcdHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdFx0Ly8gbWFrZXMgX21ldGhvZHMgY2FsbGFibGUgYnkgZXZlbnQgbmFtZS4gVE9ETzoga2lsbCB0aGlzXG5cdFx0aWYgKHRoaXNbJ18nICsgbmFtZV0pIHtcblx0XHRcdHRoaXNbJ18nICsgbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9XG5cblxufSk7XG5cbjs7XG4vKlxudGhpcy5zY3JvbGxFbCBpcyBzZXQgaW4gRHJhZ0xpc3RlbmVyXG4qL1xuRHJhZ0xpc3RlbmVyLm1peGluKHtcblxuXHRpc0F1dG9TY3JvbGw6IGZhbHNlLFxuXG5cdHNjcm9sbEJvdW5kczogbnVsbCwgLy8geyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfVxuXHRzY3JvbGxUb3BWZWw6IG51bGwsIC8vIHBpeGVscyBwZXIgc2Vjb25kXG5cdHNjcm9sbExlZnRWZWw6IG51bGwsIC8vIHBpeGVscyBwZXIgc2Vjb25kXG5cdHNjcm9sbEludGVydmFsSWQ6IG51bGwsIC8vIElEIG9mIHNldFRpbWVvdXQgZm9yIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxuXG5cdC8vIGRlZmF1bHRzXG5cdHNjcm9sbFNlbnNpdGl2aXR5OiAzMCwgLy8gcGl4ZWxzIGZyb20gZWRnZSBmb3Igc2Nyb2xsaW5nIHRvIHN0YXJ0XG5cdHNjcm9sbFNwZWVkOiAyMDAsIC8vIHBpeGVscyBwZXIgc2Vjb25kLCBhdCBtYXhpbXVtIHNwZWVkXG5cdHNjcm9sbEludGVydmFsTXM6IDUwLCAvLyBtaWxsaXNlY29uZCB3YWl0IGJldHdlZW4gc2Nyb2xsIGluY3JlbWVudFxuXG5cblx0aW5pdEF1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxFbCA9IHRoaXMuc2Nyb2xsRWw7XG5cblx0XHR0aGlzLmlzQXV0b1Njcm9sbCA9XG5cdFx0XHR0aGlzLm9wdGlvbnMuc2Nyb2xsICYmXG5cdFx0XHRzY3JvbGxFbCAmJlxuXHRcdFx0IXNjcm9sbEVsLmlzKHdpbmRvdykgJiZcblx0XHRcdCFzY3JvbGxFbC5pcyhkb2N1bWVudCk7XG5cblx0XHRpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcblx0XHRcdC8vIGRlYm91bmNlIG1ha2VzIHN1cmUgcmFwaWQgY2FsbHMgZG9uJ3QgaGFwcGVuXG5cdFx0XHR0aGlzLmxpc3RlblRvKHNjcm9sbEVsLCAnc2Nyb2xsJywgZGVib3VuY2UodGhpcy5oYW5kbGVEZWJvdW5jZWRTY3JvbGwsIDEwMCkpO1xuXHRcdH1cblx0fSxcblxuXG5cdGRlc3Ryb3lBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVuZEF1dG9TY3JvbGwoKTsgLy8ga2lsbCBhbnkgYW5pbWF0aW9uIGxvb3BcblxuXHRcdC8vIHJlbW92ZSB0aGUgc2Nyb2xsIGhhbmRsZXIgaWYgdGhlcmUgaXMgYSBzY3JvbGxFbFxuXHRcdGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xuXHRcdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5zY3JvbGxFbCwgJ3Njcm9sbCcpOyAvLyB3aWxsIHByb2JhYmx5IGdldCByZW1vdmVkIGJ5IHVuYmluZEhhbmRsZXJzIHRvbyA6KFxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGFuZCBzdG9yZXMgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBzY3JvbGxFbFxuXHRjb21wdXRlU2Nyb2xsQm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcblx0XHRcdHRoaXMuc2Nyb2xsQm91bmRzID0gZ2V0T3V0ZXJSZWN0KHRoaXMuc2Nyb2xsRWwpO1xuXHRcdFx0Ly8gVE9ETzogdXNlIGdldENsaWVudFJlY3QgaW4gZnV0dXJlLiBidXQgcHJldmVudHMgYXV0byBzY3JvbGxpbmcgd2hlbiBvbiB0b3Agb2Ygc2Nyb2xsYmFyc1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnZ2luZyBpcyBpbiBwcm9ncmVzcyBhbmQgc2Nyb2xsaW5nIHNob3VsZCBiZSB1cGRhdGVkXG5cdHVwZGF0ZUF1dG9TY3JvbGw6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHNlbnNpdGl2aXR5ID0gdGhpcy5zY3JvbGxTZW5zaXRpdml0eTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5zY3JvbGxCb3VuZHM7XG5cdFx0dmFyIHRvcENsb3NlbmVzcywgYm90dG9tQ2xvc2VuZXNzO1xuXHRcdHZhciBsZWZ0Q2xvc2VuZXNzLCByaWdodENsb3NlbmVzcztcblx0XHR2YXIgdG9wVmVsID0gMDtcblx0XHR2YXIgbGVmdFZlbCA9IDA7XG5cblx0XHRpZiAoYm91bmRzKSB7IC8vIG9ubHkgc2Nyb2xsIGlmIHNjcm9sbEVsIGV4aXN0c1xuXG5cdFx0XHQvLyBjb21wdXRlIGNsb3NlbmVzcyB0byBlZGdlcy4gdmFsaWQgcmFuZ2UgaXMgZnJvbSAwLjAgLSAxLjBcblx0XHRcdHRvcENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChnZXRFdlkoZXYpIC0gYm91bmRzLnRvcCkpIC8gc2Vuc2l0aXZpdHk7XG5cdFx0XHRib3R0b21DbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLmJvdHRvbSAtIGdldEV2WShldikpKSAvIHNlbnNpdGl2aXR5O1xuXHRcdFx0bGVmdENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChnZXRFdlgoZXYpIC0gYm91bmRzLmxlZnQpKSAvIHNlbnNpdGl2aXR5O1xuXHRcdFx0cmlnaHRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLnJpZ2h0IC0gZ2V0RXZYKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSB2ZXJ0aWNhbCBjbG9zZW5lc3MgaW50byB2ZWxvY2l0eS5cblx0XHRcdC8vIG1vdXNlIG11c3QgYmUgY29tcGxldGVseSBpbiBib3VuZHMgZm9yIHZlbG9jaXR5IHRvIGhhcHBlbi5cblx0XHRcdGlmICh0b3BDbG9zZW5lc3MgPj0gMCAmJiB0b3BDbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHR0b3BWZWwgPSB0b3BDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIHVwXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChib3R0b21DbG9zZW5lc3MgPj0gMCAmJiBib3R0b21DbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHR0b3BWZWwgPSBib3R0b21DbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmFuc2xhdGUgaG9yaXpvbnRhbCBjbG9zZW5lc3MgaW50byB2ZWxvY2l0eVxuXHRcdFx0aWYgKGxlZnRDbG9zZW5lc3MgPj0gMCAmJiBsZWZ0Q2xvc2VuZXNzIDw9IDEpIHtcblx0XHRcdFx0bGVmdFZlbCA9IGxlZnRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIGxlZnRcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHJpZ2h0Q2xvc2VuZXNzID49IDAgJiYgcmlnaHRDbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHRsZWZ0VmVsID0gcmlnaHRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2V0U2Nyb2xsVmVsKHRvcFZlbCwgbGVmdFZlbCk7XG5cdH0sXG5cblxuXHQvLyBTZXRzIHRoZSBzcGVlZC1vZi1zY3JvbGxpbmcgZm9yIHRoZSBzY3JvbGxFbFxuXHRzZXRTY3JvbGxWZWw6IGZ1bmN0aW9uKHRvcFZlbCwgbGVmdFZlbCkge1xuXG5cdFx0dGhpcy5zY3JvbGxUb3BWZWwgPSB0b3BWZWw7XG5cdFx0dGhpcy5zY3JvbGxMZWZ0VmVsID0gbGVmdFZlbDtcblxuXHRcdHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIG1hc3NhZ2VzIGludG8gcmVhbGlzdGljIHZhbHVlc1xuXG5cdFx0Ly8gaWYgdGhlcmUgaXMgbm9uLXplcm8gdmVsb2NpdHksIGFuZCBhbiBhbmltYXRpb24gbG9vcCBoYXNuJ3QgYWxyZWFkeSBzdGFydGVkLCB0aGVuIFNUQVJUXG5cdFx0aWYgKCh0aGlzLnNjcm9sbFRvcFZlbCB8fCB0aGlzLnNjcm9sbExlZnRWZWwpICYmICF0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcblx0XHRcdHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKFxuXHRcdFx0XHRwcm94eSh0aGlzLCAnc2Nyb2xsSW50ZXJ2YWxGdW5jJyksIC8vIHNjb3BlIHRvIGB0aGlzYFxuXHRcdFx0XHR0aGlzLnNjcm9sbEludGVydmFsTXNcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gRm9yY2VzIHNjcm9sbFRvcFZlbCBhbmQgc2Nyb2xsTGVmdFZlbCB0byBiZSB6ZXJvIGlmIHNjcm9sbGluZyBoYXMgYWxyZWFkeSBnb25lIGFsbCB0aGUgd2F5XG5cdGNvbnN0cmFpblNjcm9sbFZlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcblxuXHRcdGlmICh0aGlzLnNjcm9sbFRvcFZlbCA8IDApIHsgLy8gc2Nyb2xsaW5nIHVwP1xuXHRcdFx0aWYgKGVsLnNjcm9sbFRvcCgpIDw9IDApIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSB1cD9cblx0XHRcdFx0dGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnNjcm9sbFRvcFZlbCA+IDApIHsgLy8gc2Nyb2xsaW5nIGRvd24/XG5cdFx0XHRpZiAoZWwuc2Nyb2xsVG9wKCkgKyBlbFswXS5jbGllbnRIZWlnaHQgPj0gZWxbMF0uc2Nyb2xsSGVpZ2h0KSB7IC8vIGFscmVhZHkgc2Nyb2xsZWQgYWxsIHRoZSB3YXkgZG93bj9cblx0XHRcdFx0dGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPCAwKSB7IC8vIHNjcm9sbGluZyBsZWZ0P1xuXHRcdFx0aWYgKGVsLnNjcm9sbExlZnQoKSA8PSAwKSB7IC8vIGFscmVhZHkgc2Nyb2xsZWQgYWxsIHRoZSBsZWZ0P1xuXHRcdFx0XHR0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPiAwKSB7IC8vIHNjcm9sbGluZyByaWdodD9cblx0XHRcdGlmIChlbC5zY3JvbGxMZWZ0KCkgKyBlbFswXS5jbGllbnRXaWR0aCA+PSBlbFswXS5zY3JvbGxXaWR0aCkgeyAvLyBhbHJlYWR5IHNjcm9sbGVkIGFsbCB0aGUgd2F5IHJpZ2h0P1xuXHRcdFx0XHR0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXG5cdHNjcm9sbEludGVydmFsRnVuYzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcblx0XHR2YXIgZnJhYyA9IHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyAvIDEwMDA7IC8vIGNvbnNpZGVyaW5nIGFuaW1hdGlvbiBmcmVxdWVuY3ksIHdoYXQgdGhlIHZlbCBzaG91bGQgYmUgbXVsdCdkIGJ5XG5cblx0XHQvLyBjaGFuZ2UgdGhlIHZhbHVlIG9mIHNjcm9sbEVsJ3Mgc2Nyb2xsXG5cdFx0aWYgKHRoaXMuc2Nyb2xsVG9wVmVsKSB7XG5cdFx0XHRlbC5zY3JvbGxUb3AoZWwuc2Nyb2xsVG9wKCkgKyB0aGlzLnNjcm9sbFRvcFZlbCAqIGZyYWMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5zY3JvbGxMZWZ0VmVsKSB7XG5cdFx0XHRlbC5zY3JvbGxMZWZ0KGVsLnNjcm9sbExlZnQoKSArIHRoaXMuc2Nyb2xsTGVmdFZlbCAqIGZyYWMpO1xuXHRcdH1cblxuXHRcdHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIHNpbmNlIHRoZSBzY3JvbGwgdmFsdWVzIGNoYW5nZWQsIHJlY29tcHV0ZSB0aGUgdmVsb2NpdGllc1xuXG5cdFx0Ly8gaWYgc2Nyb2xsZWQgYWxsIHRoZSB3YXksIHdoaWNoIGNhdXNlcyB0aGUgdmVscyB0byBiZSB6ZXJvLCBzdG9wIHRoZSBhbmltYXRpb24gbG9vcFxuXHRcdGlmICghdGhpcy5zY3JvbGxUb3BWZWwgJiYgIXRoaXMuc2Nyb2xsTGVmdFZlbCkge1xuXHRcdFx0dGhpcy5lbmRBdXRvU2Nyb2xsKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gS2lsbHMgYW55IGV4aXN0aW5nIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxuXHRlbmRBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCk7XG5cdFx0XHR0aGlzLnNjcm9sbEludGVydmFsSWQgPSBudWxsO1xuXG5cdFx0XHR0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdldCBjYWxsZWQgd2hlbiB0aGUgc2Nyb2xsRWwgaXMgc2Nyb2xsZWQgKE5PVEU6IHRoaXMgaXMgZGVsYXllZCB2aWEgZGVib3VuY2UpXG5cdGhhbmRsZURlYm91bmNlZFNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gcmVjb21wdXRlIGFsbCBjb29yZGluYXRlcywgYnV0ICpvbmx5KiBpZiB0aGlzIGlzICpub3QqIHBhcnQgb2Ygb3VyIHNjcm9sbGluZyBhbmltYXRpb25cblx0XHRpZiAoIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xuXHRcdFx0dGhpcy5oYW5kbGVTY3JvbGxFbmQoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXG5cdGhhbmRsZVNjcm9sbEVuZDogZnVuY3Rpb24oKSB7XG5cdH1cblxufSk7XG47O1xuXG4vKiBUcmFja3MgbW91c2UgbW92ZW1lbnRzIG92ZXIgYSBjb21wb25lbnQgYW5kIHJhaXNlcyBldmVudHMgYWJvdXQgd2hpY2ggaGl0IHRoZSBtb3VzZSBpcyBvdmVyLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5vcHRpb25zOlxuLSBzdWJqZWN0RWxcbi0gc3ViamVjdENlbnRlclxuKi9cblxudmFyIEhpdERyYWdMaXN0ZW5lciA9IERyYWdMaXN0ZW5lci5leHRlbmQoe1xuXG5cdGNvbXBvbmVudDogbnVsbCwgLy8gY29udmVydHMgY29vcmRpbmF0ZXMgdG8gaGl0c1xuXHRcdC8vIG1ldGhvZHM6IHByZXBhcmVIaXRzLCByZWxlYXNlSGl0cywgcXVlcnlIaXRcblxuXHRvcmlnSGl0OiBudWxsLCAvLyB0aGUgaGl0IHRoZSBtb3VzZSB3YXMgb3ZlciB3aGVuIGxpc3RlbmluZyBzdGFydGVkXG5cdGhpdDogbnVsbCwgLy8gdGhlIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxuXHRjb29yZEFkanVzdDogbnVsbCwgLy8gZGVsdGEgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtb3VzZSBjb29yZGluYXRlcyB3aGVuIGNvbXB1dGluZyBjb2xsaXNpb25zXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0RHJhZ0xpc3RlbmVyLmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIGNhbGwgdGhlIHN1cGVyLWNvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxuXHQvLyBldiBtaWdodCBiZSB1bmRlZmluZWQgaWYgZHJhZ2dpbmcgd2FzIHN0YXJ0ZWQgbWFudWFsbHkuXG5cdGhhbmRsZUludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xuXHRcdHZhciBzdWJqZWN0UmVjdDtcblx0XHR2YXIgb3JpZ1BvaW50O1xuXHRcdHZhciBwb2ludDtcblxuXHRcdHRoaXMuY29tcHV0ZUNvb3JkcygpO1xuXG5cdFx0aWYgKGV2KSB7XG5cdFx0XHRvcmlnUG9pbnQgPSB7IGxlZnQ6IGdldEV2WChldiksIHRvcDogZ2V0RXZZKGV2KSB9O1xuXHRcdFx0cG9pbnQgPSBvcmlnUG9pbnQ7XG5cblx0XHRcdC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdGlmIChzdWJqZWN0RWwpIHtcblx0XHRcdFx0c3ViamVjdFJlY3QgPSBnZXRPdXRlclJlY3Qoc3ViamVjdEVsKTsgLy8gdXNlZCBmb3IgY2VudGVyaW5nIGFzIHdlbGxcblx0XHRcdFx0cG9pbnQgPSBjb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9yaWdIaXQgPSB0aGlzLnF1ZXJ5SGl0KHBvaW50LmxlZnQsIHBvaW50LnRvcCk7XG5cblx0XHRcdC8vIHRyZWF0IHRoZSBjZW50ZXIgb2YgdGhlIHN1YmplY3QgYXMgdGhlIGNvbGxpc2lvbiBwb2ludD9cblx0XHRcdGlmIChzdWJqZWN0RWwgJiYgdGhpcy5vcHRpb25zLnN1YmplY3RDZW50ZXIpIHtcblxuXHRcdFx0XHQvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxuXHRcdFx0XHQvLyBUT0RPOiBza2lwIHRoaXMgaWYgaGl0IGRpZG4ndCBzdXBwbHkgbGVmdC9yaWdodC90b3AvYm90dG9tXG5cdFx0XHRcdGlmICh0aGlzLm9yaWdIaXQpIHtcblx0XHRcdFx0XHRzdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XG5cdFx0XHRcdFx0XHRzdWJqZWN0UmVjdDsgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb25cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvaW50ID0gZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY29vcmRBZGp1c3QgPSBkaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMub3JpZ0hpdCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvb3JkQWRqdXN0ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBjYWxsIHRoZSBzdXBlci1tZXRob2QuIGRvIGl0IGFmdGVyIG9yaWdIaXQgaGFzIGJlZW4gY29tcHV0ZWRcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXG5cdC8vIFJlY29tcHV0ZXMgdGhlIGRyYWctY3JpdGljYWwgcG9zaXRpb25zIG9mIGVsZW1lbnRzXG5cdGNvbXB1dGVDb29yZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XG5cdFx0dGhpcy5jb21wdXRlU2Nyb2xsQm91bmRzKCk7IC8vIHdoeSBpcyB0aGlzIGhlcmU/Pz8/Pz9cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBhY3R1YWwgZHJhZyBoYXMgc3RhcnRlZFxuXHRoYW5kbGVEcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGhpdDtcblxuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXG5cdFx0Ly8gbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhpcy5vcmlnSGl0IGlmIHRoZSBtaW4tZGlzdGFuY2UgaXMgbGFyZ2Vcblx0XHRoaXQgPSB0aGlzLnF1ZXJ5SGl0KGdldEV2WChldiksIGdldEV2WShldikpO1xuXG5cdFx0Ly8gcmVwb3J0IHRoZSBpbml0aWFsIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxuXHRcdC8vIGVzcGVjaWFsbHkgaW1wb3J0YW50IGlmIG5vIG1pbi1kaXN0YW5jZSBhbmQgZHJhZyBzdGFydHMgaW1tZWRpYXRlbHlcblx0XHRpZiAoaGl0KSB7XG5cdFx0XHR0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZyBtb3Zlc1xuXHRoYW5kbGVEcmFnOiBmdW5jdGlvbihkeCwgZHksIGV2KSB7XG5cdFx0dmFyIGhpdDtcblxuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdGhpdCA9IHRoaXMucXVlcnlIaXQoZ2V0RXZYKGV2KSwgZ2V0RXZZKGV2KSk7XG5cblx0XHRpZiAoIWlzSGl0c0VxdWFsKGhpdCwgdGhpcy5oaXQpKSB7IC8vIGEgZGlmZmVyZW50IGhpdCB0aGFuIGJlZm9yZT9cblx0XHRcdGlmICh0aGlzLmhpdCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUhpdE91dCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhpdCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBkcmFnZ2luZyBoYXMgYmVlbiBzdG9wcGVkXG5cdGhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG92ZXIgYSBuZXcgaGl0XG5cdGhhbmRsZUhpdE92ZXI6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHZhciBpc09yaWcgPSBpc0hpdHNFcXVhbChoaXQsIHRoaXMub3JpZ0hpdCk7XG5cblx0XHR0aGlzLmhpdCA9IGhpdDtcblxuXHRcdHRoaXMudHJpZ2dlcignaGl0T3ZlcicsIHRoaXMuaGl0LCBpc09yaWcsIHRoaXMub3JpZ0hpdCk7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3V0IG9mIGEgaGl0XG5cdGhhbmRsZUhpdE91dDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpdE91dCcsIHRoaXMuaGl0KTtcblx0XHRcdHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xuXHRcdFx0dGhpcy5oaXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCBhZnRlciBhIGhpdE91dC4gQWxzbyBjYWxsZWQgYmVmb3JlIGEgZHJhZ1N0b3Bcblx0aGFuZGxlSGl0RG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpdERvbmUnLCB0aGlzLmhpdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGludGVyYWN0aW9uIGVuZHMsIHdoZXRoZXIgdGhlcmUgd2FzIGEgcmVhbCBkcmFnIG9yIG5vdFxuXHRoYW5kbGVJbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oKSB7XG5cdFx0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdHRoaXMub3JpZ0hpdCA9IG51bGw7XG5cdFx0dGhpcy5oaXQgPSBudWxsO1xuXG5cdFx0dGhpcy5jb21wb25lbnQucmVsZWFzZUhpdHMoKTtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcblx0aGFuZGxlU2Nyb2xsRW5kOiBmdW5jdGlvbigpIHtcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdHRoaXMuY29tcHV0ZUNvb3JkcygpOyAvLyBoaXRzJyBhYnNvbHV0ZSBwb3NpdGlvbnMgd2lsbCBiZSBpbiBuZXcgcGxhY2VzLiByZWNvbXB1dGVcblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIGhpdCB1bmRlcm5lYXRoIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIG1vdXNlIGV2ZW50XG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcblxuXHRcdGlmICh0aGlzLmNvb3JkQWRqdXN0KSB7XG5cdFx0XHRsZWZ0ICs9IHRoaXMuY29vcmRBZGp1c3QubGVmdDtcblx0XHRcdHRvcCArPSB0aGlzLmNvb3JkQWRqdXN0LnRvcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb25lbnQucXVlcnlIaXQobGVmdCwgdG9wKTtcblx0fVxuXG59KTtcblxuXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGl0cyBhcmUgaWRlbnRpY2FsbHkgZXF1YWwuIGBmYWxzZWAgb3RoZXJ3aXNlLiBNdXN0IGJlIGZyb20gdGhlIHNhbWUgY29tcG9uZW50LlxuLy8gVHdvIG51bGwgdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBlcXVhbCwgYXMgdHdvIFwib3V0IG9mIHRoZSBjb21wb25lbnRcIiBzdGF0ZXMgYXJlIHRoZSBzYW1lLlxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuXG5cdGlmICghaGl0MCAmJiAhaGl0MSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGhpdDAgJiYgaGl0MSkge1xuXHRcdHJldHVybiBoaXQwLmNvbXBvbmVudCA9PT0gaGl0MS5jb21wb25lbnQgJiZcblx0XHRcdGlzSGl0UHJvcHNXaXRoaW4oaGl0MCwgaGl0MSkgJiZcblx0XHRcdGlzSGl0UHJvcHNXaXRoaW4oaGl0MSwgaGl0MCk7IC8vIGVuc3VyZXMgYWxsIHByb3BzIGFyZSBpZGVudGljYWxcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHN1YkhpdCdzIG5vbi1zdGFuZGFyZCBwcm9wZXJ0aWVzIGFyZSB3aXRoaW4gc3VwZXJIaXRcbmZ1bmN0aW9uIGlzSGl0UHJvcHNXaXRoaW4oc3ViSGl0LCBzdXBlckhpdCkge1xuXHRmb3IgKHZhciBwcm9wTmFtZSBpbiBzdWJIaXQpIHtcblx0XHRpZiAoIS9eKGNvbXBvbmVudHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20pJC8udGVzdChwcm9wTmFtZSkpIHtcblx0XHRcdGlmIChzdWJIaXRbcHJvcE5hbWVdICE9PSBzdXBlckhpdFtwcm9wTmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuOztcblxuLyogQ3JlYXRlcyBhIGNsb25lIG9mIGFuIGVsZW1lbnQgYW5kIGxldHMgaXQgdHJhY2sgdGhlIG1vdXNlIGFzIGl0IG1vdmVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIE1vdXNlRm9sbG93ZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwge1xuXG5cdG9wdGlvbnM6IG51bGwsXG5cblx0c291cmNlRWw6IG51bGwsIC8vIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBjbG9uZWQgYW5kIG1hZGUgdG8gbG9vayBsaWtlIGl0IGlzIGRyYWdnaW5nXG5cdGVsOiBudWxsLCAvLyB0aGUgY2xvbmUgb2YgYHNvdXJjZUVsYCB0aGF0IHdpbGwgdHJhY2sgdGhlIG1vdXNlXG5cdHBhcmVudEVsOiBudWxsLCAvLyB0aGUgZWxlbWVudCB0aGF0IGBlbGAgKHRoZSBjbG9uZSkgd2lsbCBiZSBhdHRhY2hlZCB0b1xuXG5cdC8vIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIGVsLCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0IHBhcmVudC4gbWFkZSB0byBtYXRjaCB0aGUgaW5pdGlhbCBvZmZzZXQgb2Ygc291cmNlRWxcblx0dG9wMDogbnVsbCxcblx0bGVmdDA6IG51bGwsXG5cblx0Ly8gdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbml0aWF0aW5nIHRvdWNoL21vdXNlIGFjdGlvblxuXHR5MDogbnVsbCxcblx0eDA6IG51bGwsXG5cblx0Ly8gdGhlIG51bWJlciBvZiBwaXhlbHMgdGhlIG1vdXNlIGhhcyBtb3ZlZCBmcm9tIGl0cyBpbml0aWFsIHBvc2l0aW9uXG5cdHRvcERlbHRhOiBudWxsLFxuXHRsZWZ0RGVsdGE6IG51bGwsXG5cblx0aXNGb2xsb3dpbmc6IGZhbHNlLFxuXHRpc0hpZGRlbjogZmFsc2UsXG5cdGlzQW5pbWF0aW5nOiBmYWxzZSwgLy8gZG9pbmcgdGhlIHJldmVydCBhbmltYXRpb24/XG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHNvdXJjZUVsLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xuXHRcdHRoaXMucGFyZW50RWwgPSBvcHRpb25zLnBhcmVudEVsID8gJChvcHRpb25zLnBhcmVudEVsKSA6IHNvdXJjZUVsLnBhcmVudCgpOyAvLyBkZWZhdWx0IHRvIHNvdXJjZUVsJ3MgcGFyZW50XG5cdH0sXG5cblxuXHQvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RhcnQgZm9sbG93aW5nIHRoZSBtb3VzZVxuXHRzdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoIXRoaXMuaXNGb2xsb3dpbmcpIHtcblx0XHRcdHRoaXMuaXNGb2xsb3dpbmcgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnkwID0gZ2V0RXZZKGV2KTtcblx0XHRcdHRoaXMueDAgPSBnZXRFdlgoZXYpO1xuXHRcdFx0dGhpcy50b3BEZWx0YSA9IDA7XG5cdFx0XHR0aGlzLmxlZnREZWx0YSA9IDA7XG5cblx0XHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChnZXRFdklzVG91Y2goZXYpKSB7XG5cdFx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdG9wIGZvbGxvd2luZyB0aGUgbW91c2UuIElmIHNob3VsZFJldmVydCBpcyB0cnVlLCB3aWxsIGFuaW1hdGUgYmFjayB0byBvcmlnaW5hbCBwb3NpdGlvbi5cblx0Ly8gYGNhbGxiYWNrYCBnZXRzIGludm9rZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiBJZiBubyBhbmltYXRpb24sIGl0IGlzIGludm9rZWQgaW1tZWRpYXRlbHkuXG5cdHN0b3A6IGZ1bmN0aW9uKHNob3VsZFJldmVydCwgY2FsbGJhY2spIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciByZXZlcnREdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbjtcblxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0dGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0X3RoaXMucmVtb3ZlRWxlbWVudCgpO1xuXG5cdFx0XHR0aGlzLnRvcDAgPSB0aGlzLmxlZnQwID0gbnVsbDsgLy8gcmVzZXQgc3RhdGUgZm9yIGZ1dHVyZSB1cGRhdGVQb3NpdGlvbiBjYWxsc1xuXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc0ZvbGxvd2luZyAmJiAhdGhpcy5pc0FuaW1hdGluZykgeyAvLyBkaXNhbGxvdyBtb3JlIHRoYW4gb25lIHN0b3AgYW5pbWF0aW9uIGF0IGEgdGltZVxuXHRcdFx0dGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XG5cblx0XHRcdGlmIChzaG91bGRSZXZlcnQgJiYgcmV2ZXJ0RHVyYXRpb24gJiYgIXRoaXMuaXNIaWRkZW4pIHsgLy8gZG8gYSByZXZlcnQgYW5pbWF0aW9uP1xuXHRcdFx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5lbC5hbmltYXRlKHtcblx0XHRcdFx0XHR0b3A6IHRoaXMudG9wMCxcblx0XHRcdFx0XHRsZWZ0OiB0aGlzLmxlZnQwXG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRkdXJhdGlvbjogcmV2ZXJ0RHVyYXRpb24sXG5cdFx0XHRcdFx0Y29tcGxldGU6IGNvbXBsZXRlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgdHJhY2tpbmcgZWxlbWVudC4gQ3JlYXRlIGl0IGlmIG5lY2Vzc2FyeVxuXHRnZXRFbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5lbDtcblxuXHRcdGlmICghZWwpIHtcblx0XHRcdHRoaXMuc291cmNlRWwud2lkdGgoKTsgLy8gaGFjayB0byBmb3JjZSBJRTggdG8gY29tcHV0ZSBjb3JyZWN0IGJvdW5kaW5nIGJveFxuXHRcdFx0ZWwgPSB0aGlzLmVsID0gdGhpcy5zb3VyY2VFbC5jbG9uZSgpXG5cdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbENsYXNzIHx8ICcnKVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiAnJywgLy8gaW4gY2FzZSBvcmlnaW5hbCBlbGVtZW50IHdhcyBoaWRkZW4gKGNvbW1vbmx5IHRocm91Z2ggaGlkZUV2ZW50cygpKVxuXHRcdFx0XHRcdGRpc3BsYXk6IHRoaXMuaXNIaWRkZW4gPyAnbm9uZScgOiAnJywgLy8gZm9yIHdoZW4gaW5pdGlhbGx5IGhpZGRlblxuXHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRyaWdodDogJ2F1dG8nLCAvLyBlcmFzZSBhbmQgc2V0IHdpZHRoIGluc3RlYWRcblx0XHRcdFx0XHRib3R0b206ICdhdXRvJywgLy8gZXJhc2UgYW5kIHNldCBoZWlnaHQgaW5zdGVhZFxuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLnNvdXJjZUVsLndpZHRoKCksIC8vIGV4cGxpY2l0IGhlaWdodCBpbiBjYXNlIHRoZXJlIHdhcyBhICdyaWdodCcgdmFsdWVcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMuc291cmNlRWwuaGVpZ2h0KCksIC8vIGV4cGxpY2l0IHdpZHRoIGluIGNhc2UgdGhlcmUgd2FzIGEgJ2JvdHRvbScgdmFsdWVcblx0XHRcdFx0XHRvcGFjaXR5OiB0aGlzLm9wdGlvbnMub3BhY2l0eSB8fCAnJyxcblx0XHRcdFx0XHR6SW5kZXg6IHRoaXMub3B0aW9ucy56SW5kZXhcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cblx0XHRcdC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuXHRcdFx0ZWwuYWRkQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuXG5cdFx0XHRlbC5hcHBlbmRUbyh0aGlzLnBhcmVudEVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWw7XG5cdH0sXG5cblxuXHQvLyBSZW1vdmVzIHRoZSB0cmFja2luZyBlbGVtZW50IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuXHRyZW1vdmVFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5lbCkge1xuXHRcdFx0dGhpcy5lbC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuZWwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVwZGF0ZSB0aGUgQ1NTIHBvc2l0aW9uIG9mIHRoZSB0cmFja2luZyBlbGVtZW50XG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc291cmNlT2Zmc2V0O1xuXHRcdHZhciBvcmlnaW47XG5cblx0XHR0aGlzLmdldEVsKCk7IC8vIGVuc3VyZSB0aGlzLmVsXG5cblx0XHQvLyBtYWtlIHN1cmUgb3JpZ2luIGluZm8gd2FzIGNvbXB1dGVkXG5cdFx0aWYgKHRoaXMudG9wMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zb3VyY2VFbC53aWR0aCgpOyAvLyBoYWNrIHRvIGZvcmNlIElFOCB0byBjb21wdXRlIGNvcnJlY3QgYm91bmRpbmcgYm94XG5cdFx0XHRzb3VyY2VPZmZzZXQgPSB0aGlzLnNvdXJjZUVsLm9mZnNldCgpO1xuXHRcdFx0b3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcblx0XHRcdHRoaXMudG9wMCA9IHNvdXJjZU9mZnNldC50b3AgLSBvcmlnaW4udG9wO1xuXHRcdFx0dGhpcy5sZWZ0MCA9IHNvdXJjZU9mZnNldC5sZWZ0IC0gb3JpZ2luLmxlZnQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbC5jc3Moe1xuXHRcdFx0dG9wOiB0aGlzLnRvcDAgKyB0aGlzLnRvcERlbHRhLFxuXHRcdFx0bGVmdDogdGhpcy5sZWZ0MCArIHRoaXMubGVmdERlbHRhXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxuXHRoYW5kbGVNb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudG9wRGVsdGEgPSBnZXRFdlkoZXYpIC0gdGhpcy55MDtcblx0XHR0aGlzLmxlZnREZWx0YSA9IGdldEV2WChldikgLSB0aGlzLngwO1xuXG5cdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVGVtcG9yYXJpbHkgbWFrZXMgdGhlIHRyYWNraW5nIGVsZW1lbnQgaW52aXNpYmxlLiBDYW4gYmUgY2FsbGVkIGJlZm9yZSBmb2xsb3dpbmcgc3RhcnRzXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy5pc0hpZGRlbiA9IHRydWU7XG5cdFx0XHRpZiAodGhpcy5lbCkge1xuXHRcdFx0XHR0aGlzLmVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBTaG93IHRoZSB0cmFja2luZyBlbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHRlbXBvcmFyaWx5IGhpZGRlblxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5nZXRFbCgpLnNob3coKTtcblx0XHR9XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGNvbXByaXNlZCBvZiBhIFwiZ3JpZFwiIG9mIGFyZWFzIHRoYXQgZWFjaCByZXByZXNlbnQgYSBzcGVjaWZpYyBkYXRldGltZVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBHcmlkID0gRkMuR3JpZCA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCBNb3VzZUlnbm9yZXJNaXhpbiwge1xuXG5cdHZpZXc6IG51bGwsIC8vIGEgVmlldyBvYmplY3Rcblx0aXNSVEw6IG51bGwsIC8vIHNob3J0Y3V0IHRvIHRoZSB2aWV3J3MgaXNSVEwgb3B0aW9uXG5cblx0c3RhcnQ6IG51bGwsXG5cdGVuZDogbnVsbCxcblxuXHRlbDogbnVsbCwgLy8gdGhlIGNvbnRhaW5pbmcgZWxlbWVudFxuXHRlbHNCeUZpbGw6IG51bGwsIC8vIGEgaGFzaCBvZiBqUXVlcnkgZWxlbWVudCBzZXRzIHVzZWQgZm9yIHJlbmRlcmluZyBlYWNoIGZpbGwuIEtleWVkIGJ5IGZpbGwgbmFtZS5cblxuXHQvLyBkZXJpdmVkIGZyb20gb3B0aW9uc1xuXHRldmVudFRpbWVGb3JtYXQ6IG51bGwsXG5cdGRpc3BsYXlFdmVudFRpbWU6IG51bGwsXG5cdGRpc3BsYXlFdmVudEVuZDogbnVsbCxcblxuXHRtaW5SZXNpemVEdXJhdGlvbjogbnVsbCwgLy8gVE9ETzogaGFjay4gc2V0IGJ5IHN1YmNsYXNzZXMuIG1pbnVtdW0gZXZlbnQgcmVzaXplIGR1cmF0aW9uXG5cblx0Ly8gaWYgZGVmaW5lZCwgaG9sZHMgdGhlIHVuaXQgaWRlbnRpZmllZCAoZXg6IFwieWVhclwiIG9yIFwibW9udGhcIikgdGhhdCBkZXRlcm1pbmVzIHRoZSBsZXZlbCBvZiBncmFudWxhcml0eVxuXHQvLyBvZiB0aGUgZGF0ZSBhcmVhcy4gaWYgbm90IGRlZmluZWQsIGFzc3VtZXMgdG8gYmUgZGF5IGFuZCB0aW1lIGdyYW51bGFyaXR5LlxuXHQvLyBUT0RPOiBwb3J0IGlzVGltZVNjYWxlIGludG8gc2FtZSBzeXN0ZW0/XG5cdGxhcmdlVW5pdDogbnVsbCxcblxuXHRkYXlEcmFnTGlzdGVuZXI6IG51bGwsXG5cdHNlZ0RyYWdMaXN0ZW5lcjogbnVsbCxcblx0c2VnUmVzaXplTGlzdGVuZXI6IG51bGwsXG5cdGV4dGVybmFsRHJhZ0xpc3RlbmVyOiBudWxsLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHZpZXcpIHtcblx0XHR0aGlzLnZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuaXNSVEwgPSB2aWV3Lm9wdCgnaXNSVEwnKTtcblx0XHR0aGlzLmVsc0J5RmlsbCA9IHt9O1xuXG5cdFx0dGhpcy5kYXlEcmFnTGlzdGVuZXIgPSB0aGlzLmJ1aWxkRGF5RHJhZ0xpc3RlbmVyKCk7XG5cdFx0dGhpcy5pbml0TW91c2VJZ25vcmluZygpO1xuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHVzZWQgZm9yIGV2ZW50IHRpbWUgdGV4dCwgaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBieSAndGltZUZvcm1hdCdcblx0Y29tcHV0ZUV2ZW50VGltZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyB3aGV0aGVyIGV2ZW50cyBzaG91bGQgaGF2ZSB0aGVpciBlbmQgdGltZXMgZGlzcGxheWVkLCBpZiBub3QgZXhwbGljaXRseSBkZWZpbmVkIGJ5ICdkaXNwbGF5RXZlbnRUaW1lJy5cblx0Ly8gT25seSBhcHBsaWVzIHRvIG5vbi1hbGwtZGF5IGV2ZW50cy5cblx0Y29tcHV0ZURpc3BsYXlFdmVudFRpbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyB3aGV0aGVyIGV2ZW50cyBzaG91bGQgaGF2ZSB0aGVpciBlbmQgdGltZXMgZGlzcGxheWVkLCBpZiBub3QgZXhwbGljaXRseSBkZWZpbmVkIGJ5ICdkaXNwbGF5RXZlbnRFbmQnXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0LyogRGF0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFRlbGxzIHRoZSBncmlkIGFib3V0IHdoYXQgcGVyaW9kIG9mIHRpbWUgdG8gZGlzcGxheS5cblx0Ly8gQW55IGRhdGUtcmVsYXRlZCBpbnRlcm5hbCBkYXRhIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG5cdHNldFJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHRoaXMuc3RhcnQgPSByYW5nZS5zdGFydC5jbG9uZSgpO1xuXHRcdHRoaXMuZW5kID0gcmFuZ2UuZW5kLmNsb25lKCk7XG5cblx0XHR0aGlzLnJhbmdlVXBkYXRlZCgpO1xuXHRcdHRoaXMucHJvY2Vzc1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gaW50ZXJuYWwgdmFyaWFibGVzIHRoYXQgcmVseSBvbiB0aGUgcmFuZ2Ugc2hvdWxkIGJlIHVwZGF0ZWRcblx0cmFuZ2VVcGRhdGVkOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgdmFsdWVzIHRoYXQgcmVseSBvbiBvcHRpb25zIGFuZCBhbHNvIHJlbGF0ZSB0byByYW5nZVxuXHRwcm9jZXNzUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGlzcGxheUV2ZW50VGltZTtcblx0XHR2YXIgZGlzcGxheUV2ZW50RW5kO1xuXG5cdFx0dGhpcy5ldmVudFRpbWVGb3JtYXQgPVxuXHRcdFx0dmlldy5vcHQoJ2V2ZW50VGltZUZvcm1hdCcpIHx8XG5cdFx0XHR2aWV3Lm9wdCgndGltZUZvcm1hdCcpIHx8IC8vIGRlcHJlY2F0ZWRcblx0XHRcdHRoaXMuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCgpO1xuXG5cdFx0ZGlzcGxheUV2ZW50VGltZSA9IHZpZXcub3B0KCdkaXNwbGF5RXZlbnRUaW1lJyk7XG5cdFx0aWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xuXHRcdFx0ZGlzcGxheUV2ZW50VGltZSA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudFRpbWUoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXG5cdFx0fVxuXG5cdFx0ZGlzcGxheUV2ZW50RW5kID0gdmlldy5vcHQoJ2Rpc3BsYXlFdmVudEVuZCcpO1xuXHRcdGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xuXHRcdFx0ZGlzcGxheUV2ZW50RW5kID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50RW5kKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxuXHRcdH1cblxuXHRcdHRoaXMuZGlzcGxheUV2ZW50VGltZSA9IGRpc3BsYXlFdmVudFRpbWU7XG5cdFx0dGhpcy5kaXNwbGF5RXZlbnRFbmQgPSBkaXNwbGF5RXZlbnRFbmQ7XG5cdH0sXG5cblxuXHQvLyBDb252ZXJ0cyBhIHNwYW4gKGhhcyB1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgYW55IG90aGVyIGdyaWQtc3BlY2lmaWMgbG9jYXRpb24gaW5mb3JtYXRpb24pXG5cdC8vIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHMgKHBpZWNlcyBvZiBldmVudHMgd2hvc2UgZm9ybWF0IGlzIGRlY2lkZWQgYnkgdGhlIGdyaWQpLlxuXHRzcGFuVG9TZWdzOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gRGlmZnMgdGhlIHR3byBkYXRlcywgcmV0dXJuaW5nIGEgZHVyYXRpb24sIGJhc2VkIG9uIGdyYW51bGFyaXR5IG9mIHRoZSBncmlkXG5cdC8vIFRPRE86IHBvcnQgaXNUaW1lU2NhbGUgaW50byB0aGlzIHN5c3RlbT9cblx0ZGlmZkRhdGVzOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0aWYgKHRoaXMubGFyZ2VVbml0KSB7XG5cdFx0XHRyZXR1cm4gZGlmZkJ5VW5pdChhLCBiLCB0aGlzLmxhcmdlVW5pdCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIGRpZmZEYXlUaW1lKGEsIGIpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEhpdCBBcmVhXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDYWxsZWQgYmVmb3JlIG9uZSBvciBtb3JlIHF1ZXJ5SGl0IGNhbGxzIG1pZ2h0IGhhcHBlbi4gU2hvdWxkIHByZXBhcmUgYW55IGNhY2hlZCBjb29yZGluYXRlcyBmb3IgcXVlcnlIaXRcblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gcXVlcnlIaXQgY2FsbHMgaGF2ZSBzdWJzaWRlZC4gR29vZCBwbGFjZSB0byBjbGVhciBhbnkgY29vcmRpbmF0ZSBjYWNoZXMuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGNvb3JkaW5hdGVzIGZyb20gdGhlIHRvcGxlZnQgb2YgdGhlIGRvY3VtZW50LCByZXR1cm4gZGF0YSBhYm91dCB0aGUgZGF0ZS1yZWxhdGVkIGFyZWEgdW5kZXJuZWF0aC5cblx0Ly8gQ2FuIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhcmJpdHJhcnkgcHJvcGVydGllcyAoYWx0aG91Z2ggdG9wL3JpZ2h0L2xlZnQvYm90dG9tIGFyZSBlbmNvdXJhZ2VkKS5cblx0Ly8gTXVzdCBoYXZlIGEgYGdyaWRgIHByb3BlcnR5LCBhIHJlZmVyZW5jZSB0byB0aGlzIGN1cnJlbnQgZ3JpZC4gVE9ETzogYXZvaWQgdGhpc1xuXHQvLyBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGdldEhpdFNwYW4gYW5kIGdldEhpdEVsLlxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBwb3NpdGlvbi1sZXZlbCBpbmZvcm1hdGlvbiBhYm91dCBhIGRhdGUtcmVsYXRlZCBhcmVhIHdpdGhpbiB0aGUgZ3JpZCxcblx0Ly8gc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIHN0YXJ0L2VuZCBkYXRlLiBDYW4gcHJvdmlkZSBvdGhlciBpbmZvcm1hdGlvbiBhcyB3ZWxsLlxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0fSxcblxuXG5cdC8vIEdpdmVuIHBvc2l0aW9uLWxldmVsIGluZm9ybWF0aW9uIGFib3V0IGEgZGF0ZS1yZWxhdGVkIGFyZWEgd2l0aGluIHRoZSBncmlkLFxuXHQvLyBzaG91bGQgcmV0dXJuIGEgalF1ZXJ5IGVsZW1lbnQgdGhhdCBiZXN0IHJlcHJlc2VudHMgaXQuIHBhc3NlZCB0byBkYXlDbGljayBjYWxsYmFjay5cblx0Z2V0SGl0RWw6IGZ1bmN0aW9uKGhpdCkge1xuXHR9LFxuXG5cblx0LyogUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTZXRzIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSBncmlkIHNob3VsZCByZW5kZXIgaW5zaWRlIG9mLlxuXHQvLyBEb2VzIG90aGVyIERPTS1yZWxhdGVkIGluaXRpYWxpemF0aW9ucy5cblx0c2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcblx0XHR0aGlzLmVsID0gZWw7XG5cdFx0cHJldmVudFNlbGVjdGlvbihlbCk7XG5cblx0XHR0aGlzLmJpbmREYXlIYW5kbGVyKCd0b3VjaHN0YXJ0JywgdGhpcy5kYXlUb3VjaFN0YXJ0KTtcblx0XHR0aGlzLmJpbmREYXlIYW5kbGVyKCdtb3VzZWRvd24nLCB0aGlzLmRheU1vdXNlZG93bik7XG5cblx0XHQvLyBhdHRhY2ggZXZlbnQtZWxlbWVudC1yZWxhdGVkIGhhbmRsZXJzLiBpbiBHcmlkLmV2ZW50c1xuXHRcdC8vIHNhbWUgZ2FyYmFnZSBjb2xsZWN0aW9uIG5vdGUgYXMgYWJvdmUuXG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlcnMoKTtcblxuXHRcdHRoaXMuYmluZEdsb2JhbEhhbmRsZXJzKCk7XG5cdH0sXG5cblxuXHRiaW5kRGF5SGFuZGxlcjogZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHQvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIHRoZSBncmlkJ3Mgcm9vdCBlbGVtZW50LlxuXHRcdC8vIGpRdWVyeSB3aWxsIHRha2UgY2FyZSBvZiB1bnJlZ2lzdGVyaW5nIHRoZW0gd2hlbiByZW1vdmVFbGVtZW50IGdldHMgY2FsbGVkLlxuXHRcdHRoaXMuZWwub24obmFtZSwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0ISQoZXYudGFyZ2V0KS5pcygnLmZjLWV2ZW50LWNvbnRhaW5lciAqLCAuZmMtbW9yZScpICYmIC8vIG5vdCBhbiBhbiBldmVudCBlbGVtZW50LCBvciBcIm1vcmUuLlwiIGxpbmtcblx0XHRcdFx0ISQoZXYudGFyZ2V0KS5jbG9zZXN0KCcuZmMtcG9wb3ZlcicpLmxlbmd0aCAvLyBub3Qgb24gYSBwb3BvdmVyIChsaWtlIHRoZSBcIm1vcmUuLlwiIGV2ZW50cyBvbmUpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgZXYpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gUmVtb3ZlcyB0aGUgZ3JpZCdzIGNvbnRhaW5lciBlbGVtZW50IGZyb20gdGhlIERPTS4gVW5kb2VzIGFueSBvdGhlciBET00tcmVsYXRlZCBhdHRhY2htZW50cy5cblx0Ly8gRE9FUyBOT1QgcmVtb3ZlIGFueSBjb250ZW50IGJlZm9yZWhhbmQgKGRvZXNuJ3QgY2xlYXIgZXZlbnRzIG9yIGNhbGwgdW5yZW5kZXJEYXRlcyksIHVubGlrZSBWaWV3XG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcblx0XHR0aGlzLmNsZWFyRHJhZ0xpc3RlbmVycygpO1xuXG5cdFx0dGhpcy5lbC5yZW1vdmUoKTtcblxuXHRcdC8vIE5PVEU6IHdlIGRvbid0IG51bGwtb3V0IHRoaXMuZWwgZm9yIHRoZSBzYW1lIHJlYXNvbnMgd2UgZG9uJ3QgZG8gaXQgd2l0aGluIFZpZXc6OnJlbW92ZUVsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiBncmlkIHZpZXcgYmVmb3JlIGFueSBjb250ZW50IGlzIHJlbmRlcmVkXG5cdHJlbmRlclNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdyaWQncyBkYXRlLXJlbGF0ZWQgY29udGVudCAobGlrZSBhcmVhcyB0aGF0IHJlcHJlc2VudCBkYXlzL3RpbWVzKS5cblx0Ly8gQXNzdW1lcyBzZXRSYW5nZSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCBhbmQgdGhlIHNrZWxldG9uIGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgZ3JpZCdzIGRhdGUtcmVsYXRlZCBjb250ZW50XG5cdHVucmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogSGFuZGxlcnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEJpbmRzIERPTSBoYW5kbGVycyB0byBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSBncmlkLCBzdWNoIGFzIHRoZSBkb2N1bWVudFxuXHRiaW5kR2xvYmFsSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5leHRlcm5hbERyYWdTdGFydCwgLy8ganF1aVxuXHRcdFx0c29ydHN0YXJ0OiB0aGlzLmV4dGVybmFsRHJhZ1N0YXJ0IC8vIGpxdWlcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFVuYmluZHMgRE9NIGhhbmRsZXJzIGZyb20gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgZ3JpZFxuXHR1bmJpbmRHbG9iYWxIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xuXHR9LFxuXG5cblx0Ly8gUHJvY2VzcyBhIG1vdXNlZG93biBvbiBhbiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBhIGRheS4gRm9yIGRheSBjbGlja2luZyBhbmQgc2VsZWN0aW5nLlxuXHRkYXlNb3VzZWRvd246IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKCF0aGlzLmlzSWdub3JpbmdNb3VzZSkge1xuXHRcdFx0dGhpcy5kYXlEcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xuXHRcdFx0XHQvL2Rpc3RhbmNlOiA1LCAvLyBuZWVkcyBtb3JlIHdvcmsgaWYgd2Ugd2FudCBkYXlDbGljayB0byBmaXJlIGNvcnJlY3RseVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0ZGF5VG91Y2hTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdC8vIEhBQ0sgdG8gcHJldmVudCBhIHVzZXIncyBjbGlja2F3YXkgZm9yIHVuc2VsZWN0aW5nIGEgcmFuZ2Ugb3IgYW4gZXZlbnRcblx0XHQvLyBmcm9tIGNhdXNpbmcgYSBkYXlDbGljay5cblx0XHRpZiAodmlldy5pc1NlbGVjdGVkIHx8IHZpZXcuc2VsZWN0ZWRFdmVudCkge1xuXHRcdFx0dGhpcy50ZW1wSWdub3JlTW91c2UoKTtcblx0XHR9XG5cblx0XHR0aGlzLmRheURyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XG5cdFx0XHRkZWxheTogdGhpcy52aWV3Lm9wdCgnbG9uZ1ByZXNzRGVsYXknKVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyJ3MgZHJhZyBhY3Jvc3MgZGF5IGVsZW1lbnRzLlxuXHQvLyBGb3IgZGF5IGNsaWNraW5nIGFuZCBzZWxlY3RpbmcuXG5cdGJ1aWxkRGF5RHJhZ0xpc3RlbmVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBpc1NlbGVjdGFibGUgPSB2aWV3Lm9wdCgnc2VsZWN0YWJsZScpO1xuXHRcdHZhciBkYXlDbGlja0hpdDsgLy8gbnVsbCBpZiBpbnZhbGlkIGRheUNsaWNrXG5cdFx0dmFyIHNlbGVjdGlvblNwYW47IC8vIG51bGwgaWYgaW52YWxpZCBzZWxlY3Rpb25cblxuXHRcdC8vIHRoaXMgbGlzdGVuZXIgdHJhY2tzIGEgbW91c2Vkb3duIG9uIGEgZGF5IGVsZW1lbnQsIGFuZCBhIHN1YnNlcXVlbnQgZHJhZy5cblx0XHQvLyBpZiB0aGUgZHJhZyBlbmRzIG9uIHRoZSBzYW1lIGRheSwgaXQgaXMgYSAnZGF5Q2xpY2snLlxuXHRcdC8vIGlmICdzZWxlY3RhYmxlJyBpcyBlbmFibGVkLCB0aGlzIGxpc3RlbmVyIGFsc28gZGV0ZWN0cyBzZWxlY3Rpb25zLlxuXHRcdHZhciBkcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyKHRoaXMsIHtcblx0XHRcdHNjcm9sbDogdmlldy5vcHQoJ2RyYWdTY3JvbGwnKSxcblx0XHRcdGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXlDbGlja0hpdCA9IGRyYWdMaXN0ZW5lci5vcmlnSGl0OyAvLyBmb3IgZGF5Q2xpY2ssIHdoZXJlIG5vIGRyYWdnaW5nIGhhcHBlbnNcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2aWV3LnVuc2VsZWN0KCk7IC8vIHNpbmNlIHdlIGNvdWxkIGJlIHJlbmRlcmluZyBhIG5ldyBzZWxlY3Rpb24sIHdlIHdhbnQgdG8gY2xlYXIgYW55IG9sZCBvbmVcblx0XHRcdH0sXG5cdFx0XHRoaXRPdmVyOiBmdW5jdGlvbihoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xuXHRcdFx0XHRpZiAob3JpZ0hpdCkgeyAvLyBjbGljayBuZWVkcyB0byBoYXZlIHN0YXJ0ZWQgb24gYSBoaXRcblxuXHRcdFx0XHRcdC8vIGlmIHVzZXIgZHJhZ2dlZCB0byBhbm90aGVyIGNlbGwgYXQgYW55IHBvaW50LCBpdCBjYW4gbm8gbG9uZ2VyIGJlIGEgZGF5Q2xpY2tcblx0XHRcdFx0XHRpZiAoIWlzT3JpZykge1xuXHRcdFx0XHRcdFx0ZGF5Q2xpY2tIaXQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpc1NlbGVjdGFibGUpIHtcblx0XHRcdFx0XHRcdHNlbGVjdGlvblNwYW4gPSBfdGhpcy5jb21wdXRlU2VsZWN0aW9uKFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5nZXRIaXRTcGFuKG9yaWdIaXQpLFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5nZXRIaXRTcGFuKGhpdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uU3Bhbikge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5yZW5kZXJTZWxlY3Rpb24oc2VsZWN0aW9uU3Bhbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChzZWxlY3Rpb25TcGFuID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRkaXNhYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF5Q2xpY2tIaXQgPSBudWxsO1xuXHRcdFx0XHRzZWxlY3Rpb25TcGFuID0gbnVsbDtcblx0XHRcdFx0X3RoaXMudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdFx0XHRpZiAoIWlzQ2FuY2VsbGVkKSB7XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0ZGF5Q2xpY2tIaXQgJiZcblx0XHRcdFx0XHRcdCFfdGhpcy5pc0lnbm9yaW5nTW91c2UgLy8gc2VlIGhhY2sgaW4gZGF5VG91Y2hTdGFydFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0dmlldy50cmlnZ2VyRGF5Q2xpY2soXG5cdFx0XHRcdFx0XHRcdF90aGlzLmdldEhpdFNwYW4oZGF5Q2xpY2tIaXQpLFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5nZXRIaXRFbChkYXlDbGlja0hpdCksXG5cdFx0XHRcdFx0XHRcdGV2XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uU3Bhbikge1xuXHRcdFx0XHRcdFx0Ly8gdGhlIHNlbGVjdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHJlbmRlcmVkLiBqdXN0IHJlcG9ydCBpdFxuXHRcdFx0XHRcdFx0dmlldy5yZXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uU3BhbiwgZXYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbmFibGVDdXJzb3IoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGRyYWdMaXN0ZW5lcjtcblx0fSxcblxuXG5cdC8vIEtpbGxzIGFsbCBpbi1wcm9ncmVzcyBkcmFnZ2luZy5cblx0Ly8gVXNlZnVsIGZvciB3aGVuIHB1YmxpYyBBUEkgbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiByZS1yZW5kZXJpbmcgYXJlIGludm9rZWQgZHVyaW5nIGEgZHJhZy5cblx0Ly8gQWxzbyB1c2VmdWwgZm9yIHdoZW4gdG91Y2ggZGV2aWNlcyBtaXNiZWhhdmUgYW5kIGRvbid0IGZpcmUgdGhlaXIgdG91Y2hlbmQuXG5cdGNsZWFyRHJhZ0xpc3RlbmVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlEcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcblxuXHRcdGlmICh0aGlzLnNlZ0RyYWdMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5zZWdEcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTsgLy8gd2lsbCBjbGVhciB0aGlzLnNlZ0RyYWdMaXN0ZW5lclxuXHRcdH1cblx0XHRpZiAodGhpcy5zZWdSZXNpemVMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5zZWdSZXNpemVMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpOyAvLyB3aWxsIGNsZWFyIHRoaXMuc2VnUmVzaXplTGlzdGVuZXJcblx0XHR9XG5cdFx0aWYgKHRoaXMuZXh0ZXJuYWxEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuZXh0ZXJuYWxEcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTsgLy8gd2lsbCBjbGVhciB0aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRXZlbnQgSGVscGVyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIFRPRE86IHNob3VsZCBwcm9iYWJseSBtb3ZlIHRoaXMgdG8gR3JpZC5ldmVudHMsIGxpa2Ugd2UgZGlkIGV2ZW50IGRyYWdnaW5nIC8gcmVzaXppbmdcblxuXG5cdC8vIFJlbmRlcnMgYSBtb2NrIGV2ZW50IGF0IHRoZSBnaXZlbiBldmVudCBsb2NhdGlvbiwgd2hpY2ggY29udGFpbnMgem9uZWQgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG5cdC8vIFJldHVybnMgYWxsIG1vY2sgZXZlbnQgZWxlbWVudHMuXG5cdHJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXI6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNvdXJjZVNlZykge1xuXHRcdHZhciBmYWtlRXZlbnQgPSB0aGlzLmZhYnJpY2F0ZUhlbHBlckV2ZW50KGV2ZW50TG9jYXRpb24sIHNvdXJjZVNlZyk7XG5cblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJIZWxwZXIoZmFrZUV2ZW50LCBzb3VyY2VTZWcpOyAvLyBkbyB0aGUgYWN0dWFsIHJlbmRlcmluZ1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgZmFrZSBldmVudCBnaXZlbiB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXMgYW5kIGEgc2VnbWVudCBpcyBzaG91bGQgYmUgaW5zcGlyZWQgZnJvbS5cblx0Ly8gVGhlIHJhbmdlJ3MgZW5kIGNhbiBiZSBudWxsLCBpbiB3aGljaCBjYXNlIHRoZSBtb2NrIGV2ZW50IHRoYXQgaXMgcmVuZGVyZWQgd2lsbCBoYXZlIGEgbnVsbCBlbmQgdGltZS5cblx0Ly8gYHNvdXJjZVNlZ2AgaXMgdGhlIGludGVybmFsIHNlZ21lbnQgb2JqZWN0IGludm9sdmVkIGluIHRoZSBkcmFnLiBJZiBudWxsLCBzb21ldGhpbmcgZXh0ZXJuYWwgaXMgZHJhZ2dpbmcuXG5cdGZhYnJpY2F0ZUhlbHBlckV2ZW50OiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgZmFrZUV2ZW50ID0gc291cmNlU2VnID8gY3JlYXRlT2JqZWN0KHNvdXJjZVNlZy5ldmVudCkgOiB7fTsgLy8gbWFzayB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0IGlmIHBvc3NpYmxlXG5cblx0XHRmYWtlRXZlbnQuc3RhcnQgPSBldmVudExvY2F0aW9uLnN0YXJ0LmNsb25lKCk7XG5cdFx0ZmFrZUV2ZW50LmVuZCA9IGV2ZW50TG9jYXRpb24uZW5kID8gZXZlbnRMb2NhdGlvbi5lbmQuY2xvbmUoKSA6IG51bGw7XG5cdFx0ZmFrZUV2ZW50LmFsbERheSA9IG51bGw7IC8vIGZvcmNlIGl0IHRvIGJlIGZyZXNobHkgY29tcHV0ZWQgYnkgbm9ybWFsaXplRXZlbnREYXRlc1xuXHRcdHRoaXMudmlldy5jYWxlbmRhci5ub3JtYWxpemVFdmVudERhdGVzKGZha2VFdmVudCk7XG5cblx0XHQvLyB0aGlzIGV4dHJhIGNsYXNzTmFtZSB3aWxsIGJlIHVzZWZ1bCBmb3IgZGlmZmVyZW50aWF0aW5nIHJlYWwgZXZlbnRzIGZyb20gbW9jayBldmVudHMgaW4gQ1NTXG5cdFx0ZmFrZUV2ZW50LmNsYXNzTmFtZSA9IChmYWtlRXZlbnQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQoJ2ZjLWhlbHBlcicpO1xuXG5cdFx0Ly8gaWYgc29tZXRoaW5nIGV4dGVybmFsIGlzIGJlaW5nIGRyYWdnZWQgaW4sIGRvbid0IHJlbmRlciBhIHJlc2l6ZXJcblx0XHRpZiAoIXNvdXJjZVNlZykge1xuXHRcdFx0ZmFrZUV2ZW50LmVkaXRhYmxlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZha2VFdmVudDtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSBtb2NrIGV2ZW50LiBHaXZlbiB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXMuXG5cdC8vIE11c3QgcmV0dXJuIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzLlxuXHRyZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNvdXJjZVNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIG1vY2sgZXZlbnRcblx0dW5yZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uLiBXaWxsIGhpZ2hsaWdodCBieSBkZWZhdWx0IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuXHQvLyBHaXZlbiBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpXG5cdHJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHNwYW4pO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbnMgb2YgYSBzZWxlY3Rpb24uIFdpbGwgdW5yZW5kZXIgYSBoaWdobGlnaHQgYnkgZGVmYXVsdC5cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBmaXJzdCBhbmQgbGFzdCBkYXRlLXNwYW5zIG9mIGEgc2VsZWN0aW9uLCByZXR1cm5zIGFub3RoZXIgZGF0ZS1zcGFuIG9iamVjdC5cblx0Ly8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgYW5kIHByb3ZpZGUgYWRkaXRpb25hbCBkYXRhIGluIHRoZSBzcGFuIG9iamVjdC4gV2lsbCBiZSBwYXNzZWQgdG8gcmVuZGVyU2VsZWN0aW9uKCkuXG5cdC8vIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW52YWxpZCBhbmQgdGhpcyBzaG91bGQgYmUgaW5kaWNhdGVkIHRvIHRoZSB1c2VyLlxuXHQvLyBXaWxsIHJldHVybiBudWxsL3VuZGVmaW5lZCBpZiBhIHNlbGVjdGlvbiBpbnZhbGlkIGJ1dCBubyBlcnJvciBzaG91bGQgYmUgcmVwb3J0ZWQuXG5cdGNvbXB1dGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4wLCBzcGFuMSkge1xuXHRcdHZhciBzcGFuID0gdGhpcy5jb21wdXRlU2VsZWN0aW9uU3BhbihzcGFuMCwgc3BhbjEpO1xuXG5cdFx0aWYgKHNwYW4gJiYgIXRoaXMudmlldy5jYWxlbmRhci5pc1NlbGVjdGlvblNwYW5BbGxvd2VkKHNwYW4pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwYW47XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0d28gc3BhbnMsIG11c3QgcmV0dXJuIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxuXHQvLyBUT0RPOiBkbyB0aGlzIHNlcGFyYXRpb24gb2YgY29uY2VybnMgKGNvbWJpbmluZyBWUyB2YWxpZGF0aW9uKSBmb3IgZXZlbnQgZG5kL3Jlc2l6ZSB0b28uXG5cdGNvbXB1dGVTZWxlY3Rpb25TcGFuOiBmdW5jdGlvbihzcGFuMCwgc3BhbjEpIHtcblx0XHR2YXIgZGF0ZXMgPSBbIHNwYW4wLnN0YXJ0LCBzcGFuMC5lbmQsIHNwYW4xLnN0YXJ0LCBzcGFuMS5lbmQgXTtcblxuXHRcdGRhdGVzLnNvcnQoY29tcGFyZU51bWJlcnMpOyAvLyBzb3J0cyBjaHJvbm9sb2dpY2FsbHkuIHdvcmtzIHdpdGggTW9tZW50c1xuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IGRhdGVzWzBdLmNsb25lKCksIGVuZDogZGF0ZXNbM10uY2xvbmUoKSB9O1xuXHR9LFxuXG5cblx0LyogSGlnaGxpZ2h0XG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGFuIGVtcGhhc2lzIG9uIHRoZSBnaXZlbiBkYXRlIHJhbmdlLiBHaXZlbiBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpXG5cdHJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVyRmlsbCgnaGlnaGxpZ2h0JywgdGhpcy5zcGFuVG9TZWdzKHNwYW4pKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgZW1waGFzaXMgb24gYSBkYXRlIHJhbmdlXG5cdHVucmVuZGVySGlnaGxpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyRmlsbCgnaGlnaGxpZ2h0Jyk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gYXJyYXkgb2YgY2xhc3NOYW1lcyBmb3IgcmVuZGVyaW5nIHRoZSBoaWdobGlnaHQuIFVzZWQgYnkgdGhlIGZpbGwgc3lzdGVtLlxuXHRoaWdobGlnaHRTZWdDbGFzc2VzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gWyAnZmMtaGlnaGxpZ2h0JyBdO1xuXHR9LFxuXG5cblx0LyogQnVzaW5lc3MgSG91cnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8qIE5vdyBJbmRpY2F0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGdldE5vd0luZGljYXRvclVuaXQ6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvKiBGaWxsIFN5c3RlbSAoaGlnaGxpZ2h0LCBiYWNrZ3JvdW5kIGV2ZW50cywgYnVzaW5lc3MgaG91cnMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFRPRE86IHJlbW92ZSB0aGlzIHN5c3RlbS4gbGlrZSB3ZSBkaWQgaW4gVGltZUdyaWRcblx0Ki9cblxuXG5cdC8vIFJlbmRlcnMgYSBzZXQgb2YgcmVjdGFuZ2xlcyBvdmVyIHRoZSBnaXZlbiBzZWdtZW50cyBvZiB0aW1lLlxuXHQvLyBNVVNUIFJFVFVSTiBhIHN1YnNldCBvZiBzZWdzLCB0aGUgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWQuXG5cdC8vIFJlc3BvbnNpYmxlIGZvciBwb3B1bGF0aW5nIHRoaXMuZWxzQnlGaWxsLiBUT0RPOiBiZXR0ZXIgQVBJIGZvciBleHByZXNzaW5nIHRoaXMgcmVxdWlyZW1lbnRcblx0cmVuZGVyRmlsbDogZnVuY3Rpb24odHlwZSwgc2Vncykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHNwZWNpZmljIHR5cGUgb2YgZmlsbCB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxuXHR1bnJlbmRlckZpbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgZWwgPSB0aGlzLmVsc0J5RmlsbFt0eXBlXTtcblxuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbHNCeUZpbGxbdHlwZV07XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhbmQgYXNzaWducyBhbiBgZWxgIHByb3BlcnR5IGZvciBlYWNoIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cblx0Ly8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxuXHQvLyBUbyBiZSBoYXJuZXNzZWQgYnkgcmVuZGVyRmlsbCAoaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcykuXG5cdC8vIEFuYWxhZ291cyB0byByZW5kZXJGZ1NlZ0Vscy5cblx0cmVuZGVyRmlsbFNlZ0VsczogZnVuY3Rpb24odHlwZSwgc2Vncykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHNlZ0VsTWV0aG9kID0gdGhpc1t0eXBlICsgJ1NlZ0VsJ107XG5cdFx0dmFyIGh0bWwgPSAnJztcblx0XHR2YXIgcmVuZGVyZWRTZWdzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2Vncy5sZW5ndGgpIHtcblxuXHRcdFx0Ly8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aHRtbCArPSB0aGlzLmZpbGxTZWdIdG1sKHR5cGUsIHNlZ3NbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHcmFiIGluZGl2aWR1YWwgZWxlbWVudHMgZnJvbSB0aGUgY29tYmluZWQgSFRNTCBzdHJpbmcuIFVzZSBlYWNoIGFzIHRoZSBkZWZhdWx0IHJlbmRlcmluZy5cblx0XHRcdC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC5cblx0XHRcdCQoaHRtbCkuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHRcdHZhciBzZWcgPSBzZWdzW2ldO1xuXHRcdFx0XHR2YXIgZWwgPSAkKG5vZGUpO1xuXG5cdFx0XHRcdC8vIGFsbG93IGN1c3RvbSBmaWx0ZXIgbWV0aG9kcyBwZXItdHlwZVxuXHRcdFx0XHRpZiAoc2VnRWxNZXRob2QpIHtcblx0XHRcdFx0XHRlbCA9IHNlZ0VsTWV0aG9kLmNhbGwoX3RoaXMsIHNlZywgZWwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsKSB7IC8vIGN1c3RvbSBmaWx0ZXJzIGRpZCBub3QgY2FuY2VsIHRoZSByZW5kZXJcblx0XHRcdFx0XHRlbCA9ICQoZWwpOyAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIHRvIHJldHVybiByYXcgRE9NIG5vZGVcblxuXHRcdFx0XHRcdC8vIGNvcnJlY3QgZWxlbWVudCB0eXBlPyAod291bGQgYmUgYmFkIGlmIGEgbm9uLVREIHdlcmUgaW5zZXJ0ZWQgaW50byBhIHRhYmxlIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdGlmIChlbC5pcyhfdGhpcy5maWxsU2VnVGFnKSkge1xuXHRcdFx0XHRcdFx0c2VnLmVsID0gZWw7XG5cdFx0XHRcdFx0XHRyZW5kZXJlZFNlZ3MucHVzaChzZWcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlcmVkU2Vncztcblx0fSxcblxuXG5cdGZpbGxTZWdUYWc6ICdkaXYnLCAvLyBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuXG5cblx0Ly8gQnVpbGRzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cblx0ZmlsbFNlZ0h0bWw6IGZ1bmN0aW9uKHR5cGUsIHNlZykge1xuXG5cdFx0Ly8gY3VzdG9tIGhvb2tzIHBlci10eXBlXG5cdFx0dmFyIGNsYXNzZXNNZXRob2QgPSB0aGlzW3R5cGUgKyAnU2VnQ2xhc3NlcyddO1xuXHRcdHZhciBjc3NNZXRob2QgPSB0aGlzW3R5cGUgKyAnU2VnQ3NzJ107XG5cblx0XHR2YXIgY2xhc3NlcyA9IGNsYXNzZXNNZXRob2QgPyBjbGFzc2VzTWV0aG9kLmNhbGwodGhpcywgc2VnKSA6IFtdO1xuXHRcdHZhciBjc3MgPSBjc3NUb1N0cihjc3NNZXRob2QgPyBjc3NNZXRob2QuY2FsbCh0aGlzLCBzZWcpIDoge30pO1xuXG5cdFx0cmV0dXJuICc8JyArIHRoaXMuZmlsbFNlZ1RhZyArXG5cdFx0XHQoY2xhc3Nlcy5sZW5ndGggPyAnIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyA6ICcnKSArXG5cdFx0XHQoY3NzID8gJyBzdHlsZT1cIicgKyBjc3MgKyAnXCInIDogJycpICtcblx0XHRcdCcgLz4nO1xuXHR9LFxuXG5cblxuXHQvKiBHZW5lcmljIHJlbmRlcmluZyB1dGlsaXRpZXMgZm9yIHN1YmNsYXNzZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIEhUTUwgY2xhc3NOYW1lcyBmb3IgYSBzaW5nbGUtZGF5IGVsZW1lbnRcblx0Z2V0RGF5Q2xhc3NlczogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciB0b2RheSA9IHZpZXcuY2FsZW5kYXIuZ2V0Tm93KCk7XG5cdFx0dmFyIGNsYXNzZXMgPSBbICdmYy0nICsgZGF5SURzW2RhdGUuZGF5KCldIF07XG5cblx0XHRpZiAoXG5cdFx0XHR2aWV3LmludGVydmFsRHVyYXRpb24uYXMoJ21vbnRocycpID09IDEgJiZcblx0XHRcdGRhdGUubW9udGgoKSAhPSB2aWV3LmludGVydmFsU3RhcnQubW9udGgoKVxuXHRcdCkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1vdGhlci1tb250aCcpO1xuXHRcdH1cblxuXHRcdGlmIChkYXRlLmlzU2FtZSh0b2RheSwgJ2RheScpKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goXG5cdFx0XHRcdCdmYy10b2RheScsXG5cdFx0XHRcdHZpZXcuaGlnaGxpZ2h0U3RhdGVDbGFzc1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZGF0ZSA8IHRvZGF5KSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXBhc3QnKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLWZ1dHVyZScpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBFdmVudC1yZW5kZXJpbmcgYW5kIGV2ZW50LWludGVyYWN0aW9uIG1ldGhvZHMgZm9yIHRoZSBhYnN0cmFjdCBHcmlkIGNsYXNzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuR3JpZC5taXhpbih7XG5cblx0bW91c2VkT3ZlclNlZzogbnVsbCwgLy8gdGhlIHNlZ21lbnQgb2JqZWN0IHRoZSB1c2VyJ3MgbW91c2UgaXMgb3Zlci4gbnVsbCBpZiBvdmVyIG5vdGhpbmdcblx0aXNEcmFnZ2luZ1NlZzogZmFsc2UsIC8vIGlzIGEgc2VnbWVudCBiZWluZyBkcmFnZ2VkPyBib29sZWFuXG5cdGlzUmVzaXppbmdTZWc6IGZhbHNlLCAvLyBpcyBhIHNlZ21lbnQgYmVpbmcgcmVzaXplZD8gYm9vbGVhblxuXHRpc0RyYWdnaW5nRXh0ZXJuYWw6IGZhbHNlLCAvLyBqcXVpLWRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQ/IGJvb2xlYW5cblx0c2VnczogbnVsbCwgLy8gdGhlICpldmVudCogc2VnbWVudHMgY3VycmVudGx5IHJlbmRlcmVkIGluIHRoZSBncmlkLiBUT0RPOiByZW5hbWUgdG8gYGV2ZW50U2Vnc2BcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGV2ZW50cyBvbnRvIHRoZSBncmlkXG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIGJnRXZlbnRzID0gW107XG5cdFx0dmFyIGZnRXZlbnRzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoaXNCZ0V2ZW50KGV2ZW50c1tpXSkgPyBiZ0V2ZW50cyA6IGZnRXZlbnRzKS5wdXNoKGV2ZW50c1tpXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWdzID0gW10uY29uY2F0KCAvLyByZWNvcmQgYWxsIHNlZ3Ncblx0XHRcdHRoaXMucmVuZGVyQmdFdmVudHMoYmdFdmVudHMpLFxuXHRcdFx0dGhpcy5yZW5kZXJGZ0V2ZW50cyhmZ0V2ZW50cylcblx0XHQpO1xuXHR9LFxuXG5cblx0cmVuZGVyQmdFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBzZWdzID0gdGhpcy5ldmVudHNUb1NlZ3MoZXZlbnRzKTtcblxuXHRcdC8vIHJlbmRlckJnU2VncyBtaWdodCByZXR1cm4gYSBzdWJzZXQgb2Ygc2Vncywgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJCZ1NlZ3Moc2VncykgfHwgc2Vncztcblx0fSxcblxuXG5cdHJlbmRlckZnRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuZXZlbnRzVG9TZWdzKGV2ZW50cyk7XG5cblx0XHQvLyByZW5kZXJGZ1NlZ3MgbWlnaHQgcmV0dXJuIGEgc3Vic2V0IG9mIHNlZ3MsIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRmdTZWdzKHNlZ3MpIHx8IHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlU2VnTW91c2VvdXQoKTsgLy8gdHJpZ2dlciBhbiBldmVudE1vdXNlb3V0IGlmIHVzZXIncyBtb3VzZSBpcyBvdmVyIGFuIGV2ZW50XG5cdFx0dGhpcy5jbGVhckRyYWdMaXN0ZW5lcnMoKTtcblxuXHRcdHRoaXMudW5yZW5kZXJGZ1NlZ3MoKTtcblx0XHR0aGlzLnVucmVuZGVyQmdTZWdzKCk7XG5cblx0XHR0aGlzLnNlZ3MgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcblx0fSxcblxuXG5cdC8qIEZvcmVncm91bmQgU2VnbWVudCBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkLiBNYXkgcmV0dXJuIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkLlxuXHRyZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIHNlZ21lbnRzXG5cdHVucmVuZGVyRmdTZWdzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxuXHQvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXG5cdC8vIEEgdXRpbGl0eSB0aGF0IHN1YmNsYXNzZXMgbWF5IHVzZS5cblx0cmVuZGVyRmdTZWdFbHM6IGZ1bmN0aW9uKHNlZ3MsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJlbmRlcmVkU2VncyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MubGVuZ3RoKSB7IC8vIGRvbid0IGJ1aWxkIGFuIGVtcHR5IGh0bWwgc3RyaW5nXG5cblx0XHRcdC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBldmVudCBzZWdtZW50IEhUTUxcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGh0bWwgKz0gdGhpcy5mZ1NlZ0h0bWwoc2Vnc1tpXSwgZGlzYWJsZVJlc2l6aW5nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG5cdFx0XHQvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuIEFuIGVsIG1pZ2h0IGJlIG51bGwgaWYgdGhlIGV2ZW50UmVuZGVyIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlLlxuXHRcdFx0JChodG1sKS5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpIHtcblx0XHRcdFx0dmFyIHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRcdHZhciBlbCA9IHZpZXcucmVzb2x2ZUV2ZW50RWwoc2VnLmV2ZW50LCAkKG5vZGUpKTtcblxuXHRcdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0XHRlbC5kYXRhKCdmYy1zZWcnLCBzZWcpOyAvLyB1c2VkIGJ5IGhhbmRsZXJzXG5cdFx0XHRcdFx0c2VnLmVsID0gZWw7XG5cdFx0XHRcdFx0cmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlcmVkU2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LiBVc2VkIGJ5IHJlbmRlckZnU2VnRWxzKClcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogQmFja2dyb3VuZCBTZWdtZW50IFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gYmFja2dyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkLlxuXHQvLyBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZC5cblx0cmVuZGVyQmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRmlsbCgnYmdFdmVudCcsIHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGJhY2tncm91bmQgZXZlbnQgc2VnbWVudHNcblx0dW5yZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJGaWxsKCdiZ0V2ZW50Jyk7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgYmFja2dyb3VuZCBldmVudCBlbGVtZW50LCBnaXZlbiB0aGUgZGVmYXVsdCByZW5kZXJpbmcuIENhbGxlZCBieSB0aGUgZmlsbCBzeXN0ZW0uXG5cdGJnRXZlbnRTZWdFbDogZnVuY3Rpb24oc2VnLCBlbCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcucmVzb2x2ZUV2ZW50RWwoc2VnLmV2ZW50LCBlbCk7IC8vIHdpbGwgZmlsdGVyIHRocm91Z2ggZXZlbnRSZW5kZXJcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGJhY2tncm91bmQgZXZlbnQuXG5cdC8vIENhbGxlZCBieSB0aGUgZmlsbCBzeXN0ZW0uXG5cdGJnRXZlbnRTZWdDbGFzc2VzOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCB7fTtcblxuXHRcdHJldHVybiBbICdmYy1iZ2V2ZW50JyBdLmNvbmNhdChcblx0XHRcdGV2ZW50LmNsYXNzTmFtZSxcblx0XHRcdHNvdXJjZS5jbGFzc05hbWUgfHwgW11cblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGEgc2VtaWNvbG9uLXNlcGFyYXRlZCBDU1Mgc3RyaW5nIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGJhY2tncm91bmQgZXZlbnQuXG5cdC8vIENhbGxlZCBieSB0aGUgZmlsbCBzeXN0ZW0uXG5cdGJnRXZlbnRTZWdDc3M6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiB7XG5cdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuZ2V0U2VnU2tpbkNzcyhzZWcpWydiYWNrZ3JvdW5kLWNvbG9yJ11cblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIGNsYXNzTmFtZXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlbmRlcmluZyBidXNpbmVzcyBob3VycyBvdmVybGF5LiBDYWxsZWQgYnkgdGhlIGZpbGwgc3lzdGVtLlxuXHRidXNpbmVzc0hvdXJzU2VnQ2xhc3NlczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIFsgJ2ZjLW5vbmJ1c2luZXNzJywgJ2ZjLWJnZXZlbnQnIF07XG5cdH0sXG5cblxuXHQvKiBIYW5kbGVyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQXR0YWNoZXMgZXZlbnQtZWxlbWVudC1yZWxhdGVkIGhhbmRsZXJzIHRvIHRoZSBjb250YWluZXIgZWxlbWVudCBhbmQgbGV2ZXJhZ2UgYnViYmxpbmdcblx0YmluZFNlZ0hhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVTZWdUb3VjaFN0YXJ0KTtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlU2VnVG91Y2hFbmQpO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXIoJ21vdXNlZW50ZXInLCB0aGlzLmhhbmRsZVNlZ01vdXNlb3Zlcik7XG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlcignbW91c2VsZWF2ZScsIHRoaXMuaGFuZGxlU2VnTW91c2VvdXQpO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlU2VnTW91c2Vkb3duKTtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyKCdjbGljaycsIHRoaXMuaGFuZGxlU2VnQ2xpY2spO1xuXHR9LFxuXG5cblx0Ly8gRXhlY3V0ZXMgYSBoYW5kbGVyIGZvciBhbnkgYSB1c2VyLWludGVyYWN0aW9uIG9uIGEgc2VnbWVudC5cblx0Ly8gSGFuZGxlciBnZXRzIGNhbGxlZCB3aXRoIChzZWcsIGV2KSwgYW5kIHdpdGggdGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBHcmlkXG5cdGJpbmRTZWdIYW5kbGVyOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMuZWwub24obmFtZSwgJy5mYy1ldmVudC1jb250YWluZXIgPiAqJywgZnVuY3Rpb24oZXYpIHtcblx0XHRcdHZhciBzZWcgPSAkKHRoaXMpLmRhdGEoJ2ZjLXNlZycpOyAvLyBncmFiIHNlZ21lbnQgZGF0YS4gcHV0IHRoZXJlIGJ5IFZpZXc6OnJlbmRlckV2ZW50c1xuXG5cdFx0XHQvLyBvbmx5IGNhbGwgdGhlIGhhbmRsZXJzIGlmIHRoZXJlIGlzIG5vdCBhIGRyYWcvcmVzaXplIGluIHByb2dyZXNzXG5cdFx0XHRpZiAoc2VnICYmICFfdGhpcy5pc0RyYWdnaW5nU2VnICYmICFfdGhpcy5pc1Jlc2l6aW5nU2VnKSB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIHNlZywgZXYpOyAvLyBjb250ZXh0IHdpbGwgYmUgdGhlIEdyaWRcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXG5cdGhhbmRsZVNlZ0NsaWNrOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy50cmlnZ2VyKCdldmVudENsaWNrJywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTsgLy8gY2FuIHJldHVybiBgZmFsc2VgIHRvIGNhbmNlbFxuXHR9LFxuXG5cblx0Ly8gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMgZm9yIHdoZW4gYW4gZXZlbnQgZWxlbWVudCBpcyBtb3VzZWQgb3ZlclxuXHRoYW5kbGVTZWdNb3VzZW92ZXI6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHRpZiAoXG5cdFx0XHQhdGhpcy5pc0lnbm9yaW5nTW91c2UgJiZcblx0XHRcdCF0aGlzLm1vdXNlZE92ZXJTZWdcblx0XHQpIHtcblx0XHRcdHRoaXMubW91c2VkT3ZlclNlZyA9IHNlZztcblx0XHRcdHNlZy5lbC5hZGRDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XG5cdFx0XHR0aGlzLnZpZXcudHJpZ2dlcignZXZlbnRNb3VzZW92ZXInLCBzZWcuZWxbMF0sIHNlZy5ldmVudCwgZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzIGZvciB3aGVuIGFuIGV2ZW50IGVsZW1lbnQgaXMgbW91c2VkIG91dC5cblx0Ly8gQ2FuIGJlIGdpdmVuIG5vIGFyZ3VtZW50cywgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIG1vdXNlb3V0IHRoZSBzZWdtZW50IHRoYXQgd2FzIHByZXZpb3VzbHkgbW91c2VkIG92ZXIuXG5cdGhhbmRsZVNlZ01vdXNlb3V0OiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0ZXYgPSBldiB8fCB7fTsgLy8gaWYgZ2l2ZW4gbm8gYXJncywgbWFrZSBhIG1vY2sgbW91c2UgZXZlbnRcblxuXHRcdGlmICh0aGlzLm1vdXNlZE92ZXJTZWcpIHtcblx0XHRcdHNlZyA9IHNlZyB8fCB0aGlzLm1vdXNlZE92ZXJTZWc7IC8vIGlmIGdpdmVuIG5vIGFyZ3MsIHVzZSB0aGUgY3VycmVudGx5IG1vdXNlZC1vdmVyIHNlZ21lbnRcblx0XHRcdHRoaXMubW91c2VkT3ZlclNlZyA9IG51bGw7XG5cdFx0XHRzZWcuZWwucmVtb3ZlQ2xhc3MoJ2ZjLWFsbG93LW1vdXNlLXJlc2l6ZScpO1xuXHRcdFx0dGhpcy52aWV3LnRyaWdnZXIoJ2V2ZW50TW91c2VvdXQnLCBzZWcuZWxbMF0sIHNlZy5ldmVudCwgZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZVNlZ01vdXNlZG93bjogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHZhciBpc1Jlc2l6aW5nID0gdGhpcy5zdGFydFNlZ1Jlc2l6ZShzZWcsIGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xuXG5cdFx0aWYgKCFpc1Jlc2l6aW5nICYmIHRoaXMudmlldy5pc0V2ZW50RHJhZ2dhYmxlKHNlZy5ldmVudCkpIHtcblx0XHRcdHRoaXMuYnVpbGRTZWdEcmFnTGlzdGVuZXIoc2VnKVxuXHRcdFx0XHQuc3RhcnRJbnRlcmFjdGlvbihldiwge1xuXHRcdFx0XHRcdGRpc3RhbmNlOiA1XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZVNlZ1RvdWNoU3RhcnQ6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIGlzU2VsZWN0ZWQgPSB2aWV3LmlzRXZlbnRTZWxlY3RlZChldmVudCk7XG5cdFx0dmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RHJhZ2dhYmxlKGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGUgPSB2aWV3LmlzRXZlbnRSZXNpemFibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6aW5nID0gZmFsc2U7XG5cdFx0dmFyIGRyYWdMaXN0ZW5lcjtcblxuXHRcdGlmIChpc1NlbGVjdGVkICYmIGlzUmVzaXphYmxlKSB7XG5cdFx0XHQvLyBvbmx5IGFsbG93IHJlc2l6aW5nIG9mIHRoZSBldmVudCBpcyBzZWxlY3RlZFxuXHRcdFx0aXNSZXNpemluZyA9IHRoaXMuc3RhcnRTZWdSZXNpemUoc2VnLCBldik7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1Jlc2l6aW5nICYmIChpc0RyYWdnYWJsZSB8fCBpc1Jlc2l6YWJsZSkpIHsgLy8gYWxsb3dlZCB0byBiZSBzZWxlY3RlZD9cblxuXHRcdFx0ZHJhZ0xpc3RlbmVyID0gaXNEcmFnZ2FibGUgP1xuXHRcdFx0XHR0aGlzLmJ1aWxkU2VnRHJhZ0xpc3RlbmVyKHNlZykgOlxuXHRcdFx0XHR0aGlzLmJ1aWxkU2VnU2VsZWN0TGlzdGVuZXIoc2VnKTsgLy8gc2VnIGlzbid0IGRyYWdnYWJsZSwgYnV0IHN0aWxsIG5lZWRzIHRvIGJlIHNlbGVjdGVkXG5cblx0XHRcdGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7IC8vIHdvbid0IHN0YXJ0IGlmIGFscmVhZHkgc3RhcnRlZFxuXHRcdFx0XHRkZWxheTogaXNTZWxlY3RlZCA/IDAgOiB0aGlzLnZpZXcub3B0KCdsb25nUHJlc3NEZWxheScpIC8vIGRvIGRlbGF5IGlmIG5vdCBhbHJlYWR5IHNlbGVjdGVkXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBhIGxvbmcgdGFwIHNpbXVsYXRlcyBhIG1vdXNlb3Zlci4gaWdub3JlIHRoaXMgYm9ndXMgbW91c2VvdmVyLlxuXHRcdHRoaXMudGVtcElnbm9yZU1vdXNlKCk7XG5cdH0sXG5cblxuXHRoYW5kbGVTZWdUb3VjaEVuZDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdC8vIHRvdWNoc3RhcnQrdG91Y2hlbmQgPSBjbGljaywgd2hpY2ggc2ltdWxhdGVzIGEgbW91c2VvdmVyLlxuXHRcdC8vIGlnbm9yZSB0aGlzIGJvZ3VzIG1vdXNlb3Zlci5cblx0XHR0aGlzLnRlbXBJZ25vcmVNb3VzZSgpO1xuXHR9LFxuXG5cblx0Ly8gcmV0dXJucyBib29sZWFuIHdoZXRoZXIgcmVzaXppbmcgYWN0dWFsbHkgc3RhcnRlZCBvciBub3QuXG5cdC8vIGFzc3VtZXMgdGhlIHNlZyBhbGxvd3MgcmVzaXppbmcuXG5cdC8vIGBkcmFnT3B0aW9uc2AgYXJlIG9wdGlvbmFsLlxuXHRzdGFydFNlZ1Jlc2l6ZTogZnVuY3Rpb24oc2VnLCBldiwgZHJhZ09wdGlvbnMpIHtcblx0XHRpZiAoJChldi50YXJnZXQpLmlzKCcuZmMtcmVzaXplcicpKSB7XG5cdFx0XHR0aGlzLmJ1aWxkU2VnUmVzaXplTGlzdGVuZXIoc2VnLCAkKGV2LnRhcmdldCkuaXMoJy5mYy1zdGFydC1yZXNpemVyJykpXG5cdFx0XHRcdC5zdGFydEludGVyYWN0aW9uKGV2LCBkcmFnT3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cblxuXHQvKiBFdmVudCBEcmFnZ2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQnVpbGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyYWNrIHVzZXItZHJhZ2dpbmcgb24gYW4gZXZlbnQgc2VnbWVudC5cblx0Ly8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXG5cdC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgc2VnRHJhZ0xpc3RlbmVyYFxuXHRidWlsZFNlZ0RyYWdMaXN0ZW5lcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xuXHRcdHZhciBlbCA9IHNlZy5lbDtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIGlzRHJhZ2dpbmc7XG5cdFx0dmFyIG1vdXNlRm9sbG93ZXI7IC8vIEEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCB3aWxsIG1vdmUgd2l0aCB0aGUgbW91c2Vcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXNcblxuXHRcdGlmICh0aGlzLnNlZ0RyYWdMaXN0ZW5lcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VnRHJhZ0xpc3RlbmVyO1xuXHRcdH1cblxuXHRcdC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqdmlldydzKiBjb29yZGluYXRlIG1hcC4gQWxsb3dzIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBiZXR3ZWVuIHN1YmNvbXBvbmVudHNcblx0XHQvLyBvZiB0aGUgdmlldy5cblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5zZWdEcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyKHZpZXcsIHtcblx0XHRcdHNjcm9sbDogdmlldy5vcHQoJ2RyYWdTY3JvbGwnKSxcblx0XHRcdHN1YmplY3RFbDogZWwsXG5cdFx0XHRzdWJqZWN0Q2VudGVyOiB0cnVlLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyID0gbmV3IE1vdXNlRm9sbG93ZXIoc2VnLmVsLCB7XG5cdFx0XHRcdFx0YWRkaXRpb25hbENsYXNzOiAnZmMtZHJhZ2dpbmcnLFxuXHRcdFx0XHRcdHBhcmVudEVsOiB2aWV3LmVsLFxuXHRcdFx0XHRcdG9wYWNpdHk6IGRyYWdMaXN0ZW5lci5pc1RvdWNoID8gbnVsbCA6IHZpZXcub3B0KCdkcmFnT3BhY2l0eScpLFxuXHRcdFx0XHRcdHJldmVydER1cmF0aW9uOiB2aWV3Lm9wdCgnZHJhZ1JldmVydER1cmF0aW9uJyksXG5cdFx0XHRcdFx0ekluZGV4OiAyIC8vIG9uZSBhYm92ZSB0aGUgLmZjLXZpZXdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBkb24ndCBzaG93IHVudGlsIHdlIGtub3cgdGhpcyBpcyBhIHJlYWwgZHJhZ1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyLnN0YXJ0KGV2KTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJiAhdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XG5cdFx0XHRcdFx0dmlldy5zZWxlY3RFdmVudChldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNEcmFnZ2luZyA9IHRydWU7XG5cdFx0XHRcdF90aGlzLmhhbmRsZVNlZ01vdXNlb3V0KHNlZywgZXYpOyAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ1N0YXJ0KHNlZywgZXYpO1xuXHRcdFx0XHR2aWV3LmhpZGVFdmVudChldmVudCk7IC8vIGhpZGUgYWxsIGV2ZW50IHNlZ21lbnRzLiBvdXIgbW91c2VGb2xsb3dlciB3aWxsIHRha2Ugb3ZlclxuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XG5cdFx0XHRcdHZhciBkcmFnSGVscGVyRWxzO1xuXG5cdFx0XHRcdC8vIHN0YXJ0aW5nIGhpdCBjb3VsZCBiZSBmb3JjZWQgKERheUdyaWQubGltaXQpXG5cdFx0XHRcdGlmIChzZWcuaGl0KSB7XG5cdFx0XHRcdFx0b3JpZ0hpdCA9IHNlZy5oaXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzaW5jZSB3ZSBhcmUgcXVlcnlpbmcgdGhlIHBhcmVudCB2aWV3LCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZFxuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSBfdGhpcy5jb21wdXRlRXZlbnREcm9wKFxuXHRcdFx0XHRcdG9yaWdIaXQuY29tcG9uZW50LmdldEhpdFNwYW4ob3JpZ0hpdCksXG5cdFx0XHRcdFx0aGl0LmNvbXBvbmVudC5nZXRIaXRTcGFuKGhpdCksXG5cdFx0XHRcdFx0ZXZlbnRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uICYmICFjYWxlbmRhci5pc0V2ZW50U3BhbkFsbG93ZWQoX3RoaXMuZXZlbnRUb1NwYW4oZHJvcExvY2F0aW9uKSwgZXZlbnQpKSB7XG5cdFx0XHRcdFx0ZGlzYWJsZUN1cnNvcigpO1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBhIHZhbGlkIGRyb3AgbG9jYXRpb24sIGhhdmUgdGhlIHN1YmNsYXNzIHJlbmRlciBhIHZpc3VhbCBpbmRpY2F0aW9uXG5cdFx0XHRcdGlmIChkcm9wTG9jYXRpb24gJiYgKGRyYWdIZWxwZXJFbHMgPSB2aWV3LnJlbmRlckRyYWcoZHJvcExvY2F0aW9uLCBzZWcpKSkge1xuXG5cdFx0XHRcdFx0ZHJhZ0hlbHBlckVscy5hZGRDbGFzcygnZmMtZHJhZ2dpbmcnKTtcblx0XHRcdFx0XHRpZiAoIWRyYWdMaXN0ZW5lci5pc1RvdWNoKSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5hcHBseURyYWdPcGFjaXR5KGRyYWdIZWxwZXJFbHMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBpZiB0aGUgc3ViY2xhc3MgaXMgYWxyZWFkeSB1c2luZyBhIG1vY2sgZXZlbnQgXCJoZWxwZXJcIiwgaGlkZSBvdXIgb3duXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bW91c2VGb2xsb3dlci5zaG93KCk7IC8vIG90aGVyd2lzZSwgaGF2ZSB0aGUgaGVscGVyIGZvbGxvdyB0aGUgbW91c2UgKG5vIHNuYXBwaW5nKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzT3JpZykge1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7IC8vIG5lZWRzIHRvIGhhdmUgbW92ZWQgaGl0cyB0byBiZSBhIHZhbGlkIGRyb3Bcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7IC8vIGNhbGxlZCBiZWZvcmUgbW91c2UgbW92ZXMgdG8gYSBkaWZmZXJlbnQgaGl0IE9SIG1vdmVkIG91dCBvZiBhbGwgaGl0c1xuXHRcdFx0XHR2aWV3LnVucmVuZGVyRHJhZygpOyAvLyB1bnJlbmRlciB3aGF0ZXZlciB3YXMgZG9uZSBpbiByZW5kZXJEcmFnXG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBzaG93IGluIGNhc2Ugd2UgYXJlIG1vdmluZyBvdXQgb2YgYWxsIGhpdHNcblx0XHRcdFx0ZHJvcExvY2F0aW9uID0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gQ2FsbGVkIGFmdGVyIGEgaGl0T3V0IE9SIGJlZm9yZSBhIGRyYWdFbmRcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdC8vIGRvIHJldmVydCBhbmltYXRpb24gaWYgaGFzbid0IGNoYW5nZWQuIGNhbGxzIGEgY2FsbGJhY2sgd2hlbiBmaW5pc2hlZCAod2hldGhlciBhbmltYXRpb24gb3Igbm90KVxuXHRcdFx0XHRtb3VzZUZvbGxvd2VyLnN0b3AoIWRyb3BMb2NhdGlvbiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKGlzRHJhZ2dpbmcpIHtcblx0XHRcdFx0XHRcdHZpZXcudW5yZW5kZXJEcmFnKCk7XG5cdFx0XHRcdFx0XHR2aWV3LnNob3dFdmVudChldmVudCk7XG5cdFx0XHRcdFx0XHRfdGhpcy5zZWdEcmFnU3RvcChzZWcsIGV2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRyb3BMb2NhdGlvbikge1xuXHRcdFx0XHRcdFx0dmlldy5yZXBvcnRFdmVudERyb3AoZXZlbnQsIGRyb3BMb2NhdGlvbiwgdGhpcy5sYXJnZVVuaXQsIGVsLCBldik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBzZWcgaXNuJ3QgZHJhZ2dhYmxlLCBidXQgbGV0J3MgdXNlIGEgZ2VuZXJpYyBEcmFnTGlzdGVuZXJcblx0Ly8gc2ltcGx5IGZvciB0aGUgZGVsYXksIHNvIGl0IGNhbiBiZSBzZWxlY3RlZC5cblx0Ly8gSGFzIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcvdW5zZXR0aW5nIGBzZWdEcmFnTGlzdGVuZXJgXG5cdGJ1aWxkU2VnU2VsZWN0TGlzdGVuZXI6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXG5cdFx0aWYgKHRoaXMuc2VnRHJhZ0xpc3RlbmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWdEcmFnTGlzdGVuZXI7XG5cdFx0fVxuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbmV3IERyYWdMaXN0ZW5lcih7XG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJiAhdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XG5cdFx0XHRcdFx0dmlldy5zZWxlY3RFdmVudChldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgYmVmb3JlIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RhcnRzXG5cdHNlZ0RyYWdTdGFydDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHRoaXMuaXNEcmFnZ2luZ1NlZyA9IHRydWU7XG5cdFx0dGhpcy52aWV3LnRyaWdnZXIoJ2V2ZW50RHJhZ1N0YXJ0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2LCB7fSk7IC8vIGxhc3QgYXJndW1lbnQgaXMganF1aSBkdW1teVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RvcHNcblx0c2VnRHJhZ1N0b3A6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR0aGlzLmlzRHJhZ2dpbmdTZWcgPSBmYWxzZTtcblx0XHR0aGlzLnZpZXcudHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBzcGFucyBhbiBldmVudCBkcmFnIGJlZ2FuLCBhbmQgdGhlIHNwYW4gZXZlbnQgd2FzIGRyb3BwZWQsIGNhbGN1bGF0ZXMgdGhlIG5ldyB6b25lZCBzdGFydC9lbmQvYWxsRGF5XG5cdC8vIHZhbHVlcyBmb3IgdGhlIGV2ZW50LiBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSBhbmQgc2V0IGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSB1c2VkIGJ5IHJlbmRlckRyYWcuXG5cdC8vIEEgZmFsc3kgcmV0dXJuZWQgdmFsdWUgaW5kaWNhdGVzIGFuIGludmFsaWQgZHJvcC5cblx0Ly8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxuXHRjb21wdXRlRXZlbnREcm9wOiBmdW5jdGlvbihzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xuXHRcdHZhciBkcmFnU3RhcnQgPSBzdGFydFNwYW4uc3RhcnQ7XG5cdFx0dmFyIGRyYWdFbmQgPSBlbmRTcGFuLnN0YXJ0O1xuXHRcdHZhciBkZWx0YTtcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXNcblxuXHRcdGlmIChkcmFnU3RhcnQuaGFzVGltZSgpID09PSBkcmFnRW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0ZGVsdGEgPSB0aGlzLmRpZmZEYXRlcyhkcmFnRW5kLCBkcmFnU3RhcnQpO1xuXG5cdFx0XHQvLyBpZiBhbiBhbGwtZGF5IGV2ZW50IHdhcyBpbiBhIHRpbWVkIGFyZWEgYW5kIGl0IHdhcyBkcmFnZ2VkIHRvIGEgZGlmZmVyZW50IHRpbWUsXG5cdFx0XHQvLyBndWFyYW50ZWUgYW4gZW5kIGFuZCBhZGp1c3Qgc3RhcnQvZW5kIHRvIGhhdmUgdGltZXNcblx0XHRcdGlmIChldmVudC5hbGxEYXkgJiYgZHVyYXRpb25IYXNUaW1lKGRlbHRhKSkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSB7XG5cdFx0XHRcdFx0c3RhcnQ6IGV2ZW50LnN0YXJ0LmNsb25lKCksXG5cdFx0XHRcdFx0ZW5kOiBjYWxlbmRhci5nZXRFdmVudEVuZChldmVudCksIC8vIHdpbGwgYmUgYW4gYW1iaWcgZGF5XG5cdFx0XHRcdFx0YWxsRGF5OiBmYWxzZSAvLyBmb3Igbm9ybWFsaXplRXZlbnRUaW1lc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjYWxlbmRhci5ub3JtYWxpemVFdmVudFRpbWVzKGRyb3BMb2NhdGlvbik7XG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhld2lzZSwgd29yayBvZmYgZXhpc3RpbmcgdmFsdWVzXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZHJvcExvY2F0aW9uID0ge1xuXHRcdFx0XHRcdHN0YXJ0OiBldmVudC5zdGFydC5jbG9uZSgpLFxuXHRcdFx0XHRcdGVuZDogZXZlbnQuZW5kID8gZXZlbnQuZW5kLmNsb25lKCkgOiBudWxsLFxuXHRcdFx0XHRcdGFsbERheTogZXZlbnQuYWxsRGF5IC8vIGtlZXAgaXQgdGhlIHNhbWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0ZHJvcExvY2F0aW9uLnN0YXJ0LmFkZChkZWx0YSk7XG5cdFx0XHRpZiAoZHJvcExvY2F0aW9uLmVuZCkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24uZW5kLmFkZChkZWx0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gaWYgc3dpdGNoaW5nIGZyb20gZGF5IDwtPiB0aW1lZCwgc3RhcnQgc2hvdWxkIGJlIHJlc2V0IHRvIHRoZSBkcm9wcGVkIGRhdGUsIGFuZCB0aGUgZW5kIGNsZWFyZWRcblx0XHRcdGRyb3BMb2NhdGlvbiA9IHtcblx0XHRcdFx0c3RhcnQ6IGRyYWdFbmQuY2xvbmUoKSxcblx0XHRcdFx0ZW5kOiBudWxsLCAvLyBlbmQgc2hvdWxkIGJlIGNsZWFyZWRcblx0XHRcdFx0YWxsRGF5OiAhZHJhZ0VuZC5oYXNUaW1lKClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRyb3BMb2NhdGlvbjtcblx0fSxcblxuXG5cdC8vIFV0aWxpdHkgZm9yIGFwcGx5IGRyYWdPcGFjaXR5IHRvIGEgalF1ZXJ5IHNldFxuXHRhcHBseURyYWdPcGFjaXR5OiBmdW5jdGlvbihlbHMpIHtcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMudmlldy5vcHQoJ2RyYWdPcGFjaXR5Jyk7XG5cblx0XHRpZiAob3BhY2l0eSAhPSBudWxsKSB7XG5cdFx0XHRlbHMuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHRcdC8vIERvbid0IHVzZSBqUXVlcnkgKHdpbGwgc2V0IGFuIElFIGZpbHRlciksIGRvIGl0IHRoZSBvbGQgZmFzaGlvbmVkIHdheS5cblx0XHRcdFx0Ly8gSW4gSUU4LCBhIGhlbHBlciBlbGVtZW50IHdpbGwgZGlzYXBwZWFycyBpZiB0aGVyZSdzIGEgZmlsdGVyLlxuXHRcdFx0XHRub2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRXh0ZXJuYWwgRWxlbWVudCBEcmFnZ2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBpcyBpbml0aWF0ZWQgYW55d2hlcmUgaW4gdGhlIERPTVxuXHRleHRlcm5hbERyYWdTdGFydDogZnVuY3Rpb24oZXYsIHVpKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGVsO1xuXHRcdHZhciBhY2NlcHQ7XG5cblx0XHRpZiAodmlldy5vcHQoJ2Ryb3BwYWJsZScpKSB7IC8vIG9ubHkgbGlzdGVuIGlmIHRoaXMgc2V0dGluZyBpcyBvblxuXHRcdFx0ZWwgPSAkKCh1aSA/IHVpLml0ZW0gOiBudWxsKSB8fCBldi50YXJnZXQpO1xuXG5cdFx0XHQvLyBUZXN0IHRoYXQgdGhlIGRyYWdnZWQgZWxlbWVudCBwYXNzZXMgdGhlIGRyb3BBY2NlcHQgc2VsZWN0b3Igb3IgZmlsdGVyIGZ1bmN0aW9uLlxuXHRcdFx0Ly8gRllJLCB0aGUgZGVmYXVsdCBpcyBcIipcIiAobWF0Y2hlcyBhbGwpXG5cdFx0XHRhY2NlcHQgPSB2aWV3Lm9wdCgnZHJvcEFjY2VwdCcpO1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbihhY2NlcHQpID8gYWNjZXB0LmNhbGwoZWxbMF0sIGVsKSA6IGVsLmlzKGFjY2VwdCkpIHtcblx0XHRcdFx0aWYgKCF0aGlzLmlzRHJhZ2dpbmdFeHRlcm5hbCkgeyAvLyBwcmV2ZW50IGRvdWJsZS1saXN0ZW5pbmcgaWYgZmlyZWQgdHdpY2Vcblx0XHRcdFx0XHR0aGlzLmxpc3RlblRvRXh0ZXJuYWxEcmFnKGVsLCBldiwgdWkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBzdGFydHMgYW5kIGl0IG5lZWRzIHRvIGJlIG1vbml0b3JlZCBmb3IgZHJvcHBpbmdcblx0bGlzdGVuVG9FeHRlcm5hbERyYWc6IGZ1bmN0aW9uKGVsLCBldiwgdWkpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgbWV0YSA9IGdldERyYWdnZWRFbE1ldGEoZWwpOyAvLyBleHRyYSBkYXRhIGFib3V0IGV2ZW50IGRyb3AsIGluY2x1ZGluZyBwb3NzaWJsZSBldmVudCB0byBjcmVhdGVcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiB1bnN1Y2Nlc3NmdWwgZHJhZ1xuXG5cdFx0Ly8gbGlzdGVuZXIgdGhhdCB0cmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciBkYXRlLWFzc29jaWF0ZWQgcGl4ZWwgcmVnaW9uc1xuXHRcdHZhciBkcmFnTGlzdGVuZXIgPSBfdGhpcy5leHRlcm5hbERyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXIodGhpcywge1xuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aGlzLmlzRHJhZ2dpbmdFeHRlcm5hbCA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3ZlcjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0XHRcdGRyb3BMb2NhdGlvbiA9IF90aGlzLmNvbXB1dGVFeHRlcm5hbERyb3AoXG5cdFx0XHRcdFx0aGl0LmNvbXBvbmVudC5nZXRIaXRTcGFuKGhpdCksIC8vIHNpbmNlIHdlIGFyZSBxdWVyeWluZyB0aGUgcGFyZW50IHZpZXcsIG1pZ2h0IG5vdCBiZWxvbmcgdG8gdGhpcyBncmlkXG5cdFx0XHRcdFx0bWV0YVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggLy8gaW52YWxpZCBoaXQ/XG5cdFx0XHRcdFx0ZHJvcExvY2F0aW9uICYmXG5cdFx0XHRcdFx0IWNhbGVuZGFyLmlzRXh0ZXJuYWxTcGFuQWxsb3dlZChfdGhpcy5ldmVudFRvU3Bhbihkcm9wTG9jYXRpb24pLCBkcm9wTG9jYXRpb24sIG1ldGEuZXZlbnRQcm9wcylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGlzYWJsZUN1cnNvcigpO1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uKSB7XG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyRHJhZyhkcm9wTG9jYXRpb24pOyAvLyBjYWxsZWQgd2l0aG91dCBhIHNlZyBwYXJhbWV0ZXJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7IC8vIHNpZ25hbCB1bnN1Y2Nlc3NmdWxcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gQ2FsbGVkIGFmdGVyIGEgaGl0T3V0IE9SIGJlZm9yZSBhIGRyYWdFbmRcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdF90aGlzLnVucmVuZGVyRHJhZygpO1xuXHRcdFx0fSxcblx0XHRcdGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uKSB7IC8vIGVsZW1lbnQgd2FzIGRyb3BwZWQgb24gYSB2YWxpZCBoaXRcblx0XHRcdFx0XHRfdGhpcy52aWV3LnJlcG9ydEV4dGVybmFsRHJvcChtZXRhLCBkcm9wTG9jYXRpb24sIGVsLCBldiwgdWkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aGlzLmlzRHJhZ2dpbmdFeHRlcm5hbCA9IGZhbHNlO1xuXHRcdFx0XHRfdGhpcy5leHRlcm5hbERyYWdMaXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRkcmFnTGlzdGVuZXIuc3RhcnREcmFnKGV2KTsgLy8gc3RhcnQgbGlzdGVuaW5nIGltbWVkaWF0ZWx5XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGhpdCB0byBiZSBkcm9wcGVkIHVwb24sIGFuZCBtaXNjIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBqcXVpIGRyYWcgKGd1YXJhbnRlZWQgdG8gYmUgYSBwbGFpbiBvYmplY3QpLFxuXHQvLyByZXR1cm5zIHRoZSB6b25lZCBzdGFydC9lbmQgZGF0ZXMgZm9yIHRoZSBldmVudCB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIHRoZSBoeXBvdGhldGljYWwgZHJvcC4gZW5kIG1pZ2h0IGJlIG51bGwuXG5cdC8vIFJldHVybmluZyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiBpbnZhbGlkIGRyb3AgaGl0LlxuXHQvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnQuXG5cdGNvbXB1dGVFeHRlcm5hbERyb3A6IGZ1bmN0aW9uKHNwYW4sIG1ldGEpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGRyb3BMb2NhdGlvbiA9IHtcblx0XHRcdHN0YXJ0OiBjYWxlbmRhci5hcHBseVRpbWV6b25lKHNwYW4uc3RhcnQpLCAvLyBzaW11bGF0ZSBhIHpvbmVkIGV2ZW50IHN0YXJ0IGRhdGVcblx0XHRcdGVuZDogbnVsbFxuXHRcdH07XG5cblx0XHQvLyBpZiBkcm9wcGVkIG9uIGFuIGFsbC1kYXkgc3BhbiwgYW5kIGVsZW1lbnQncyBtZXRhZGF0YSBzcGVjaWZpZWQgYSB0aW1lLCBzZXQgaXRcblx0XHRpZiAobWV0YS5zdGFydFRpbWUgJiYgIWRyb3BMb2NhdGlvbi5zdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdGRyb3BMb2NhdGlvbi5zdGFydC50aW1lKG1ldGEuc3RhcnRUaW1lKTtcblx0XHR9XG5cblx0XHRpZiAobWV0YS5kdXJhdGlvbikge1xuXHRcdFx0ZHJvcExvY2F0aW9uLmVuZCA9IGRyb3BMb2NhdGlvbi5zdGFydC5jbG9uZSgpLmFkZChtZXRhLmR1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZHJvcExvY2F0aW9uO1xuXHR9LFxuXG5cblxuXHQvKiBEcmFnIFJlbmRlcmluZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBhbiBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbCBlbGVtZW50IGJlaW5nIGRyYWdnZWQuXG5cdC8vIGBkcm9wTG9jYXRpb25gIGNvbnRhaW5zIGh5cG90aGV0aWNhbCBzdGFydC9lbmQvYWxsRGF5IHZhbHVlcyB0aGUgZXZlbnQgd291bGQgaGF2ZSBpZiBkcm9wcGVkLiBlbmQgY2FuIGJlIG51bGwuXG5cdC8vIGBzZWdgIGlzIHRoZSBpbnRlcm5hbCBzZWdtZW50IG9iamVjdCB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIElmIGRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQsIGBzZWdgIGlzIG51bGwuXG5cdC8vIEEgdHJ1dGh5IHJldHVybmVkIHZhbHVlIGluZGljYXRlcyB0aGlzIG1ldGhvZCBoYXMgcmVuZGVyZWQgYSBoZWxwZXIgZWxlbWVudC5cblx0Ly8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihkcm9wTG9jYXRpb24sIHNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIFJlc2l6aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIgYXMgdGhleSByZXNpemUgYW4gZXZlbnQgc2VnbWVudC5cblx0Ly8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXG5cdGJ1aWxkU2VnUmVzaXplTGlzdGVuZXI6IGZ1bmN0aW9uKHNlZywgaXNTdGFydCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZWwgPSBzZWcuZWw7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBldmVudEVuZCA9IGNhbGVuZGFyLmdldEV2ZW50RW5kKGV2ZW50KTtcblx0XHR2YXIgaXNEcmFnZ2luZztcblx0XHR2YXIgcmVzaXplTG9jYXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllcy4gZmFsc3kgaWYgaW52YWxpZCByZXNpemVcblxuXHRcdC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqZ3JpZCdzKiBjb29yZGluYXRlIG1hcFxuXHRcdHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLnNlZ1Jlc2l6ZUxpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih0aGlzLCB7XG5cdFx0XHRzY3JvbGw6IHZpZXcub3B0KCdkcmFnU2Nyb2xsJyksXG5cdFx0XHRzdWJqZWN0RWw6IGVsLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlzRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlzRHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0XHRfdGhpcy5oYW5kbGVTZWdNb3VzZW91dChzZWcsIGV2KTsgLy8gZW5zdXJlIGEgbW91c2VvdXQgb24gdGhlIG1hbmlwdWxhdGVkIGV2ZW50IGhhcyBiZWVuIHJlcG9ydGVkXG5cdFx0XHRcdF90aGlzLnNlZ1Jlc2l6ZVN0YXJ0KHNlZywgZXYpO1xuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XG5cdFx0XHRcdHZhciBvcmlnSGl0U3BhbiA9IF90aGlzLmdldEhpdFNwYW4ob3JpZ0hpdCk7XG5cdFx0XHRcdHZhciBoaXRTcGFuID0gX3RoaXMuZ2V0SGl0U3BhbihoaXQpO1xuXG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uID0gaXNTdGFydCA/XG5cdFx0XHRcdFx0X3RoaXMuY29tcHV0ZUV2ZW50U3RhcnRSZXNpemUob3JpZ0hpdFNwYW4sIGhpdFNwYW4sIGV2ZW50KSA6XG5cdFx0XHRcdFx0X3RoaXMuY29tcHV0ZUV2ZW50RW5kUmVzaXplKG9yaWdIaXRTcGFuLCBoaXRTcGFuLCBldmVudCk7XG5cblx0XHRcdFx0aWYgKHJlc2l6ZUxvY2F0aW9uKSB7XG5cdFx0XHRcdFx0aWYgKCFjYWxlbmRhci5pc0V2ZW50U3BhbkFsbG93ZWQoX3RoaXMuZXZlbnRUb1NwYW4ocmVzaXplTG9jYXRpb24pLCBldmVudCkpIHtcblx0XHRcdFx0XHRcdGRpc2FibGVDdXJzb3IoKTtcblx0XHRcdFx0XHRcdHJlc2l6ZUxvY2F0aW9uID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gbm8gY2hhbmdlPyAoVE9ETzogaG93IGRvZXMgdGhpcyB3b3JrIHdpdGggdGltZXpvbmVzPylcblx0XHRcdFx0XHRlbHNlIGlmIChyZXNpemVMb2NhdGlvbi5zdGFydC5pc1NhbWUoZXZlbnQuc3RhcnQpICYmIHJlc2l6ZUxvY2F0aW9uLmVuZC5pc1NhbWUoZXZlbnRFbmQpKSB7XG5cdFx0XHRcdFx0XHRyZXNpemVMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlc2l6ZUxvY2F0aW9uKSB7XG5cdFx0XHRcdFx0dmlldy5oaWRlRXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdF90aGlzLnJlbmRlckV2ZW50UmVzaXplKHJlc2l6ZUxvY2F0aW9uLCBzZWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGJlZm9yZSBtb3VzZSBtb3ZlcyB0byBhIGRpZmZlcmVudCBoaXQgT1IgbW92ZWQgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uID0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gcmVzZXRzIHRoZSByZW5kZXJpbmcgdG8gc2hvdyB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRcdFx0X3RoaXMudW5yZW5kZXJFdmVudFJlc2l6ZSgpO1xuXHRcdFx0XHR2aWV3LnNob3dFdmVudChldmVudCk7XG5cdFx0XHRcdGVuYWJsZUN1cnNvcigpO1xuXHRcdFx0fSxcblx0XHRcdGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRpZiAoaXNEcmFnZ2luZykge1xuXHRcdFx0XHRcdF90aGlzLnNlZ1Jlc2l6ZVN0b3Aoc2VnLCBldik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc2l6ZUxvY2F0aW9uKSB7IC8vIHZhbGlkIGRhdGUgdG8gcmVzaXplIHRvP1xuXHRcdFx0XHRcdHZpZXcucmVwb3J0RXZlbnRSZXNpemUoZXZlbnQsIHJlc2l6ZUxvY2F0aW9uLCB0aGlzLmxhcmdlVW5pdCwgZWwsIGV2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGhpcy5zZWdSZXNpemVMaXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZHJhZ0xpc3RlbmVyO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0YXJ0c1xuXHRzZWdSZXNpemVTdGFydDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHRoaXMuaXNSZXNpemluZ1NlZyA9IHRydWU7XG5cdFx0dGhpcy52aWV3LnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RhcnQnLCBzZWcuZWxbMF0sIHNlZy5ldmVudCwgZXYsIHt9KTsgLy8gbGFzdCBhcmd1bWVudCBpcyBqcXVpIGR1bW15XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgYWZ0ZXIgZXZlbnQgc2VnbWVudCByZXNpemluZyBzdG9wc1xuXHRzZWdSZXNpemVTdG9wOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dGhpcy5pc1Jlc2l6aW5nU2VnID0gZmFsc2U7XG5cdFx0dGhpcy52aWV3LnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBzdGFydFxuXHRjb21wdXRlRXZlbnRTdGFydFJlc2l6ZTogZnVuY3Rpb24oc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmNvbXB1dGVFdmVudFJlc2l6ZSgnc3RhcnQnLCBzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBlbmRcblx0Y29tcHV0ZUV2ZW50RW5kUmVzaXplOiBmdW5jdGlvbihzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuY29tcHV0ZUV2ZW50UmVzaXplKCdlbmQnLCBzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgbmV3IHpvbmVkIGRhdGUgaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBzdGFydCBPUiBlbmRcblx0Ly8gYHR5cGVgIGlzIGVpdGhlciAnc3RhcnQnIG9yICdlbmQnLlxuXHQvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnQuXG5cdGNvbXB1dGVFdmVudFJlc2l6ZTogZnVuY3Rpb24odHlwZSwgc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCkge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZEYXRlcyhlbmRTcGFuW3R5cGVdLCBzdGFydFNwYW5bdHlwZV0pO1xuXHRcdHZhciByZXNpemVMb2NhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGRlZmF1bHREdXJhdGlvbjtcblxuXHRcdC8vIGJ1aWxkIG9yaWdpbmFsIHZhbHVlcyB0byB3b3JrIGZyb20sIGd1YXJhbnRlZWluZyBhIHN0YXJ0IGFuZCBlbmRcblx0XHRyZXNpemVMb2NhdGlvbiA9IHtcblx0XHRcdHN0YXJ0OiBldmVudC5zdGFydC5jbG9uZSgpLFxuXHRcdFx0ZW5kOiBjYWxlbmRhci5nZXRFdmVudEVuZChldmVudCksXG5cdFx0XHRhbGxEYXk6IGV2ZW50LmFsbERheVxuXHRcdH07XG5cblx0XHQvLyBpZiBhbiBhbGwtZGF5IGV2ZW50IHdhcyBpbiBhIHRpbWVkIGFyZWEgYW5kIHdhcyByZXNpemVkIHRvIGEgdGltZSwgYWRqdXN0IHN0YXJ0L2VuZCB0byBoYXZlIHRpbWVzXG5cdFx0aWYgKHJlc2l6ZUxvY2F0aW9uLmFsbERheSAmJiBkdXJhdGlvbkhhc1RpbWUoZGVsdGEpKSB7XG5cdFx0XHRyZXNpemVMb2NhdGlvbi5hbGxEYXkgPSBmYWxzZTtcblx0XHRcdGNhbGVuZGFyLm5vcm1hbGl6ZUV2ZW50VGltZXMocmVzaXplTG9jYXRpb24pO1xuXHRcdH1cblxuXHRcdHJlc2l6ZUxvY2F0aW9uW3R5cGVdLmFkZChkZWx0YSk7IC8vIGFwcGx5IGRlbHRhIHRvIHN0YXJ0IG9yIGVuZFxuXG5cdFx0Ly8gaWYgdGhlIGV2ZW50IHdhcyBjb21wcmVzc2VkIHRvbyBzbWFsbCwgZmluZCBhIG5ldyByZWFzb25hYmxlIGR1cmF0aW9uIGZvciBpdFxuXHRcdGlmICghcmVzaXplTG9jYXRpb24uc3RhcnQuaXNCZWZvcmUocmVzaXplTG9jYXRpb24uZW5kKSkge1xuXG5cdFx0XHRkZWZhdWx0RHVyYXRpb24gPVxuXHRcdFx0XHR0aGlzLm1pblJlc2l6ZUR1cmF0aW9uIHx8IC8vIFRPRE86IGhhY2tcblx0XHRcdFx0KGV2ZW50LmFsbERheSA/XG5cdFx0XHRcdFx0Y2FsZW5kYXIuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuXHRcdFx0XHRcdGNhbGVuZGFyLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuXG5cdFx0XHRpZiAodHlwZSA9PSAnc3RhcnQnKSB7IC8vIHJlc2l6aW5nIHRoZSBzdGFydD9cblx0XHRcdFx0cmVzaXplTG9jYXRpb24uc3RhcnQgPSByZXNpemVMb2NhdGlvbi5lbmQuY2xvbmUoKS5zdWJ0cmFjdChkZWZhdWx0RHVyYXRpb24pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIHJlc2l6aW5nIHRoZSBlbmQ/XG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uLmVuZCA9IHJlc2l6ZUxvY2F0aW9uLnN0YXJ0LmNsb25lKCkuYWRkKGRlZmF1bHREdXJhdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc2l6ZUxvY2F0aW9uO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXG5cdC8vIGByYW5nZWAgaGFzIHRoZSB1cGRhdGVkIGRhdGVzIG9mIHRoZSBldmVudC4gYHNlZ2AgaXMgdGhlIG9yaWdpbmFsIHNlZ21lbnQgb2JqZWN0IGludm9sdmVkIGluIHRoZSBkcmFnLlxuXHQvLyBNdXN0IHJldHVybiBlbGVtZW50cyB1c2VkIGZvciBhbnkgbW9jayBldmVudHMuXG5cdHJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbihyYW5nZSwgc2VnKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZC5cblx0dW5yZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogUmVuZGVyaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlIHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBvbiBhbiBldmVudCdzIGVsZW1lbnQuXG5cdC8vIGByYW5nZWAgY2FuIGJlIHRoZSBFdmVudCBvYmplY3QgaXRzZWxmLCBvciBzb21ldGhpbmcgcmFuZ2UtbGlrZSwgd2l0aCBhdCBsZWFzdCBhIGBzdGFydGAuXG5cdC8vIElmIGV2ZW50IHRpbWVzIGFyZSBkaXNhYmxlZCwgb3IgdGhlIGV2ZW50IGhhcyBubyB0aW1lLCB3aWxsIHJldHVybiBhIGJsYW5rIHN0cmluZy5cblx0Ly8gSWYgbm90IHNwZWNpZmllZCwgZm9ybWF0U3RyIHdpbGwgZGVmYXVsdCB0byB0aGUgZXZlbnRUaW1lRm9ybWF0IHNldHRpbmcsXG5cdC8vIGFuZCBkaXNwbGF5RW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgZGlzcGxheUV2ZW50RW5kIHNldHRpbmcuXG5cdGdldEV2ZW50VGltZVRleHQ6IGZ1bmN0aW9uKHJhbmdlLCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcblxuXHRcdGlmIChmb3JtYXRTdHIgPT0gbnVsbCkge1xuXHRcdFx0Zm9ybWF0U3RyID0gdGhpcy5ldmVudFRpbWVGb3JtYXQ7XG5cdFx0fVxuXG5cdFx0aWYgKGRpc3BsYXlFbmQgPT0gbnVsbCkge1xuXHRcdFx0ZGlzcGxheUVuZCA9IHRoaXMuZGlzcGxheUV2ZW50RW5kO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgJiYgcmFuZ2Uuc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRpZiAoZGlzcGxheUVuZCAmJiByYW5nZS5lbmQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmlldy5mb3JtYXRSYW5nZShyYW5nZSwgZm9ybWF0U3RyKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmFuZ2Uuc3RhcnQuZm9ybWF0KGZvcm1hdFN0cik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJpYyB1dGlsaXR5IGZvciBnZW5lcmF0aW5nIHRoZSBIVE1MIGNsYXNzTmFtZXMgZm9yIGFuIGV2ZW50IHNlZ21lbnQncyBlbGVtZW50XG5cdGdldFNlZ0NsYXNzZXM6IGZ1bmN0aW9uKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBjbGFzc2VzID0gW1xuXHRcdFx0J2ZjLWV2ZW50Jyxcblx0XHRcdHNlZy5pc1N0YXJ0ID8gJ2ZjLXN0YXJ0JyA6ICdmYy1ub3Qtc3RhcnQnLFxuXHRcdFx0c2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcblx0XHRdLmNvbmNhdChcblx0XHRcdGV2ZW50LmNsYXNzTmFtZSxcblx0XHRcdGV2ZW50LnNvdXJjZSA/IGV2ZW50LnNvdXJjZS5jbGFzc05hbWUgOiBbXVxuXHRcdCk7XG5cblx0XHRpZiAoaXNEcmFnZ2FibGUpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHRcdGlmIChpc1Jlc2l6YWJsZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1yZXNpemFibGUnKTtcblx0XHR9XG5cblx0XHQvLyBldmVudCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQ/IGF0dGFjaCBhIGNsYXNzTmFtZS5cblx0XHRpZiAodmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXNlbGVjdGVkJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH0sXG5cblxuXHQvLyBVdGlsaXR5IGZvciBnZW5lcmF0aW5nIGV2ZW50IHNraW4tcmVsYXRlZCBDU1MgcHJvcGVydGllc1xuXHRnZXRTZWdTa2luQ3NzOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCB7fTtcblx0XHR2YXIgZXZlbnRDb2xvciA9IGV2ZW50LmNvbG9yO1xuXHRcdHZhciBzb3VyY2VDb2xvciA9IHNvdXJjZS5jb2xvcjtcblx0XHR2YXIgb3B0aW9uQ29sb3IgPSB2aWV3Lm9wdCgnZXZlbnRDb2xvcicpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzpcblx0XHRcdFx0ZXZlbnQuYmFja2dyb3VuZENvbG9yIHx8XG5cdFx0XHRcdGV2ZW50Q29sb3IgfHxcblx0XHRcdFx0c291cmNlLmJhY2tncm91bmRDb2xvciB8fFxuXHRcdFx0XHRzb3VyY2VDb2xvciB8fFxuXHRcdFx0XHR2aWV3Lm9wdCgnZXZlbnRCYWNrZ3JvdW5kQ29sb3InKSB8fFxuXHRcdFx0XHRvcHRpb25Db2xvcixcblx0XHRcdCdib3JkZXItY29sb3InOlxuXHRcdFx0XHRldmVudC5ib3JkZXJDb2xvciB8fFxuXHRcdFx0XHRldmVudENvbG9yIHx8XG5cdFx0XHRcdHNvdXJjZS5ib3JkZXJDb2xvciB8fFxuXHRcdFx0XHRzb3VyY2VDb2xvciB8fFxuXHRcdFx0XHR2aWV3Lm9wdCgnZXZlbnRCb3JkZXJDb2xvcicpIHx8XG5cdFx0XHRcdG9wdGlvbkNvbG9yLFxuXHRcdFx0Y29sb3I6XG5cdFx0XHRcdGV2ZW50LnRleHRDb2xvciB8fFxuXHRcdFx0XHRzb3VyY2UudGV4dENvbG9yIHx8XG5cdFx0XHRcdHZpZXcub3B0KCdldmVudFRleHRDb2xvcicpXG5cdFx0fTtcblx0fSxcblxuXG5cdC8qIENvbnZlcnRpbmcgZXZlbnRzIC0+IGV2ZW50UmFuZ2UgLT4gZXZlbnRTcGFuIC0+IGV2ZW50U2Vnc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIHNlZ21lbnRzIGZvciB0aGUgZ2l2ZW4gc2luZ2xlIGV2ZW50XG5cdC8vIENhbiBhY2NlcHQgYW4gZXZlbnQgXCJsb2NhdGlvblwiIGFzIHdlbGwgKHdoaWNoIG9ubHkgaGFzIHN0YXJ0L2VuZCBhbmQgbm8gYWxsRGF5KVxuXHRldmVudFRvU2VnczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudHNUb1NlZ3MoWyBldmVudCBdKTtcblx0fSxcblxuXG5cdGV2ZW50VG9TcGFuOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmV2ZW50VG9TcGFucyhldmVudClbMF07XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgc3BhbnMgKGFsd2F5cyB1bnpvbmVkKSBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuXHQvLyBEb2VzIG5vdCBkbyBhbnkgaW52ZXJ0aW5nIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzLlxuXHQvLyBDYW4gYWNjZXB0IGFuIGV2ZW50IFwibG9jYXRpb25cIiBhcyB3ZWxsICh3aGljaCBvbmx5IGhhcyBzdGFydC9lbmQgYW5kIG5vIGFsbERheSlcblx0ZXZlbnRUb1NwYW5zOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciByYW5nZSA9IHRoaXMuZXZlbnRUb1JhbmdlKGV2ZW50KTtcblx0XHRyZXR1cm4gdGhpcy5ldmVudFJhbmdlVG9TcGFucyhyYW5nZSwgZXZlbnQpO1xuXHR9LFxuXG5cblxuXHQvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBldmVudCBvYmplY3RzIGludG8gYW4gYXJyYXkgb2YgZXZlbnQgc2VnbWVudCBvYmplY3RzLlxuXHQvLyBBIGN1c3RvbSBgc2VnU2xpY2VGdW5jYCBtYXkgYmUgZ2l2ZW4gZm9yIGFyYml0cmFyaWx5IHNsaWNpbmcgdXAgZXZlbnRzLlxuXHQvLyBEb2Vzbid0IGd1YXJhbnRlZSBhbiBvcmRlciBmb3IgdGhlIHJlc3VsdGluZyBhcnJheS5cblx0ZXZlbnRzVG9TZWdzOiBmdW5jdGlvbihhbGxFdmVudHMsIHNlZ1NsaWNlRnVuYykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIGV2ZW50c0J5SWQgPSBncm91cEV2ZW50c0J5SWQoYWxsRXZlbnRzKTtcblx0XHR2YXIgc2VncyA9IFtdO1xuXG5cdFx0JC5lYWNoKGV2ZW50c0J5SWQsIGZ1bmN0aW9uKGlkLCBldmVudHMpIHtcblx0XHRcdHZhciByYW5nZXMgPSBbXTtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJhbmdlcy5wdXNoKF90aGlzLmV2ZW50VG9SYW5nZShldmVudHNbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50cyAodXRpbGl6ZSBvbmx5IHRoZSBmaXJzdCBldmVudCBpbiBjYWxjdWxhdGlvbnMpXG5cdFx0XHRpZiAoaXNJbnZlcnNlQmdFdmVudChldmVudHNbMF0pKSB7XG5cdFx0XHRcdHJhbmdlcyA9IF90aGlzLmludmVydFJhbmdlcyhyYW5nZXMpO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzZWdzLnB1c2guYXBwbHkoc2VncywgLy8gYXBwZW5kIHRvXG5cdFx0XHRcdFx0XHRfdGhpcy5ldmVudFJhbmdlVG9TZWdzKHJhbmdlc1tpXSwgZXZlbnRzWzBdLCBzZWdTbGljZUZ1bmMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm9ybWFsIGV2ZW50IHJhbmdlc1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzZWdzLnB1c2guYXBwbHkoc2VncywgLy8gYXBwZW5kIHRvXG5cdFx0XHRcdFx0XHRfdGhpcy5ldmVudFJhbmdlVG9TZWdzKHJhbmdlc1tpXSwgZXZlbnRzW2ldLCBzZWdTbGljZUZ1bmMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIHVuem9uZWQgc3RhcnQvZW5kIGRhdGVzIGFuIGV2ZW50IGFwcGVhcnMgdG8gb2NjdXB5XG5cdC8vIENhbiBhY2NlcHQgYW4gZXZlbnQgXCJsb2NhdGlvblwiIGFzIHdlbGwgKHdoaWNoIG9ubHkgaGFzIHN0YXJ0L2VuZCBhbmQgbm8gYWxsRGF5KVxuXHRldmVudFRvUmFuZ2U6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBldmVudC5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLFxuXHRcdFx0ZW5kOiAoXG5cdFx0XHRcdGV2ZW50LmVuZCA/XG5cdFx0XHRcdFx0ZXZlbnQuZW5kLmNsb25lKCkgOlxuXHRcdFx0XHRcdC8vIGRlcml2ZSB0aGUgZW5kIGZyb20gdGhlIHN0YXJ0IGFuZCBhbGxEYXkuIGNvbXB1dGUgYWxsRGF5IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdHRoaXMudmlldy5jYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoXG5cdFx0XHRcdFx0XHRldmVudC5hbGxEYXkgIT0gbnVsbCA/XG5cdFx0XHRcdFx0XHRcdGV2ZW50LmFsbERheSA6XG5cdFx0XHRcdFx0XHRcdCFldmVudC5zdGFydC5oYXNUaW1lKCksXG5cdFx0XHRcdFx0XHRldmVudC5zdGFydFxuXHRcdFx0XHRcdClcblx0XHRcdCkuc3RyaXBab25lKClcblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQncyByYW5nZSAodW56b25lZCBzdGFydC9lbmQpLCBhbmQgdGhlIGV2ZW50IGl0c2VsZixcblx0Ly8gc2xpY2UgaW50byBzZWdtZW50cyAodXNpbmcgdGhlIHNlZ1NsaWNlRnVuYyBmdW5jdGlvbiBpZiBzcGVjaWZpZWQpXG5cdGV2ZW50UmFuZ2VUb1NlZ3M6IGZ1bmN0aW9uKHJhbmdlLCBldmVudCwgc2VnU2xpY2VGdW5jKSB7XG5cdFx0dmFyIHNwYW5zID0gdGhpcy5ldmVudFJhbmdlVG9TcGFucyhyYW5nZSwgZXZlbnQpO1xuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ3MucHVzaC5hcHBseShzZWdzLCAvLyBhcHBlbmQgdG9cblx0XHRcdFx0dGhpcy5ldmVudFNwYW5Ub1NlZ3Moc3BhbnNbaV0sIGV2ZW50LCBzZWdTbGljZUZ1bmMpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGV2ZW50J3MgdW56b25lZCBkYXRlIHJhbmdlLCByZXR1cm4gYW4gYXJyYXkgb2YgXCJzcGFuXCIgb2JqZWN0cy5cblx0Ly8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUuXG5cdGV2ZW50UmFuZ2VUb1NwYW5zOiBmdW5jdGlvbihyYW5nZSwgZXZlbnQpIHtcblx0XHRyZXR1cm4gWyAkLmV4dGVuZCh7fSwgcmFuZ2UpIF07IC8vIGNvcHkgaW50byBhIHNpbmdsZS1pdGVtIGFycmF5XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCdzIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpLCBhbmQgdGhlIGV2ZW50IGl0c2VsZixcblx0Ly8gc2xpY2VzIGludG8gc2VnbWVudHMgYW5kIGF0dGFjaGVzIGV2ZW50LWRlcml2ZWQgcHJvcGVydGllcyB0byB0aGVtLlxuXHRldmVudFNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4sIGV2ZW50LCBzZWdTbGljZUZ1bmMpIHtcblx0XHR2YXIgc2VncyA9IHNlZ1NsaWNlRnVuYyA/IHNlZ1NsaWNlRnVuYyhzcGFuKSA6IHRoaXMuc3BhblRvU2VncyhzcGFuKTtcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRzZWcuZXZlbnQgPSBldmVudDtcblx0XHRcdHNlZy5ldmVudFN0YXJ0TVMgPSArc3Bhbi5zdGFydDsgLy8gVE9ETzogbm90IHRoZSBiZXN0IG5hbWUgYWZ0ZXIgbWFraW5nIHNwYW5zIHVuem9uZWRcblx0XHRcdHNlZy5ldmVudER1cmF0aW9uTVMgPSBzcGFuLmVuZCAtIHNwYW4uc3RhcnQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBQcm9kdWNlcyBhIG5ldyBhcnJheSBvZiByYW5nZSBvYmplY3RzIHRoYXQgd2lsbCBjb3ZlciBhbGwgdGhlIHRpbWUgTk9UIGNvdmVyZWQgYnkgdGhlIGdpdmVuIHJhbmdlcy5cblx0Ly8gU0lERSBFRkZFQ1Q6IHdpbGwgbXV0YXRlIHRoZSBnaXZlbiBhcnJheSBhbmQgd2lsbCB1c2UgaXRzIGRhdGUgcmVmZXJlbmNlcy5cblx0aW52ZXJ0UmFuZ2VzOiBmdW5jdGlvbihyYW5nZXMpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgdmlld1N0YXJ0ID0gdmlldy5zdGFydC5jbG9uZSgpOyAvLyBuZWVkIGEgY29weVxuXHRcdHZhciB2aWV3RW5kID0gdmlldy5lbmQuY2xvbmUoKTsgLy8gbmVlZCBhIGNvcHlcblx0XHR2YXIgaW52ZXJzZVJhbmdlcyA9IFtdO1xuXHRcdHZhciBzdGFydCA9IHZpZXdTdGFydDsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG5cdFx0dmFyIGksIHJhbmdlO1xuXG5cdFx0Ly8gcmFuZ2VzIG5lZWQgdG8gYmUgaW4gb3JkZXIuIHJlcXVpcmVkIGZvciBvdXIgZGF0ZS13YWxraW5nIGFsZ29yaXRobVxuXHRcdHJhbmdlcy5zb3J0KGNvbXBhcmVSYW5nZXMpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmFuZ2UgPSByYW5nZXNbaV07XG5cblx0XHRcdC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcblx0XHRcdGlmIChyYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG5cdFx0XHRcdGludmVyc2VSYW5nZXMucHVzaCh7XG5cdFx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRcdGVuZDogcmFuZ2Uuc3RhcnRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YXJ0ID0gcmFuZ2UuZW5kO1xuXHRcdH1cblxuXHRcdC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG5cdFx0aWYgKHN0YXJ0IDwgdmlld0VuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuXHRcdFx0aW52ZXJzZVJhbmdlcy5wdXNoKHtcblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRlbmQ6IHZpZXdFbmRcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbnZlcnNlUmFuZ2VzO1xuXHR9LFxuXG5cblx0c29ydEV2ZW50U2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHNlZ3Muc29ydChwcm94eSh0aGlzLCAnY29tcGFyZUV2ZW50U2VncycpKTtcblx0fSxcblxuXG5cdC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBzZWdtZW50cyBzaG91bGQgdGFrZSB2aXN1YWwgcHJpb3JpdHlcblx0Y29tcGFyZUV2ZW50U2VnczogZnVuY3Rpb24oc2VnMSwgc2VnMikge1xuXHRcdHJldHVybiBzZWcxLmV2ZW50U3RhcnRNUyAtIHNlZzIuZXZlbnRTdGFydE1TIHx8IC8vIGVhcmxpZXIgZXZlbnRzIGdvIGZpcnN0XG5cdFx0XHRzZWcyLmV2ZW50RHVyYXRpb25NUyAtIHNlZzEuZXZlbnREdXJhdGlvbk1TIHx8IC8vIHRpZT8gbG9uZ2VyIGV2ZW50cyBnbyBmaXJzdFxuXHRcdFx0c2VnMi5ldmVudC5hbGxEYXkgLSBzZWcxLmV2ZW50LmFsbERheSB8fCAvLyB0aWU/IHB1dCBhbGwtZGF5IGV2ZW50cyBmaXJzdCAoYm9vbGVhbnMgY2FzdCB0byAwLzEpXG5cdFx0XHRjb21wYXJlQnlGaWVsZFNwZWNzKHNlZzEuZXZlbnQsIHNlZzIuZXZlbnQsIHRoaXMudmlldy5ldmVudE9yZGVyU3BlY3MpO1xuXHR9XG5cbn0pO1xuXG5cbi8qIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuZnVuY3Rpb24gaXNCZ0V2ZW50KGV2ZW50KSB7IC8vIHJldHVybnMgdHJ1ZSBpZiBiYWNrZ3JvdW5kIE9SIGludmVyc2UtYmFja2dyb3VuZFxuXHR2YXIgcmVuZGVyaW5nID0gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpO1xuXHRyZXR1cm4gcmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCcgfHwgcmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbkZDLmlzQmdFdmVudCA9IGlzQmdFdmVudDsgLy8gZXhwb3J0XG5cblxuZnVuY3Rpb24gaXNJbnZlcnNlQmdFdmVudChldmVudCkge1xuXHRyZXR1cm4gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cblxuXG5mdW5jdGlvbiBnZXRFdmVudFJlbmRlcmluZyhldmVudCkge1xuXHRyZXR1cm4gZmlyc3REZWZpbmVkKChldmVudC5zb3VyY2UgfHwge30pLnJlbmRlcmluZywgZXZlbnQucmVuZGVyaW5nKTtcbn1cblxuXG5mdW5jdGlvbiBncm91cEV2ZW50c0J5SWQoZXZlbnRzKSB7XG5cdHZhciBldmVudHNCeUlkID0ge307XG5cdHZhciBpLCBldmVudDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZXZlbnQgPSBldmVudHNbaV07XG5cdFx0KGV2ZW50c0J5SWRbZXZlbnQuX2lkXSB8fCAoZXZlbnRzQnlJZFtldmVudC5faWRdID0gW10pKS5wdXNoKGV2ZW50KTtcblx0fVxuXG5cdHJldHVybiBldmVudHNCeUlkO1xufVxuXG5cbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBub24taW52ZXJ0ZWQgXCJyYW5nZXNcIiAoc2VlIGFib3ZlKSBoYXBwZW4gZWFybGllclxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTEsIHJhbmdlMikge1xuXHRyZXR1cm4gcmFuZ2UxLnN0YXJ0IC0gcmFuZ2UyLnN0YXJ0OyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxufVxuXG5cbi8qIEV4dGVybmFsLURyYWdnaW5nLUVsZW1lbnQgRGF0YVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFJlcXVpcmUgYWxsIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVzIHVzZWQgYnkgRnVsbENhbGVuZGFyIHRvIGhhdmUgdGhpcyBwcmVmaXguXG4vLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxuRkMuZGF0YUF0dHJQcmVmaXggPSAnJztcblxuLy8gR2l2ZW4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IG1pZ2h0IHJlcHJlc2VudCBhIGRyYWdnZWQgRnVsbENhbGVuZGFyIGV2ZW50LCByZXR1cm5zIGFuIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZVxuLy8gdG8gYmUgdXNlZCBmb3IgRXZlbnQgT2JqZWN0IGNyZWF0aW9uLlxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXG5mdW5jdGlvbiBnZXREcmFnZ2VkRWxNZXRhKGVsKSB7XG5cdHZhciBwcmVmaXggPSBGQy5kYXRhQXR0clByZWZpeDtcblx0dmFyIGV2ZW50UHJvcHM7IC8vIHByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIHRoZSBldmVudCwgbm90IHJlbGF0ZWQgdG8gZGF0ZS90aW1lXG5cdHZhciBzdGFydFRpbWU7IC8vIGEgRHVyYXRpb25cblx0dmFyIGR1cmF0aW9uO1xuXHR2YXIgc3RpY2s7XG5cblx0aWYgKHByZWZpeCkgeyBwcmVmaXggKz0gJy0nOyB9XG5cdGV2ZW50UHJvcHMgPSBlbC5kYXRhKHByZWZpeCArICdldmVudCcpIHx8IG51bGw7XG5cblx0aWYgKGV2ZW50UHJvcHMpIHtcblx0XHRpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRldmVudFByb3BzID0gJC5leHRlbmQoe30sIGV2ZW50UHJvcHMpOyAvLyBtYWtlIGEgY29weVxuXHRcdH1cblx0XHRlbHNlIHsgLy8gc29tZXRoaW5nIGxpa2UgMSBvciB0cnVlLiBzdGlsbCBzaWduYWwgZXZlbnQgY3JlYXRpb25cblx0XHRcdGV2ZW50UHJvcHMgPSB7fTtcblx0XHR9XG5cblx0XHQvLyBwbHVjayBzcGVjaWFsLWNhc2VkIGRhdGUvdGltZSBwcm9wZXJ0aWVzXG5cdFx0c3RhcnRUaW1lID0gZXZlbnRQcm9wcy5zdGFydDtcblx0XHRpZiAoc3RhcnRUaW1lID09IG51bGwpIHsgc3RhcnRUaW1lID0gZXZlbnRQcm9wcy50aW1lOyB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxuXHRcdGR1cmF0aW9uID0gZXZlbnRQcm9wcy5kdXJhdGlvbjtcblx0XHRzdGljayA9IGV2ZW50UHJvcHMuc3RpY2s7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMuc3RhcnQ7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMudGltZTtcblx0XHRkZWxldGUgZXZlbnRQcm9wcy5kdXJhdGlvbjtcblx0XHRkZWxldGUgZXZlbnRQcm9wcy5zdGljaztcblx0fVxuXG5cdC8vIGZhbGxiYWNrIHRvIHN0YW5kYWxvbmUgYXR0cmlidXRlIHZhbHVlcyBmb3IgZWFjaCBvZiB0aGUgZGF0ZS90aW1lIHByb3BlcnRpZXNcblx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3N0YXJ0Jyk7IH1cblx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3RpbWUnKTsgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcblx0aWYgKGR1cmF0aW9uID09IG51bGwpIHsgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpOyB9XG5cdGlmIChzdGljayA9PSBudWxsKSB7IHN0aWNrID0gZWwuZGF0YShwcmVmaXggKyAnc3RpY2snKTsgfVxuXG5cdC8vIG1hc3NhZ2UgaW50byBjb3JyZWN0IGRhdGEgdHlwZXNcblx0c3RhcnRUaW1lID0gc3RhcnRUaW1lICE9IG51bGwgPyBtb21lbnQuZHVyYXRpb24oc3RhcnRUaW1lKSA6IG51bGw7XG5cdGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xuXHRzdGljayA9IEJvb2xlYW4oc3RpY2spO1xuXG5cdHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xufVxuXG5cbjs7XG5cbi8qXG5BIHNldCBvZiByZW5kZXJpbmcgYW5kIGRhdGUtcmVsYXRlZCBtZXRob2RzIGZvciBhIHZpc3VhbCBjb21wb25lbnQgY29tcHJpc2VkIG9mIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNvbHVtbnMuXG5QcmVyZXF1aXNpdGU6IHRoZSBvYmplY3QgYmVpbmcgbWl4ZWQgaW50byBuZWVkcyB0byBiZSBhICpHcmlkKlxuKi9cbnZhciBEYXlUYWJsZU1peGluID0gRkMuRGF5VGFibGVNaXhpbiA9IHtcblxuXHRicmVha09uV2Vla3M6IGZhbHNlLCAvLyBzaG91bGQgY3JlYXRlIGEgbmV3IHJvdyBmb3IgZWFjaCB3ZWVrP1xuXHRkYXlEYXRlczogbnVsbCwgLy8gd2hvbGUtZGF5IGRhdGVzIGZvciBlYWNoIGNvbHVtbi4gbGVmdCB0byByaWdodFxuXHRkYXlJbmRpY2VzOiBudWxsLCAvLyBmb3IgZWFjaCBkYXkgZnJvbSBzdGFydCwgdGhlIG9mZnNldFxuXHRkYXlzUGVyUm93OiBudWxsLFxuXHRyb3dDbnQ6IG51bGwsXG5cdGNvbENudDogbnVsbCxcblx0Y29sSGVhZEZvcm1hdDogbnVsbCxcblxuXG5cdC8vIFBvcHVsYXRlcyBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCBmb3IgZGF0ZSBjYWxjdWxhdGlvbiBhbmQgcmVuZGVyaW5nXG5cdHVwZGF0ZURheVRhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGF0ZSA9IHRoaXMuc3RhcnQuY2xvbmUoKTtcblx0XHR2YXIgZGF5SW5kZXggPSAtMTtcblx0XHR2YXIgZGF5SW5kaWNlcyA9IFtdO1xuXHRcdHZhciBkYXlEYXRlcyA9IFtdO1xuXHRcdHZhciBkYXlzUGVyUm93O1xuXHRcdHZhciBmaXJzdERheTtcblx0XHR2YXIgcm93Q250O1xuXG5cdFx0d2hpbGUgKGRhdGUuaXNCZWZvcmUodGhpcy5lbmQpKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcblx0XHRcdGlmICh2aWV3LmlzSGlkZGVuRGF5KGRhdGUpKSB7XG5cdFx0XHRcdGRheUluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRheUluZGV4Kys7XG5cdFx0XHRcdGRheUluZGljZXMucHVzaChkYXlJbmRleCk7XG5cdFx0XHRcdGRheURhdGVzLnB1c2goZGF0ZS5jbG9uZSgpKTtcblx0XHRcdH1cblx0XHRcdGRhdGUuYWRkKDEsICdkYXlzJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYnJlYWtPbldlZWtzKSB7XG5cdFx0XHQvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG5cdFx0XHRmaXJzdERheSA9IGRheURhdGVzWzBdLmRheSgpO1xuXHRcdFx0Zm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRheURhdGVzLmxlbmd0aDsgZGF5c1BlclJvdysrKSB7XG5cdFx0XHRcdGlmIChkYXlEYXRlc1tkYXlzUGVyUm93XS5kYXkoKSA9PSBmaXJzdERheSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyb3dDbnQgPSBNYXRoLmNlaWwoZGF5RGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cm93Q250ID0gMTtcblx0XHRcdGRheXNQZXJSb3cgPSBkYXlEYXRlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xuXHRcdHRoaXMuZGF5SW5kaWNlcyA9IGRheUluZGljZXM7XG5cdFx0dGhpcy5kYXlzUGVyUm93ID0gZGF5c1BlclJvdztcblx0XHR0aGlzLnJvd0NudCA9IHJvd0NudDtcblx0XHRcblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlQ29scygpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYW5kIGFzc2lnbmVkIHRoZSBjb2xDbnQgcHJvcGVydHkgYW5kIHVwZGF0ZXMgYW55IG9wdGlvbnMgdGhhdCBtYXkgYmUgY29tcHV0ZWQgZnJvbSBpdFxuXHR1cGRhdGVEYXlUYWJsZUNvbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ250ID0gdGhpcy5jb21wdXRlQ29sQ250KCk7XG5cdFx0dGhpcy5jb2xIZWFkRm9ybWF0ID0gdGhpcy52aWV3Lm9wdCgnY29sdW1uRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlQ29sSGVhZEZvcm1hdCgpO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyBob3cgbWFueSBjb2x1bW5zIHRoZXJlIHNob3VsZCBiZSBpbiB0aGUgdGFibGVcblx0Y29tcHV0ZUNvbENudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5c1BlclJvdztcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnQgZm9yIHRoZSBnaXZlbiBjZWxsXG5cdGdldENlbGxEYXRlOiBmdW5jdGlvbihyb3csIGNvbCkge1xuXHRcdHJldHVybiB0aGlzLmRheURhdGVzW1xuXHRcdFx0XHR0aGlzLmdldENlbGxEYXlJbmRleChyb3csIGNvbClcblx0XHRcdF0uY2xvbmUoKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBkYXRlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gY2VsbFxuXHRnZXRDZWxsUmFuZ2U6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0dmFyIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5IGNlbGxzLCBjaHJvbm9sb2dpY2FsbHksIGZyb20gdGhlIGZpcnN0IG9mIHRoZSBncmlkICgwLWJhc2VkKVxuXHRnZXRDZWxsRGF5SW5kZXg6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0cmV0dXJuIHJvdyAqIHRoaXMuZGF5c1BlclJvdyArIHRoaXMuZ2V0Q29sRGF5SW5kZXgoY29sKTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgdGhlIG51bW5lciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3QgY2VsbCBpbiAqYW55IGdpdmVuIHJvdypcblx0Z2V0Q29sRGF5SW5kZXg6IGZ1bmN0aW9uKGNvbCkge1xuXHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2xDbnQgLSAxIC0gY29sO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBjb2w7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuXHQvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG5cdC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHQvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG5cdC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuXHRnZXREYXRlRGF5SW5kZXg6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgZGF5SW5kaWNlcyA9IHRoaXMuZGF5SW5kaWNlcztcblx0XHR2YXIgZGF5T2Zmc2V0ID0gZGF0ZS5kaWZmKHRoaXMuc3RhcnQsICdkYXlzJyk7XG5cblx0XHRpZiAoZGF5T2Zmc2V0IDwgMCkge1xuXHRcdFx0cmV0dXJuIGRheUluZGljZXNbMF0gLSAxO1xuXHRcdH1cblx0XHRlbHNlIGlmIChkYXlPZmZzZXQgPj0gZGF5SW5kaWNlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBkYXlJbmRpY2VzW2RheUluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBkYXlJbmRpY2VzW2RheU9mZnNldF07XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuXHRjb21wdXRlQ29sSGVhZEZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcblx0XHQvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcblx0XHRpZiAodGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID4gMTApIHtcblx0XHRcdHJldHVybiAnZGRkJzsgLy8gXCJTYXRcIlxuXHRcdH1cblx0XHQvLyBtdWx0aXBsZSBkYXlzLCBzbyBmdWxsIHNpbmdsZSBkYXRlIHN0cmluZyBXT04nVCBiZSBpbiB0aXRsZSB0ZXh0XG5cdFx0ZWxzZSBpZiAodGhpcy5jb2xDbnQgPiAxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3Lm9wdCgnZGF5T2ZNb250aEZvcm1hdCcpOyAvLyBcIlNhdCAxMi8xMFwiXG5cdFx0fVxuXHRcdC8vIHNpbmdsZSBkYXksIHNvIGZ1bGwgc2luZ2xlIGRhdGUgc3RyaW5nIHdpbGwgcHJvYmFibHkgYmUgaW4gdGl0bGUgdGV4dFxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICdkZGRkJzsgLy8gXCJTYXR1cmRheVwiXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogU2xpY2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgd2Vlay1yb3cgaXQgaW50ZXJzZWN0cyB3aXRoXG5cdHNsaWNlUmFuZ2VCeVJvdzogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcblx0XHR2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcblx0XHR2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG5cdFx0dmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XG5cdFx0dmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuXHRcdFx0cm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xuXHRcdFx0cm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XG5cblx0XHRcdC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXG5cdFx0XHRzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIHJvd0ZpcnN0KTtcblx0XHRcdHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIHJvd0xhc3QpO1xuXG5cdFx0XHQvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG5cdFx0XHRzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuXHRcdFx0c2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuXHRcdFx0aWYgKHNlZ0ZpcnN0IDw9IHNlZ0xhc3QpIHsgLy8gd2FzIHRoZXJlIGFueSBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgY3VycmVudCByb3c/XG5cdFx0XHRcdHNlZ3MucHVzaCh7XG5cdFx0XHRcdFx0cm93OiByb3csXG5cblx0XHRcdFx0XHQvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XG5cdFx0XHRcdFx0Zmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcblx0XHRcdFx0XHRsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcblxuXHRcdFx0XHRcdC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcblx0XHRcdFx0XHRpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcblx0XHRcdFx0XHRpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgZGF5LWNlbGwgaXQgaW50ZXJzZWN0cyB3aXRoLlxuXHQvLyBUT0RPOiBtYWtlIG1vcmUgRFJZIHdpdGggc2xpY2VSYW5nZUJ5Um93IHNvbWVob3cuXG5cdHNsaWNlUmFuZ2VCeURheTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcblx0XHR2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcblx0XHR2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG5cdFx0dmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuXHRcdFx0cm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xuXHRcdFx0cm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XG5cblx0XHRcdGZvciAoaSA9IHJvd0ZpcnN0OyBpIDw9IHJvd0xhc3Q7IGkrKykge1xuXG5cdFx0XHRcdC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXG5cdFx0XHRcdHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgaSk7XG5cdFx0XHRcdHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIGkpO1xuXG5cdFx0XHRcdC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcblx0XHRcdFx0c2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcblx0XHRcdFx0c2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuXHRcdFx0XHRpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkgeyAvLyB3YXMgdGhlcmUgYW55IGludGVyc2VjdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdz9cblx0XHRcdFx0XHRzZWdzLnB1c2goe1xuXHRcdFx0XHRcdFx0cm93OiByb3csXG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcblx0XHRcdFx0XHRcdGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXG5cdFx0XHRcdFx0XHRsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcblxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBiZSBtYXRjaGluZyBpbnRlZ2VycyB0byBiZSB0aGUgc2VnbWVudCdzIHN0YXJ0L2VuZFxuXHRcdFx0XHRcdFx0aXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXG5cdFx0XHRcdFx0XHRpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8qIEhlYWRlciBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhlYWRIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdmlldy53aWRnZXRIZWFkZXJDbGFzcyArICdcIj4nICtcblx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHQnPHRoZWFkPicgK1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xuXHRcdFx0XHRcdCc8L3RoZWFkPicgK1xuXHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nO1xuXHR9LFxuXG5cblx0cmVuZGVySGVhZEludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXG5cdH0sXG5cblxuXHRyZW5kZXJIZWFkVHJIdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyAnJyA6IHRoaXMucmVuZGVySGVhZEludHJvSHRtbCgpKSArXG5cdFx0XHRcdHRoaXMucmVuZGVySGVhZERhdGVDZWxsc0h0bWwoKSArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkgOiAnJykgK1xuXHRcdFx0JzwvdHI+Jztcblx0fSxcblxuXG5cdHJlbmRlckhlYWREYXRlQ2VsbHNIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKDAsIGNvbCk7XG5cdFx0XHRodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0Ly8gVE9ETzogd2hlbiBpbnRlcm5hbEFwaVZlcnNpb24sIGFjY2VwdCBhbiBvYmplY3QgZm9yIEhUTUwgYXR0cmlidXRlc1xuXHQvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxuXHRyZW5kZXJIZWFkRGF0ZUNlbGxIdG1sOiBmdW5jdGlvbihkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0aCBjbGFzcz1cImZjLWRheS1oZWFkZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnIGZjLScgKyBkYXlJRHNbZGF0ZS5kYXkoKV0gKyAnXCInICtcblx0XHRcdFx0KHRoaXMucm93Q250ID09IDEgP1xuXHRcdFx0XHRcdCcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCInIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0XHQoY29sc3BhbiA+IDEgP1xuXHRcdFx0XHRcdCcgY29sc3Bhbj1cIicgKyBjb2xzcGFuICsgJ1wiJyA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdFx0KG90aGVyQXR0cnMgP1xuXHRcdFx0XHRcdCcgJyArIG90aGVyQXR0cnMgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHQnPicgK1xuXHRcdFx0XHRodG1sRXNjYXBlKGRhdGUuZm9ybWF0KHRoaXMuY29sSGVhZEZvcm1hdCkpICtcblx0XHRcdCc8L3RoPic7XG5cdH0sXG5cblxuXHQvKiBCYWNrZ3JvdW5kIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQmdUckh0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRyPicgK1xuXHRcdFx0XHQodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJCZ0ludHJvSHRtbChyb3cpKSArXG5cdFx0XHRcdHRoaXMucmVuZGVyQmdDZWxsc0h0bWwocm93KSArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJCZ0ludHJvSHRtbChyb3cpIDogJycpICtcblx0XHRcdCc8L3RyPic7XG5cdH0sXG5cblxuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXG5cdH0sXG5cblxuXHRyZW5kZXJCZ0NlbGxzSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIGh0bWxzID0gW107XG5cdFx0dmFyIGNvbCwgZGF0ZTtcblxuXHRcdGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XG5cdFx0XHRkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0XHRodG1scy5wdXNoKHRoaXMucmVuZGVyQmdDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0cmVuZGVyQmdDZWxsSHRtbDogZnVuY3Rpb24oZGF0ZSwgb3RoZXJBdHRycykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gdGhpcy5nZXREYXlDbGFzc2VzKGRhdGUpO1xuXG5cdFx0Y2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXknLCB2aWV3LndpZGdldENvbnRlbnRDbGFzcyk7XG5cblx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xuXHRcdFx0JyBkYXRhLWRhdGU9XCInICsgZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIicgKyAvLyBpZiBkYXRlIGhhcyBhIHRpbWUsIHdvbid0IGZvcm1hdCBpdFxuXHRcdFx0KG90aGVyQXR0cnMgP1xuXHRcdFx0XHQnICcgKyBvdGhlckF0dHJzIDpcblx0XHRcdFx0JycpICtcblx0XHRcdCc+PC90ZD4nO1xuXHR9LFxuXG5cblx0LyogR2VuZXJpY1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBkZWZhdWx0IEhUTUwgaW50cm8gZm9yIGFueSByb3cuIFVzZXIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcblx0cmVuZGVySW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIFRPRE86IGEgZ2VuZXJpYyBtZXRob2QgZm9yIGRlYWxpbmcgd2l0aCA8dHI+LCBSVEwsIGludHJvXG5cdC8vIHdoZW4gaW5jcmVtZW50IGludGVybmFsQXBpVmVyc2lvblxuXHQvLyB3cmFwVHIgKHNjaGVkdWxlcilcblxuXG5cdC8qIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBBcHBsaWVzIHRoZSBnZW5lcmljIFwiaW50cm9cIiBhbmQgXCJvdXRyb1wiIEhUTUwgdG8gdGhlIGdpdmVuIGNlbGxzLlxuXHQvLyBJbnRybyBtZWFucyB0aGUgbGVmdG1vc3QgY2VsbCB3aGVuIHRoZSBjYWxlbmRhciBpcyBMVFIgYW5kIHRoZSByaWdodG1vc3QgY2VsbCB3aGVuIFJUTC4gVmljZS12ZXJzYSBmb3Igb3V0cm8uXG5cdGJvb2tlbmRDZWxsczogZnVuY3Rpb24odHJFbCkge1xuXHRcdHZhciBpbnRyb0h0bWwgPSB0aGlzLnJlbmRlckludHJvSHRtbCgpO1xuXG5cdFx0aWYgKGludHJvSHRtbCkge1xuXHRcdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdFx0dHJFbC5hcHBlbmQoaW50cm9IdG1sKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0ckVsLnByZXBlbmQoaW50cm9IdG1sKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxufTtcblxuOztcblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIGEgZ3JpZCBvZiB3aG9sZS1kYXlzIHRoYXQgcnVucyBob3Jpem9udGFsbHkuIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSByb3dzLCBvbmUgcGVyIHdlZWsuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIERheUdyaWQgPSBGQy5EYXlHcmlkID0gR3JpZC5leHRlbmQoRGF5VGFibGVNaXhpbiwge1xuXG5cdG51bWJlcnNWaXNpYmxlOiBmYWxzZSwgLy8gc2hvdWxkIHJlbmRlciBhIHJvdyBmb3IgZGF5L3dlZWsgbnVtYmVycz8gc2V0IGJ5IG91dHNpZGUgdmlldy4gVE9ETzogbWFrZSBpbnRlcm5hbFxuXHRib3R0b21Db29yZFBhZGRpbmc6IDAsIC8vIGhhY2sgZm9yIGV4dGVuZGluZyB0aGUgaGl0IGFyZWEgZm9yIHRoZSBsYXN0IHJvdyBvZiB0aGUgY29vcmRpbmF0ZSBncmlkXG5cblx0cm93RWxzOiBudWxsLCAvLyBzZXQgb2YgZmFrZSByb3cgZWxlbWVudHNcblx0Y2VsbEVsczogbnVsbCwgLy8gc2V0IG9mIHdob2xlLWRheSBlbGVtZW50cyBjb21wcmlzaW5nIHRoZSByb3cncyBiYWNrZ3JvdW5kXG5cdGhlbHBlckVsczogbnVsbCwgLy8gc2V0IG9mIGNlbGwgc2tlbGV0b24gZWxlbWVudHMgZm9yIHJlbmRlcmluZyB0aGUgbW9jayBldmVudCBcImhlbHBlclwiXG5cblx0cm93Q29vcmRDYWNoZTogbnVsbCxcblx0Y29sQ29vcmRDYWNoZTogbnVsbCxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIHJvd3MgYW5kIGNvbHVtbnMgaW50byB0aGUgY29tcG9uZW50J3MgYHRoaXMuZWxgLCB3aGljaCBzaG91bGQgYWxyZWFkeSBiZSBhc3NpZ25lZC5cblx0Ly8gaXNSaWdpZCBkZXRlcm1pbnMgd2hldGhlciB0aGUgaW5kaXZpZHVhbCByb3dzIHNob3VsZCBpZ25vcmUgdGhlIGNvbnRlbnRzIGFuZCBiZSBhIGNvbnN0YW50IGhlaWdodC5cblx0Ly8gUmVsaWVzIG9uIHRoZSB2aWV3J3MgY29sQ250IGFuZCByb3dDbnQuIEluIHRoZSBmdXR1cmUsIHRoaXMgY29tcG9uZW50IHNob3VsZCBwcm9iYWJseSBiZSBzZWxmLXN1ZmZpY2llbnQuXG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbihpc1JpZ2lkKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHJvd0NudCA9IHRoaXMucm93Q250O1xuXHRcdHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXHRcdHZhciByb3c7XG5cdFx0dmFyIGNvbDtcblxuXHRcdGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xuXHRcdFx0aHRtbCArPSB0aGlzLnJlbmRlckRheVJvd0h0bWwocm93LCBpc1JpZ2lkKTtcblx0XHR9XG5cdFx0dGhpcy5lbC5odG1sKGh0bWwpO1xuXG5cdFx0dGhpcy5yb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3cnKTtcblx0XHR0aGlzLmNlbGxFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXknKTtcblxuXHRcdHRoaXMucm93Q29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlKHtcblx0XHRcdGVsczogdGhpcy5yb3dFbHMsXG5cdFx0XHRpc1ZlcnRpY2FsOiB0cnVlXG5cdFx0fSk7XG5cdFx0dGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGUoe1xuXHRcdFx0ZWxzOiB0aGlzLmNlbGxFbHMuc2xpY2UoMCwgdGhpcy5jb2xDbnQpLCAvLyBvbmx5IHRoZSBmaXJzdCByb3dcblx0XHRcdGlzSG9yaXpvbnRhbDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0Ly8gdHJpZ2dlciBkYXlSZW5kZXIgd2l0aCBlYWNoIGNlbGwncyBlbGVtZW50XG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XG5cdFx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sKyspIHtcblx0XHRcdFx0dmlldy50cmlnZ2VyKFxuXHRcdFx0XHRcdCdkYXlSZW5kZXInLFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0dGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCksXG5cdFx0XHRcdFx0dGhpcy5nZXRDZWxsRWwocm93LCBjb2wpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7XG5cdH0sXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRzID0gdGhpcy52aWV3LmNhbGVuZGFyLmdldEJ1c2luZXNzSG91cnNFdmVudHModHJ1ZSk7IC8vIHdob2xlRGF5PXRydWVcblx0XHR2YXIgc2VncyA9IHRoaXMuZXZlbnRzVG9TZWdzKGV2ZW50cyk7XG5cblx0XHR0aGlzLnJlbmRlckZpbGwoJ2J1c2luZXNzSG91cnMnLCBzZWdzLCAnYmdldmVudCcpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyRmlsbCgnYnVzaW5lc3NIb3VycycpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSByb3csIHdoaWNoIGlzIGEgZGl2IHRoYXQgd3JhcHMgYSB0YWJsZS5cblx0Ly8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG5cdHJlbmRlckRheVJvd0h0bWw6IGZ1bmN0aW9uKHJvdywgaXNSaWdpZCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gWyAnZmMtcm93JywgJ2ZjLXdlZWsnLCB2aWV3LndpZGdldENvbnRlbnRDbGFzcyBdO1xuXG5cdFx0aWYgKGlzUmlnaWQpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtcmlnaWQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcblx0XHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJCZ1RySHRtbChyb3cpICtcblx0XHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcblx0XHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdFx0KHRoaXMubnVtYmVyc1Zpc2libGUgP1xuXHRcdFx0XHRcdFx0XHQnPHRoZWFkPicgK1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVuZGVyTnVtYmVyVHJIdG1sKHJvdykgK1xuXHRcdFx0XHRcdFx0XHQnPC90aGVhZD4nIDpcblx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdCc8L2Rpdj4nO1xuXHR9LFxuXG5cblx0LyogR3JpZCBOdW1iZXIgUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJOdW1iZXJUckh0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRyPicgK1xuXHRcdFx0XHQodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSkgK1xuXHRcdFx0XHR0aGlzLnJlbmRlck51bWJlckNlbGxzSHRtbChyb3cpICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpIDogJycpICtcblx0XHRcdCc8L3RyPic7XG5cdH0sXG5cblxuXHRyZW5kZXJOdW1iZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpO1xuXHR9LFxuXG5cblx0cmVuZGVyTnVtYmVyQ2VsbHNIdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcblx0XHRcdGh0bWxzLnB1c2godGhpcy5yZW5kZXJOdW1iZXJDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgPHRkPnMgb2YgdGhlIFwibnVtYmVyXCIgcm93IGluIHRoZSBEYXlHcmlkJ3MgY29udGVudCBza2VsZXRvbi5cblx0Ly8gVGhlIG51bWJlciByb3cgd2lsbCBvbmx5IGV4aXN0IGlmIGVpdGhlciBkYXkgbnVtYmVycyBvciB3ZWVrIG51bWJlcnMgYXJlIHR1cm5lZCBvbi5cblx0cmVuZGVyTnVtYmVyQ2VsbEh0bWw6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgY2xhc3NlcztcblxuXHRcdGlmICghdGhpcy52aWV3LmRheU51bWJlcnNWaXNpYmxlKSB7IC8vIGlmIHRoZXJlIGFyZSB3ZWVrIG51bWJlcnMgYnV0IG5vdCBkYXkgbnVtYmVyc1xuXHRcdFx0cmV0dXJuICc8dGQvPic7IC8vICB3aWxsIGNyZWF0ZSBhbiBlbXB0eSBzcGFjZSBhYm92ZSBldmVudHMgOihcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gdGhpcy5nZXREYXlDbGFzc2VzKGRhdGUpO1xuXHRcdGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LW51bWJlcicpO1xuXG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCIgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCkgKyAnXCI+JyArXG5cdFx0XHRcdGRhdGUuZGF0ZSgpICtcblx0XHRcdCc8L3RkPic7XG5cdH0sXG5cblxuXHQvKiBPcHRpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgdGltZUZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuXHRjb21wdXRlRXZlbnRUaW1lRm9ybWF0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3Lm9wdCgnZXh0cmFTbWFsbFRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjZwXCIgb3IgXCI2OjMwcFwiXG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhIGRlZmF1bHQgYGRpc3BsYXlFdmVudEVuZGAgdmFsdWUgaWYgb25lIGlzIG5vdCBleHBsaWNsdHkgZGVmaW5lZFxuXHRjb21wdXRlRGlzcGxheUV2ZW50RW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb2xDbnQgPT0gMTsgLy8gd2UnbGwgbGlrZWx5IGhhdmUgc3BhY2UgaWYgdGhlcmUncyBvbmx5IG9uZSBkYXlcblx0fSxcblxuXG5cdC8qIERhdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyYW5nZVVwZGF0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlRGF5VGFibGUoKTtcblx0fSxcblxuXG5cdC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcblx0c3BhblRvU2VnczogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlSb3coc3Bhbik7XG5cdFx0dmFyIGksIHNlZztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdFx0c2VnLmxlZnRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmxhc3RSb3dEYXlJbmRleDtcblx0XHRcdFx0c2VnLnJpZ2h0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5maXJzdFJvd0RheUluZGV4O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNlZy5sZWZ0Q29sID0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XG5cdFx0XHRcdHNlZy5yaWdodENvbCA9IHNlZy5sYXN0Um93RGF5SW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvKiBIaXQgU3lzdGVtXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRwcmVwYXJlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XG5cdFx0dGhpcy5yb3dDb29yZENhY2hlLmJ1aWxkKCk7XG5cdFx0dGhpcy5yb3dDb29yZENhY2hlLmJvdHRvbXNbdGhpcy5yb3dDbnQgLSAxXSArPSB0aGlzLmJvdHRvbUNvb3JkUGFkZGluZzsgLy8gaGFja1xuXHR9LFxuXG5cblx0cmVsZWFzZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xuXHRcdHRoaXMucm93Q29vcmRDYWNoZS5jbGVhcigpO1xuXHR9LFxuXG5cblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xuXHRcdHZhciBjb2wgPSB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xuXHRcdHZhciByb3cgPSB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xuXG5cdFx0aWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcblx0XHR9XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZWxsUmFuZ2UoaGl0LnJvdywgaGl0LmNvbCk7XG5cdH0sXG5cblxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VsbEVsKGhpdC5yb3csIGhpdC5jb2wpO1xuXHR9LFxuXG5cblx0LyogQ2VsbCBTeXN0ZW1cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxuXG5cblx0Z2V0Q2VsbEhpdDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cm93OiByb3csXG5cdFx0XHRjb2w6IGNvbCxcblx0XHRcdGNvbXBvbmVudDogdGhpcywgLy8gbmVlZGVkIHVuZm9ydHVuYXRlbHkgOihcblx0XHRcdGxlZnQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRMZWZ0T2Zmc2V0KGNvbCksXG5cdFx0XHRyaWdodDogdGhpcy5jb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbCksXG5cdFx0XHR0b3A6IHRoaXMucm93Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQocm93KSxcblx0XHRcdGJvdHRvbTogdGhpcy5yb3dDb29yZENhY2hlLmdldEJvdHRvbU9mZnNldChyb3cpXG5cdFx0fTtcblx0fSxcblxuXG5cdGdldENlbGxFbDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4gdGhpcy5jZWxsRWxzLmVxKHJvdyAqIHRoaXMuY29sQ250ICsgY29sKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBtb3ZlIHRvIERheUdyaWQuZXZlbnQsIHNpbWlsYXIgdG8gd2hhdCB3ZSBkaWQgd2l0aCBHcmlkJ3MgZHJhZyBtZXRob2RzXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxuXHQvLyBgZXZlbnRMb2NhdGlvbmAgaGFzIHpvbmVkIHN0YXJ0IGFuZCBlbmQgKG9wdGlvbmFsKVxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblxuXHRcdC8vIGFsd2F5cyByZW5kZXIgYSBoaWdobGlnaHQgdW5kZXJuZWF0aFxuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHRoaXMuZXZlbnRUb1NwYW4oZXZlbnRMb2NhdGlvbikpO1xuXG5cdFx0Ly8gaWYgYSBzZWdtZW50IGZyb20gdGhlIHNhbWUgY2FsZW5kYXIgYnV0IGFub3RoZXIgY29tcG9uZW50IGlzIGJlaW5nIGRyYWdnZWQsIHJlbmRlciBhIGhlbHBlciBldmVudFxuXHRcdGlmIChzZWcgJiYgIXNlZy5lbC5jbG9zZXN0KHRoaXMuZWwpLmxlbmd0aCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBob3ZlcmluZyBldmVudFxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcblx0XHR0aGlzLnVucmVuZGVySGVscGVyKCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0cmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNlZykge1xuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHRoaXMuZXZlbnRUb1NwYW4oZXZlbnRMb2NhdGlvbikpO1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXIoZXZlbnRMb2NhdGlvbiwgc2VnKTsgLy8gcmV0dXJucyBtb2NrIGV2ZW50IGVsZW1lbnRzXG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXG5cdHVucmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcblx0XHR0aGlzLnVucmVuZGVySGVscGVyKCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBIZWxwZXJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQuIGBzb3VyY2VTZWdgIGlzIHRoZSBhc3NvY2lhdGVkIGludGVybmFsIHNlZ21lbnQgb2JqZWN0LiBJdCBjYW4gYmUgbnVsbC5cblx0cmVuZGVySGVscGVyOiBmdW5jdGlvbihldmVudCwgc291cmNlU2VnKSB7XG5cdFx0dmFyIGhlbHBlck5vZGVzID0gW107XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLmV2ZW50VG9TZWdzKGV2ZW50KTtcblx0XHR2YXIgcm93U3RydWN0cztcblxuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZnU2VnRWxzKHNlZ3MpOyAvLyBhc3NpZ25zIGVhY2ggc2VnJ3MgZWwgYW5kIHJldHVybnMgYSBzdWJzZXQgb2Ygc2VncyB0aGF0IHdlcmUgcmVuZGVyZWRcblx0XHRyb3dTdHJ1Y3RzID0gdGhpcy5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xuXG5cdFx0Ly8gaW5qZWN0IGVhY2ggbmV3IGV2ZW50IHNrZWxldG9uIGludG8gZWFjaCBhc3NvY2lhdGVkIHJvd1xuXHRcdHRoaXMucm93RWxzLmVhY2goZnVuY3Rpb24ocm93LCByb3dOb2RlKSB7XG5cdFx0XHR2YXIgcm93RWwgPSAkKHJvd05vZGUpOyAvLyB0aGUgLmZjLXJvd1xuXHRcdFx0dmFyIHNrZWxldG9uRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtaGVscGVyLXNrZWxldG9uXCI+PHRhYmxlLz48L2Rpdj4nKTsgLy8gd2lsbCBiZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWRcblx0XHRcdHZhciBza2VsZXRvblRvcDtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gb3JpZ2luYWwgc2VnbWVudCwgbWF0Y2ggdGhlIHRvcCBwb3NpdGlvbi4gT3RoZXJ3aXNlLCBwdXQgaXQgYXQgdGhlIHJvdydzIHRvcCBsZXZlbFxuXHRcdFx0aWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcucm93ID09PSByb3cpIHtcblx0XHRcdFx0c2tlbGV0b25Ub3AgPSBzb3VyY2VTZWcuZWwucG9zaXRpb24oKS50b3A7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2tlbGV0b25Ub3AgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0Ym9keScpLnBvc2l0aW9uKCkudG9wO1xuXHRcdFx0fVxuXG5cdFx0XHRza2VsZXRvbkVsLmNzcygndG9wJywgc2tlbGV0b25Ub3ApXG5cdFx0XHRcdC5maW5kKCd0YWJsZScpXG5cdFx0XHRcdFx0LmFwcGVuZChyb3dTdHJ1Y3RzW3Jvd10udGJvZHlFbCk7XG5cblx0XHRcdHJvd0VsLmFwcGVuZChza2VsZXRvbkVsKTtcblx0XHRcdGhlbHBlck5vZGVzLnB1c2goc2tlbGV0b25FbFswXSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCAvLyBtdXN0IHJldHVybiB0aGUgZWxlbWVudHMgcmVuZGVyZWRcblx0XHRcdHRoaXMuaGVscGVyRWxzID0gJChoZWxwZXJOb2RlcykgLy8gYXJyYXkgLT4galF1ZXJ5IHNldFxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgbW9jayBoZWxwZXIgZXZlbnRcblx0dW5yZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmhlbHBlckVscykge1xuXHRcdFx0dGhpcy5oZWxwZXJFbHMucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmhlbHBlckVscyA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRmlsbCBTeXN0ZW0gKGhpZ2hsaWdodCwgYmFja2dyb3VuZCBldmVudHMsIGJ1c2luZXNzIGhvdXJzKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0ZmlsbFNlZ1RhZzogJ3RkJywgLy8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGFnIG5hbWVcblxuXG5cdC8vIFJlbmRlcnMgYSBzZXQgb2YgcmVjdGFuZ2xlcyBvdmVyIHRoZSBnaXZlbiBzZWdtZW50cyBvZiBkYXlzLlxuXHQvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXG5cdHJlbmRlckZpbGw6IGZ1bmN0aW9uKHR5cGUsIHNlZ3MsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdHZhciBpLCBzZWc7XG5cdFx0dmFyIHNrZWxldG9uRWw7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGaWxsU2VnRWxzKHR5cGUsIHNlZ3MpOyAvLyBhc3NpZ25lcyBgLmVsYCB0byBlYWNoIHNlZy4gcmV0dXJucyBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgc2Vnc1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRza2VsZXRvbkVsID0gdGhpcy5yZW5kZXJGaWxsUm93KHR5cGUsIHNlZywgY2xhc3NOYW1lKTtcblx0XHRcdHRoaXMucm93RWxzLmVxKHNlZy5yb3cpLmFwcGVuZChza2VsZXRvbkVsKTtcblx0XHRcdG5vZGVzLnB1c2goc2tlbGV0b25FbFswXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbHNCeUZpbGxbdHlwZV0gPSAkKG5vZGVzKTtcblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIHJvdyBvZiBhIGZpbGwuIFJlcXVpcmVzIHRoZSBzZWcncyBlbCB0byBiZSByZW5kZXJlZC5cblx0cmVuZGVyRmlsbFJvdzogZnVuY3Rpb24odHlwZSwgc2VnLCBjbGFzc05hbWUpIHtcblx0XHR2YXIgY29sQ250ID0gdGhpcy5jb2xDbnQ7XG5cdFx0dmFyIHN0YXJ0Q29sID0gc2VnLmxlZnRDb2w7XG5cdFx0dmFyIGVuZENvbCA9IHNlZy5yaWdodENvbCArIDE7XG5cdFx0dmFyIHNrZWxldG9uRWw7XG5cdFx0dmFyIHRyRWw7XG5cblx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0c2tlbGV0b25FbCA9ICQoXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLScgKyBjbGFzc05hbWUgKyAnLXNrZWxldG9uXCI+JyArXG5cdFx0XHRcdCc8dGFibGU+PHRyLz48L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXHRcdHRyRWwgPSBza2VsZXRvbkVsLmZpbmQoJ3RyJyk7XG5cblx0XHRpZiAoc3RhcnRDb2wgPiAwKSB7XG5cdFx0XHR0ckVsLmFwcGVuZCgnPHRkIGNvbHNwYW49XCInICsgc3RhcnRDb2wgKyAnXCIvPicpO1xuXHRcdH1cblxuXHRcdHRyRWwuYXBwZW5kKFxuXHRcdFx0c2VnLmVsLmF0dHIoJ2NvbHNwYW4nLCBlbmRDb2wgLSBzdGFydENvbClcblx0XHQpO1xuXG5cdFx0aWYgKGVuZENvbCA8IGNvbENudCkge1xuXHRcdFx0dHJFbC5hcHBlbmQoJzx0ZCBjb2xzcGFuPVwiJyArIChjb2xDbnQgLSBlbmRDb2wpICsgJ1wiLz4nKTtcblx0XHR9XG5cblx0XHR0aGlzLmJvb2tlbmRDZWxscyh0ckVsKTtcblxuXHRcdHJldHVybiBza2VsZXRvbkVsO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBFdmVudC1yZW5kZXJpbmcgbWV0aG9kcyBmb3IgdGhlIERheUdyaWQgY2xhc3Ncbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5EYXlHcmlkLm1peGluKHtcblxuXHRyb3dTdHJ1Y3RzOiBudWxsLCAvLyBhbiBhcnJheSBvZiBvYmplY3RzLCBlYWNoIGhvbGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgYSByb3cncyBmb3JlZ3JvdW5kIGV2ZW50LXJlbmRlcmluZ1xuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCBldmVudHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXG5cdHVucmVuZGVyRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8gcmVtb3ZlcyB0aGUgXCJtb3JlLi5cIiBldmVudHMgcG9wb3ZlclxuXHRcdEdyaWQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGxzIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbGwgcmVuZGVyZWQgc2VnbWVudCBvYmplY3RzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxuXHRnZXRFdmVudFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBHcmlkLnByb3RvdHlwZS5nZXRFdmVudFNlZ3MuY2FsbCh0aGlzKSAvLyBnZXQgdGhlIHNlZ21lbnRzIGZyb20gdGhlIHN1cGVyLW1ldGhvZFxuXHRcdFx0LmNvbmNhdCh0aGlzLnBvcG92ZXJTZWdzIHx8IFtdKTsgLy8gYXBwZW5kIHRoZSBzZWdtZW50cyBmcm9tIHRoZSBcIm1vcmUuLi5cIiBwb3BvdmVyXG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBnaXZlbiBiYWNrZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcblx0cmVuZGVyQmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cblx0XHQvLyBkb24ndCByZW5kZXIgdGltZWQgYmFja2dyb3VuZCBldmVudHNcblx0XHR2YXIgYWxsRGF5U2VncyA9ICQuZ3JlcChzZWdzLCBmdW5jdGlvbihzZWcpIHtcblx0XHRcdHJldHVybiBzZWcuZXZlbnQuYWxsRGF5O1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIEdyaWQucHJvdG90eXBlLnJlbmRlckJnU2Vncy5jYWxsKHRoaXMsIGFsbERheVNlZ3MpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxuXHRyZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgcm93U3RydWN0cztcblxuXHRcdC8vIHJlbmRlciBhbiBgLmVsYCBvbiBlYWNoIHNlZ1xuXHRcdC8vIHJldHVybnMgYSBzdWJzZXQgb2YgdGhlIHNlZ3MuIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2Vncyk7XG5cblx0XHRyb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzID0gdGhpcy5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xuXG5cdFx0Ly8gYXBwZW5kIHRvIGVhY2ggcm93J3MgY29udGVudCBza2VsZXRvblxuXHRcdHRoaXMucm93RWxzLmVhY2goZnVuY3Rpb24oaSwgcm93Tm9kZSkge1xuXHRcdFx0JChyb3dOb2RlKS5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiA+IHRhYmxlJykuYXBwZW5kKFxuXHRcdFx0XHRyb3dTdHJ1Y3RzW2ldLnRib2R5RWxcblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc2VnczsgLy8gcmV0dXJuIG9ubHkgdGhlIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzXG5cdHVucmVuZGVyRmdTZWdzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyB8fCBbXTtcblx0XHR2YXIgcm93U3RydWN0O1xuXG5cdFx0d2hpbGUgKChyb3dTdHJ1Y3QgPSByb3dTdHJ1Y3RzLnBvcCgpKSkge1xuXHRcdFx0cm93U3RydWN0LnRib2R5RWwucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yb3dTdHJ1Y3RzID0gbnVsbDtcblx0fSxcblxuXG5cdC8vIFVzZXMgdGhlIGdpdmVuIGV2ZW50cyBhcnJheSB0byBnZW5lcmF0ZSA8dGJvZHk+IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIGVhY2ggcm93J3MgY29udGVudCBza2VsZXRvbi5cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiByb3dTdHJ1Y3Qgb2JqZWN0cyAoc2VlIHRoZSBib3R0b20gb2YgYHJlbmRlclNlZ1Jvd2ApLlxuXHQvLyBQUkVDT05ESVRJT046IGVhY2ggc2VnbWVudCBzaG91ZCBhbHJlYWR5IGhhdmUgYSByZW5kZXJlZCBhbmQgYXNzaWduZWQgYC5lbGBcblx0cmVuZGVyU2VnUm93czogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciByb3dTdHJ1Y3RzID0gW107XG5cdFx0dmFyIHNlZ1Jvd3M7XG5cdFx0dmFyIHJvdztcblxuXHRcdHNlZ1Jvd3MgPSB0aGlzLmdyb3VwU2VnUm93cyhzZWdzKTsgLy8gZ3JvdXAgaW50byBuZXN0ZWQgYXJyYXlzXG5cblx0XHQvLyBpdGVyYXRlIGVhY2ggcm93IG9mIHNlZ21lbnQgZ3JvdXBpbmdzXG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCBzZWdSb3dzLmxlbmd0aDsgcm93KyspIHtcblx0XHRcdHJvd1N0cnVjdHMucHVzaChcblx0XHRcdFx0dGhpcy5yZW5kZXJTZWdSb3cocm93LCBzZWdSb3dzW3Jvd10pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByb3dTdHJ1Y3RzO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIHRoZSBIVE1MIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IGVsZW1lbnQgZm9yIGFuIGluZGl2aWR1YWwgc2VnbWVudFxuXHRmZ1NlZ0h0bWw6IGZ1bmN0aW9uKHNlZywgZGlzYWJsZVJlc2l6aW5nKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERyYWdnYWJsZShldmVudCk7XG5cdFx0dmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBldmVudC5hbGxEYXkgJiZcblx0XHRcdHNlZy5pc1N0YXJ0ICYmIHZpZXcuaXNFdmVudFJlc2l6YWJsZUZyb21TdGFydChldmVudCk7XG5cdFx0dmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgZXZlbnQuYWxsRGF5ICYmXG5cdFx0XHRzZWcuaXNFbmQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbUVuZChldmVudCk7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kKTtcblx0XHR2YXIgc2tpbkNzcyA9IGNzc1RvU3RyKHRoaXMuZ2V0U2VnU2tpbkNzcyhzZWcpKTtcblx0XHR2YXIgdGltZUh0bWwgPSAnJztcblx0XHR2YXIgdGltZVRleHQ7XG5cdFx0dmFyIHRpdGxlSHRtbDtcblxuXHRcdGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LWdyaWQtZXZlbnQnLCAnZmMtaC1ldmVudCcpO1xuXG5cdFx0Ly8gT25seSBkaXNwbGF5IGEgdGltZWQgZXZlbnRzIHRpbWUgaWYgaXQgaXMgdGhlIHN0YXJ0aW5nIHNlZ21lbnRcblx0XHRpZiAoc2VnLmlzU3RhcnQpIHtcblx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50KTtcblx0XHRcdGlmICh0aW1lVGV4dCkge1xuXHRcdFx0XHR0aW1lSHRtbCA9ICc8c3BhbiBjbGFzcz1cImZjLXRpbWVcIj4nICsgaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPic7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGl0bGVIdG1sID1cblx0XHRcdCc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXG5cdFx0XHRcdChodG1sRXNjYXBlKGV2ZW50LnRpdGxlIHx8ICcnKSB8fCAnJm5ic3A7JykgKyAvLyB3ZSBhbHdheXMgd2FudCBvbmUgbGluZSBvZiBoZWlnaHRcblx0XHRcdCc8L3NwYW4+Jztcblx0XHRcblx0XHRyZXR1cm4gJzxhIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG5cdFx0XHRcdChldmVudC51cmwgP1xuXHRcdFx0XHRcdCcgaHJlZj1cIicgKyBodG1sRXNjYXBlKGV2ZW50LnVybCkgKyAnXCInIDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQoc2tpbkNzcyA/XG5cdFx0XHRcdFx0JyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdCc+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xuXHRcdFx0XHRcdCh0aGlzLmlzUlRMID9cblx0XHRcdFx0XHRcdHRpdGxlSHRtbCArICcgJyArIHRpbWVIdG1sIDogLy8gcHV0IGEgbmF0dXJhbCBzcGFjZSBpbiBiZXR3ZWVuXG5cdFx0XHRcdFx0XHR0aW1lSHRtbCArICcgJyArIHRpdGxlSHRtbCAgIC8vXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQoaXNSZXNpemFibGVGcm9tRW5kID9cblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtZW5kLXJlc2l6ZXJcIiAvPicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHQnPC9hPic7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHJvdyAjIGFuZCBhbiBhcnJheSBvZiBzZWdtZW50cyBhbGwgaW4gdGhlIHNhbWUgcm93LCByZW5kZXIgYSA8dGJvZHk+IGVsZW1lbnQsIGEgc2tlbGV0b24gdGhhdCBjb250YWluc1xuXHQvLyB0aGUgc2VnbWVudHMuIFJldHVybnMgb2JqZWN0IHdpdGggYSBidW5jaCBvZiBpbnRlcm5hbCBkYXRhIGFib3V0IGhvdyB0aGUgcmVuZGVyIHdhcyBjYWxjdWxhdGVkLlxuXHQvLyBOT1RFOiBtb2RpZmllcyByb3dTZWdzXG5cdHJlbmRlclNlZ1JvdzogZnVuY3Rpb24ocm93LCByb3dTZWdzKSB7XG5cdFx0dmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xuXHRcdHZhciBzZWdMZXZlbHMgPSB0aGlzLmJ1aWxkU2VnTGV2ZWxzKHJvd1NlZ3MpOyAvLyBncm91cCBpbnRvIHN1Yi1hcnJheXMgb2YgbGV2ZWxzXG5cdFx0dmFyIGxldmVsQ250ID0gTWF0aC5tYXgoMSwgc2VnTGV2ZWxzLmxlbmd0aCk7IC8vIGVuc3VyZSBhdCBsZWFzdCBvbmUgbGV2ZWxcblx0XHR2YXIgdGJvZHkgPSAkKCc8dGJvZHkvPicpO1xuXHRcdHZhciBzZWdNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciB3aGljaCBzZWdtZW50cyBhcmUgcmVuZGVyZWQgaW50byB3aGljaCBsZXZlbCtjb2wgY2VsbHNcblx0XHR2YXIgY2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIGFsbCA8dGQ+IGVsZW1lbnRzIG9mIHRoZSBsZXZlbCtjb2wgbWF0cml4XG5cdFx0dmFyIGxvbmVDZWxsTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3IgPHRkPiBlbGVtZW50cyB0aGF0IG9ubHkgdGFrZSB1cCBhIHNpbmdsZSBjb2x1bW5cblx0XHR2YXIgaSwgbGV2ZWxTZWdzO1xuXHRcdHZhciBjb2w7XG5cdFx0dmFyIHRyO1xuXHRcdHZhciBqLCBzZWc7XG5cdFx0dmFyIHRkO1xuXG5cdFx0Ly8gcG9wdWxhdGVzIGVtcHR5IGNlbGxzIGZyb20gdGhlIGN1cnJlbnQgY29sdW1uIChgY29sYCkgdG8gYGVuZENvbGBcblx0XHRmdW5jdGlvbiBlbXB0eUNlbGxzVW50aWwoZW5kQ29sKSB7XG5cdFx0XHR3aGlsZSAoY29sIDwgZW5kQ29sKSB7XG5cdFx0XHRcdC8vIHRyeSB0byBncmFiIGEgY2VsbCBmcm9tIHRoZSBsZXZlbCBhYm92ZSBhbmQgZXh0ZW5kIGl0cyByb3dzcGFuLiBvdGhlcndpc2UsIGNyZWF0ZSBhIGZyZXNoIGNlbGxcblx0XHRcdFx0dGQgPSAobG9uZUNlbGxNYXRyaXhbaSAtIDFdIHx8IFtdKVtjb2xdO1xuXHRcdFx0XHRpZiAodGQpIHtcblx0XHRcdFx0XHR0ZC5hdHRyKFxuXHRcdFx0XHRcdFx0J3Jvd3NwYW4nLFxuXHRcdFx0XHRcdFx0cGFyc2VJbnQodGQuYXR0cigncm93c3BhbicpIHx8IDEsIDEwKSArIDFcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRkID0gJCgnPHRkLz4nKTtcblx0XHRcdFx0XHR0ci5hcHBlbmQodGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xuXHRcdFx0XHRsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XG5cdFx0XHRcdGNvbCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZXZlbENudDsgaSsrKSB7IC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgbGV2ZWxzXG5cdFx0XHRsZXZlbFNlZ3MgPSBzZWdMZXZlbHNbaV07XG5cdFx0XHRjb2wgPSAwO1xuXHRcdFx0dHIgPSAkKCc8dHIvPicpO1xuXG5cdFx0XHRzZWdNYXRyaXgucHVzaChbXSk7XG5cdFx0XHRjZWxsTWF0cml4LnB1c2goW10pO1xuXHRcdFx0bG9uZUNlbGxNYXRyaXgucHVzaChbXSk7XG5cblx0XHRcdC8vIGxldmVsQ250IG1pZ2h0IGJlIDEgZXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIGFjdHVhbCBsZXZlbHMuIHByb3RlY3QgYWdhaW5zdCB0aGlzLlxuXHRcdFx0Ly8gdGhpcyBzaW5nbGUgZW1wdHkgcm93IGlzIHVzZWZ1bCBmb3Igc3R5bGluZy5cblx0XHRcdGlmIChsZXZlbFNlZ3MpIHtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGxldmVsU2Vncy5sZW5ndGg7IGorKykgeyAvLyBpdGVyYXRlIHRocm91Z2ggc2VnbWVudHMgaW4gbGV2ZWxcblx0XHRcdFx0XHRzZWcgPSBsZXZlbFNlZ3Nbal07XG5cblx0XHRcdFx0XHRlbXB0eUNlbGxzVW50aWwoc2VnLmxlZnRDb2wpO1xuXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGEgY29udGFpbmVyIHRoYXQgb2NjdXBpZXMgb3IgbW9yZSBjb2x1bW5zLiBhcHBlbmQgdGhlIGV2ZW50IGVsZW1lbnQuXG5cdFx0XHRcdFx0dGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIi8+JykuYXBwZW5kKHNlZy5lbCk7XG5cdFx0XHRcdFx0aWYgKHNlZy5sZWZ0Q29sICE9IHNlZy5yaWdodENvbCkge1xuXHRcdFx0XHRcdFx0dGQuYXR0cignY29sc3BhbicsIHNlZy5yaWdodENvbCAtIHNlZy5sZWZ0Q29sICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyAvLyBhIHNpbmdsZS1jb2x1bW4gc2VnbWVudFxuXHRcdFx0XHRcdFx0bG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlIChjb2wgPD0gc2VnLnJpZ2h0Q29sKSB7XG5cdFx0XHRcdFx0XHRjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcblx0XHRcdFx0XHRcdHNlZ01hdHJpeFtpXVtjb2xdID0gc2VnO1xuXHRcdFx0XHRcdFx0Y29sKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHIuYXBwZW5kKHRkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XG5cdFx0XHR0aGlzLmJvb2tlbmRDZWxscyh0cik7XG5cdFx0XHR0Ym9keS5hcHBlbmQodHIpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IC8vIGEgXCJyb3dTdHJ1Y3RcIlxuXHRcdFx0cm93OiByb3csIC8vIHRoZSByb3cgbnVtYmVyXG5cdFx0XHR0Ym9keUVsOiB0Ym9keSxcblx0XHRcdGNlbGxNYXRyaXg6IGNlbGxNYXRyaXgsXG5cdFx0XHRzZWdNYXRyaXg6IHNlZ01hdHJpeCxcblx0XHRcdHNlZ0xldmVsczogc2VnTGV2ZWxzLFxuXHRcdFx0c2Vnczogcm93U2Vnc1xuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBTdGFja3MgYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCB3aGljaCBhcmUgYWxsIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LCBpbnRvIHN1YmFycmF5cyBvZiB2ZXJ0aWNhbCBsZXZlbHMuXG5cdC8vIE5PVEU6IG1vZGlmaWVzIHNlZ3Ncblx0YnVpbGRTZWdMZXZlbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgbGV2ZWxzID0gW107XG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgajtcblxuXHRcdC8vIEdpdmUgcHJlZmVyZW5jZSB0byBlbGVtZW50cyB3aXRoIGNlcnRhaW4gY3JpdGVyaWEsIHNvIHRoZXkgaGF2ZVxuXHRcdC8vIGEgY2hhbmNlIHRvIGJlIGNsb3NlciB0byB0aGUgdG9wLlxuXHRcdHRoaXMuc29ydEV2ZW50U2VncyhzZWdzKTtcblx0XHRcblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCwgdW50aWwgdGhlIHNlZ21lbnQgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgc2VnbWVudHNcblx0XHRcdGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKCFpc0RheVNlZ0NvbGxpc2lvbihzZWcsIGxldmVsc1tqXSkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYGpgIG5vdyBob2xkcyB0aGUgZGVzaXJlZCBzdWJyb3cgaW5kZXhcblx0XHRcdHNlZy5sZXZlbCA9IGo7XG5cblx0XHRcdC8vIGNyZWF0ZSBuZXcgbGV2ZWwgYXJyYXkgaWYgbmVlZGVkIGFuZCBhcHBlbmQgc2VnbWVudFxuXHRcdFx0KGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XG5cdFx0fVxuXG5cdFx0Ly8gb3JkZXIgc2VnbWVudHMgbGVmdC10by1yaWdodC4gdmVyeSBpbXBvcnRhbnQgaWYgY2FsZW5kYXIgaXMgUlRMXG5cdFx0Zm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0bGV2ZWxzW2pdLnNvcnQoY29tcGFyZURheVNlZ0NvbHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZXZlbHM7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIHJvd1xuXHRncm91cFNlZ1Jvd3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgc2VnUm93cyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMucm93Q250OyBpKyspIHtcblx0XHRcdHNlZ1Jvd3MucHVzaChbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ1Jvd3Nbc2Vnc1tpXS5yb3ddLnB1c2goc2Vnc1tpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ1Jvd3M7XG5cdH1cblxufSk7XG5cblxuLy8gQ29tcHV0ZXMgd2hldGhlciB0d28gc2VnbWVudHMnIGNvbHVtbnMgY29sbGlkZS4gVGhleSBhcmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3cuXG5mdW5jdGlvbiBpc0RheVNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vncykge1xuXHR2YXIgaSwgb3RoZXJTZWc7XG5cblx0Zm9yIChpID0gMDsgaSA8IG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdG90aGVyU2VnID0gb3RoZXJTZWdzW2ldO1xuXG5cdFx0aWYgKFxuXHRcdFx0b3RoZXJTZWcubGVmdENvbCA8PSBzZWcucmlnaHRDb2wgJiZcblx0XHRcdG90aGVyU2VnLnJpZ2h0Q29sID49IHNlZy5sZWZ0Q29sXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHRoZSBsZWZ0bW9zdCBldmVudFxuZnVuY3Rpb24gY29tcGFyZURheVNlZ0NvbHMoYSwgYikge1xuXHRyZXR1cm4gYS5sZWZ0Q29sIC0gYi5sZWZ0Q29sO1xufVxuXG47O1xuXG4vKiBNZXRob2RzIHJlbGF0ZSB0byBsaW1pdGluZyB0aGUgbnVtYmVyIGV2ZW50cyBmb3IgYSBnaXZlbiBkYXkgb24gYSBEYXlHcmlkXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE5PVEU6IGFsbCB0aGUgc2VncyBiZWluZyBwYXNzZWQgYXJvdW5kIGluIGhlcmUgYXJlIGZvcmVncm91bmQgc2Vnc1xuXG5EYXlHcmlkLm1peGluKHtcblxuXHRzZWdQb3BvdmVyOiBudWxsLCAvLyB0aGUgUG9wb3ZlciB0aGF0IGhvbGRzIGV2ZW50cyB0aGF0IGNhbid0IGZpdCBpbiBhIGNlbGwuIG51bGwgd2hlbiBub3QgdmlzaWJsZVxuXHRwb3BvdmVyU2VnczogbnVsbCwgLy8gYW4gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIHRoYXQgdGhlIHNlZ1BvcG92ZXIgaG9sZHMuIG51bGwgd2hlbiBub3QgdmlzaWJsZVxuXG5cblx0cmVtb3ZlU2VnUG9wb3ZlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuc2VnUG9wb3Zlcikge1xuXHRcdFx0dGhpcy5zZWdQb3BvdmVyLmhpZGUoKTsgLy8gaW4gaGFuZGxlciwgd2lsbCBjYWxsIHNlZ1BvcG92ZXIncyByZW1vdmVFbGVtZW50XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gTGltaXRzIHRoZSBudW1iZXIgb2YgXCJsZXZlbHNcIiAodmVydGljYWxseSBzdGFja2luZyBsYXllcnMgb2YgZXZlbnRzKSBmb3IgZWFjaCByb3cgb2YgdGhlIGdyaWQuXG5cdC8vIGBsZXZlbExpbWl0YCBjYW4gYmUgZmFsc2UgKGRvbid0IGxpbWl0KSwgYSBudW1iZXIsIG9yIHRydWUgKHNob3VsZCBiZSBjb21wdXRlZCkuXG5cdGxpbWl0Um93czogZnVuY3Rpb24obGV2ZWxMaW1pdCkge1xuXHRcdHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzIHx8IFtdO1xuXHRcdHZhciByb3c7IC8vIHJvdyAjXG5cdFx0dmFyIHJvd0xldmVsTGltaXQ7XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd1N0cnVjdHMubGVuZ3RoOyByb3crKykge1xuXHRcdFx0dGhpcy51bmxpbWl0Um93KHJvdyk7XG5cblx0XHRcdGlmICghbGV2ZWxMaW1pdCkge1xuXHRcdFx0XHRyb3dMZXZlbExpbWl0ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgbGV2ZWxMaW1pdCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cm93TGV2ZWxMaW1pdCA9IGxldmVsTGltaXQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93TGV2ZWxMaW1pdCA9IHRoaXMuY29tcHV0ZVJvd0xldmVsTGltaXQocm93KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJvd0xldmVsTGltaXQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMubGltaXRSb3cocm93LCByb3dMZXZlbExpbWl0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIGxldmVscyBhIHJvdyB3aWxsIGFjY29tb2RhdGUgd2l0aG91dCBnb2luZyBvdXRzaWRlIGl0cyBib3VuZHMuXG5cdC8vIEFzc3VtZXMgdGhlIHJvdyBpcyBcInJpZ2lkXCIgKG1haW50YWlucyBhIGNvbnN0YW50IGhlaWdodCByZWdhcmRsZXNzIG9mIHdoYXQgaXMgaW5zaWRlKS5cblx0Ly8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG5cdGNvbXB1dGVSb3dMZXZlbExpbWl0OiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgcm93RWwgPSB0aGlzLnJvd0Vscy5lcShyb3cpOyAvLyB0aGUgY29udGFpbmluZyBcImZha2VcIiByb3cgZGl2XG5cdFx0dmFyIHJvd0hlaWdodCA9IHJvd0VsLmhlaWdodCgpOyAvLyBUT0RPOiBjYWNoZSBzb21laG93P1xuXHRcdHZhciB0ckVscyA9IHRoaXMucm93U3RydWN0c1tyb3ddLnRib2R5RWwuY2hpbGRyZW4oKTtcblx0XHR2YXIgaSwgdHJFbDtcblx0XHR2YXIgdHJIZWlnaHQ7XG5cblx0XHRmdW5jdGlvbiBpdGVySW5uZXJIZWlnaHRzKGksIGNoaWxkTm9kZSkge1xuXHRcdFx0dHJIZWlnaHQgPSBNYXRoLm1heCh0ckhlaWdodCwgJChjaGlsZE5vZGUpLm91dGVySGVpZ2h0KCkpO1xuXHRcdH1cblxuXHRcdC8vIFJldmVhbCBvbmUgbGV2ZWwgPHRyPiBhdCBhIHRpbWUgYW5kIHN0b3Agd2hlbiB3ZSBmaW5kIG9uZSBvdXQgb2YgYm91bmRzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRyRWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0ckVsID0gdHJFbHMuZXEoaSkucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc3RhdGUgKHJldmVhbClcblxuXHRcdFx0Ly8gd2l0aCByb3dzcGFucz4xIGFuZCBJRTgsIHRyRWwub3V0ZXJIZWlnaHQoKSB3b3VsZCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgbGFyZ2VzdCBjZWxsLFxuXHRcdFx0Ly8gc28gaW5zdGVhZCwgZmluZCB0aGUgdGFsbGVzdCBpbm5lciBjb250ZW50IGVsZW1lbnQuXG5cdFx0XHR0ckhlaWdodCA9IDA7XG5cdFx0XHR0ckVsLmZpbmQoJz4gdGQgPiA6Zmlyc3QtY2hpbGQnKS5lYWNoKGl0ZXJJbm5lckhlaWdodHMpO1xuXG5cdFx0XHRpZiAodHJFbC5wb3NpdGlvbigpLnRvcCArIHRySGVpZ2h0ID4gcm93SGVpZ2h0KSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTsgLy8gc2hvdWxkIG5vdCBsaW1pdCBhdCBhbGxcblx0fSxcblxuXG5cdC8vIExpbWl0cyB0aGUgZ2l2ZW4gZ3JpZCByb3cgdG8gdGhlIG1heGltdW0gbnVtYmVyIG9mIGxldmVscyBhbmQgaW5qZWN0cyBcIm1vcmVcIiBsaW5rcyBpZiBuZWNlc3NhcnkuXG5cdC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxuXHQvLyBgbGV2ZWxMaW1pdGAgaXMgYSBudW1iZXIgZm9yIHRoZSBtYXhpbXVtIChpbmNsdXNpdmUpIG51bWJlciBvZiBsZXZlbHMgYWxsb3dlZC5cblx0bGltaXRSb3c6IGZ1bmN0aW9uKHJvdywgbGV2ZWxMaW1pdCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHJvd1N0cnVjdCA9IHRoaXMucm93U3RydWN0c1tyb3ddO1xuXHRcdHZhciBtb3JlTm9kZXMgPSBbXTsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPGE+IGxpbmtzIGFuZCA8dGQ+IERPTSBub2Rlc1xuXHRcdHZhciBjb2wgPSAwOyAvLyBjb2wgIywgbGVmdC10by1yaWdodCAobm90IGNocm9ub2xvZ2ljYWxseSlcblx0XHR2YXIgbGV2ZWxTZWdzOyAvLyBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMgaW4gdGhlIGxhc3QgYWxsb3dhYmxlIGxldmVsLCBvcmRlcmVkIGxlZnQtdG8tcmlnaHRcblx0XHR2YXIgY2VsbE1hdHJpeDsgLy8gYSBtYXRyaXggKGJ5IGxldmVsLCB0aGVuIGNvbHVtbikgb2YgYWxsIDx0ZD4galF1ZXJ5IGVsZW1lbnRzIGluIHRoZSByb3dcblx0XHR2YXIgbGltaXRlZE5vZGVzOyAvLyBhcnJheSBvZiB0ZW1wb3JhcmlseSBoaWRkZW4gbGV2ZWwgPHRyPiBhbmQgc2VnbWVudCA8dGQ+IERPTSBub2Rlc1xuXHRcdHZhciBpLCBzZWc7XG5cdFx0dmFyIHNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGJlbG93IGBzZWdgIGluIHRoZSBjdXJyZW50IGBjb2xgXG5cdFx0dmFyIHRvdGFsU2Vnc0JlbG93OyAvLyB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgYmVsb3cgYHNlZ2AgaW4gYW55IG9mIHRoZSBjb2x1bW5zIGBzZWdgIG9jY3VwaWVzXG5cdFx0dmFyIGNvbFNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBhcnJheXMsIGJlbG93IHNlZywgb25lIGZvciBlYWNoIGNvbHVtbiAob2Zmc2V0IGZyb20gc2VncydzIGZpcnN0IGNvbHVtbilcblx0XHR2YXIgdGQsIHJvd3NwYW47XG5cdFx0dmFyIHNlZ01vcmVOb2RlczsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPHRkPiBjZWxscyB0aGF0IHdpbGwgc3RhbmQtaW4gZm9yIHRoZSBjdXJyZW50IHNlZydzIGNlbGxcblx0XHR2YXIgajtcblx0XHR2YXIgbW9yZVRkLCBtb3JlV3JhcCwgbW9yZUxpbms7XG5cblx0XHQvLyBJdGVyYXRlcyB0aHJvdWdoIGVtcHR5IGxldmVsIGNlbGxzIGFuZCBwbGFjZXMgXCJtb3JlXCIgbGlua3MgaW5zaWRlIGlmIG5lZWQgYmVcblx0XHRmdW5jdGlvbiBlbXB0eUNlbGxzVW50aWwoZW5kQ29sKSB7IC8vIGdvZXMgZnJvbSBjdXJyZW50IGBjb2xgIHRvIGBlbmRDb2xgXG5cdFx0XHR3aGlsZSAoY29sIDwgZW5kQ29sKSB7XG5cdFx0XHRcdHNlZ3NCZWxvdyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcblx0XHRcdFx0aWYgKHNlZ3NCZWxvdy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW2NvbF07XG5cdFx0XHRcdFx0bW9yZUxpbmsgPSBfdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIGNvbCwgc2Vnc0JlbG93KTtcblx0XHRcdFx0XHRtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XG5cdFx0XHRcdFx0dGQuYXBwZW5kKG1vcmVXcmFwKTtcblx0XHRcdFx0XHRtb3JlTm9kZXMucHVzaChtb3JlV3JhcFswXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGxldmVsTGltaXQgJiYgbGV2ZWxMaW1pdCA8IHJvd1N0cnVjdC5zZWdMZXZlbHMubGVuZ3RoKSB7IC8vIGlzIGl0IGFjdHVhbGx5IG92ZXIgdGhlIGxpbWl0P1xuXHRcdFx0bGV2ZWxTZWdzID0gcm93U3RydWN0LnNlZ0xldmVsc1tsZXZlbExpbWl0IC0gMV07XG5cdFx0XHRjZWxsTWF0cml4ID0gcm93U3RydWN0LmNlbGxNYXRyaXg7XG5cblx0XHRcdGxpbWl0ZWROb2RlcyA9IHJvd1N0cnVjdC50Ym9keUVsLmNoaWxkcmVuKCkuc2xpY2UobGV2ZWxMaW1pdCkgLy8gZ2V0IGxldmVsIDx0cj4gZWxlbWVudHMgcGFzdCB0aGUgbGltaXRcblx0XHRcdFx0LmFkZENsYXNzKCdmYy1saW1pdGVkJykuZ2V0KCk7IC8vIGhpZGUgZWxlbWVudHMgYW5kIGdldCBhIHNpbXBsZSBET00tbm9kZXMgYXJyYXlcblxuXHRcdFx0Ly8gaXRlcmF0ZSB0aG91Z2ggc2VnbWVudHMgaW4gdGhlIGxhc3QgYWxsb3dhYmxlIGxldmVsXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNlZyA9IGxldmVsU2Vnc1tpXTtcblx0XHRcdFx0ZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTsgLy8gcHJvY2VzcyBlbXB0eSBjZWxscyBiZWZvcmUgdGhlIHNlZ21lbnRcblxuXHRcdFx0XHQvLyBkZXRlcm1pbmUgKmFsbCogc2VnbWVudHMgYmVsb3cgYHNlZ2AgdGhhdCBvY2N1cHkgdGhlIHNhbWUgY29sdW1uc1xuXHRcdFx0XHRjb2xTZWdzQmVsb3cgPSBbXTtcblx0XHRcdFx0dG90YWxTZWdzQmVsb3cgPSAwO1xuXHRcdFx0XHR3aGlsZSAoY29sIDw9IHNlZy5yaWdodENvbCkge1xuXHRcdFx0XHRcdHNlZ3NCZWxvdyA9IHRoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wsIGxldmVsTGltaXQpO1xuXHRcdFx0XHRcdGNvbFNlZ3NCZWxvdy5wdXNoKHNlZ3NCZWxvdyk7XG5cdFx0XHRcdFx0dG90YWxTZWdzQmVsb3cgKz0gc2Vnc0JlbG93Lmxlbmd0aDtcblx0XHRcdFx0XHRjb2wrKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0b3RhbFNlZ3NCZWxvdykgeyAvLyBkbyB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhpcyBzZWdtZW50IHdpdGggb25lIG9yIG1hbnkgXCJtb3JlXCIgbGlua3M/XG5cdFx0XHRcdFx0dGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtzZWcubGVmdENvbF07IC8vIHRoZSBzZWdtZW50J3MgcGFyZW50IGNlbGxcblx0XHRcdFx0XHRyb3dzcGFuID0gdGQuYXR0cigncm93c3BhbicpIHx8IDE7XG5cdFx0XHRcdFx0c2VnTW9yZU5vZGVzID0gW107XG5cblx0XHRcdFx0XHQvLyBtYWtlIGEgcmVwbGFjZW1lbnQgPHRkPiBmb3IgZWFjaCBjb2x1bW4gdGhlIHNlZ21lbnQgb2NjdXBpZXMuIHdpbGwgYmUgb25lIGZvciBlYWNoIGNvbHNwYW5cblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgY29sU2Vnc0JlbG93Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRtb3JlVGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1tb3JlLWNlbGxcIi8+JykuYXR0cigncm93c3BhbicsIHJvd3NwYW4pO1xuXHRcdFx0XHRcdFx0c2Vnc0JlbG93ID0gY29sU2Vnc0JlbG93W2pdO1xuXHRcdFx0XHRcdFx0bW9yZUxpbmsgPSB0aGlzLnJlbmRlck1vcmVMaW5rKFxuXHRcdFx0XHRcdFx0XHRyb3csXG5cdFx0XHRcdFx0XHRcdHNlZy5sZWZ0Q29sICsgaixcblx0XHRcdFx0XHRcdFx0WyBzZWcgXS5jb25jYXQoc2Vnc0JlbG93KSAvLyBjb3VudCBzZWcgYXMgaGlkZGVuIHRvb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdG1vcmVXcmFwID0gJCgnPGRpdi8+JykuYXBwZW5kKG1vcmVMaW5rKTtcblx0XHRcdFx0XHRcdG1vcmVUZC5hcHBlbmQobW9yZVdyYXApO1xuXHRcdFx0XHRcdFx0c2VnTW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcblx0XHRcdFx0XHRcdG1vcmVOb2Rlcy5wdXNoKG1vcmVUZFswXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGQuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5hZnRlcigkKHNlZ01vcmVOb2RlcykpOyAvLyBoaWRlIG9yaWdpbmFsIDx0ZD4gYW5kIGluamVjdCByZXBsYWNlbWVudHNcblx0XHRcdFx0XHRsaW1pdGVkTm9kZXMucHVzaCh0ZFswXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZW1wdHlDZWxsc1VudGlsKHRoaXMuY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgbGV2ZWxcblx0XHRcdHJvd1N0cnVjdC5tb3JlRWxzID0gJChtb3JlTm9kZXMpOyAvLyBmb3IgZWFzeSB1bmRvaW5nIGxhdGVyXG5cdFx0XHRyb3dTdHJ1Y3QubGltaXRlZEVscyA9ICQobGltaXRlZE5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJldmVhbHMgYWxsIGxldmVscyBhbmQgcmVtb3ZlcyBhbGwgXCJtb3JlXCItcmVsYXRlZCBlbGVtZW50cyBmb3IgYSBncmlkJ3Mgcm93LlxuXHQvLyBgcm93YCBpcyBhIHJvdyBudW1iZXIuXG5cdHVubGltaXRSb3c6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHZhciByb3dTdHJ1Y3QgPSB0aGlzLnJvd1N0cnVjdHNbcm93XTtcblxuXHRcdGlmIChyb3dTdHJ1Y3QubW9yZUVscykge1xuXHRcdFx0cm93U3RydWN0Lm1vcmVFbHMucmVtb3ZlKCk7XG5cdFx0XHRyb3dTdHJ1Y3QubW9yZUVscyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHJvd1N0cnVjdC5saW1pdGVkRWxzKSB7XG5cdFx0XHRyb3dTdHJ1Y3QubGltaXRlZEVscy5yZW1vdmVDbGFzcygnZmMtbGltaXRlZCcpO1xuXHRcdFx0cm93U3RydWN0LmxpbWl0ZWRFbHMgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYW4gPGE+IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGhpZGRlbiBldmVudCBlbGVtZW50IGZvciBhIGNlbGwuXG5cdC8vIFJlc3BvbnNpYmxlIGZvciBhdHRhY2hpbmcgY2xpY2sgaGFuZGxlciBhcyB3ZWxsLlxuXHRyZW5kZXJNb3JlTGluazogZnVuY3Rpb24ocm93LCBjb2wsIGhpZGRlblNlZ3MpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICQoJzxhIGNsYXNzPVwiZmMtbW9yZVwiLz4nKVxuXHRcdFx0LnRleHQoXG5cdFx0XHRcdHRoaXMuZ2V0TW9yZUxpbmtUZXh0KGhpZGRlblNlZ3MubGVuZ3RoKVxuXHRcdFx0KVxuXHRcdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHZhciBjbGlja09wdGlvbiA9IHZpZXcub3B0KCdldmVudExpbWl0Q2xpY2snKTtcblx0XHRcdFx0dmFyIGRhdGUgPSBfdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0XHRcdHZhciBtb3JlRWwgPSAkKHRoaXMpO1xuXHRcdFx0XHR2YXIgZGF5RWwgPSBfdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpO1xuXHRcdFx0XHR2YXIgYWxsU2VncyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sKTtcblxuXHRcdFx0XHQvLyByZXNjb3BlIHRoZSBzZWdtZW50cyB0byBiZSB3aXRoaW4gdGhlIGNlbGwncyBkYXRlXG5cdFx0XHRcdHZhciByZXNsaWNlZEFsbFNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhhbGxTZWdzLCBkYXRlKTtcblx0XHRcdFx0dmFyIHJlc2xpY2VkSGlkZGVuU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGhpZGRlblNlZ3MsIGRhdGUpO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YgY2xpY2tPcHRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHQvLyB0aGUgcmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIGF0b21pYyBvcHRpb25cblx0XHRcdFx0XHRjbGlja09wdGlvbiA9IHZpZXcudHJpZ2dlcignZXZlbnRMaW1pdENsaWNrJywgbnVsbCwge1xuXHRcdFx0XHRcdFx0ZGF0ZTogZGF0ZSxcblx0XHRcdFx0XHRcdGRheUVsOiBkYXlFbCxcblx0XHRcdFx0XHRcdG1vcmVFbDogbW9yZUVsLFxuXHRcdFx0XHRcdFx0c2VnczogcmVzbGljZWRBbGxTZWdzLFxuXHRcdFx0XHRcdFx0aGlkZGVuU2VnczogcmVzbGljZWRIaWRkZW5TZWdzXG5cdFx0XHRcdFx0fSwgZXYpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNsaWNrT3B0aW9uID09PSAncG9wb3ZlcicpIHtcblx0XHRcdFx0XHRfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcblx0XHRcdFx0XHR2aWV3LmNhbGVuZGFyLnpvb21UbyhkYXRlLCBjbGlja09wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gUmV2ZWFscyB0aGUgcG9wb3ZlciB0aGF0IGRpc3BsYXlzIGFsbCBldmVudHMgd2l0aGluIGEgY2VsbFxuXHRzaG93U2VnUG9wb3ZlcjogZnVuY3Rpb24ocm93LCBjb2wsIG1vcmVMaW5rLCBzZWdzKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgbW9yZVdyYXAgPSBtb3JlTGluay5wYXJlbnQoKTsgLy8gdGhlIDxkaXY+IHdyYXBwZXIgYXJvdW5kIHRoZSA8YT5cblx0XHR2YXIgdG9wRWw7IC8vIHRoZSBlbGVtZW50IHdlIHdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBjb29yZGluYXRlIG9mXG5cdFx0dmFyIG9wdGlvbnM7XG5cblx0XHRpZiAodGhpcy5yb3dDbnQgPT0gMSkge1xuXHRcdFx0dG9wRWwgPSB2aWV3LmVsOyAvLyB3aWxsIGNhdXNlIHRoZSBwb3BvdmVyIHRvIGNvdmVyIGFueSBzb3J0IG9mIGhlYWRlclxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRvcEVsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gd2lsbCBhbGlnbiB3aXRoIHRvcCBvZiByb3dcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0Y2xhc3NOYW1lOiAnZmMtbW9yZS1wb3BvdmVyJyxcblx0XHRcdGNvbnRlbnQ6IHRoaXMucmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQocm93LCBjb2wsIHNlZ3MpLFxuXHRcdFx0cGFyZW50RWw6IHRoaXMuZWwsXG5cdFx0XHR0b3A6IHRvcEVsLm9mZnNldCgpLnRvcCxcblx0XHRcdGF1dG9IaWRlOiB0cnVlLCAvLyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBlbHNld2hlcmUsIGhpZGUgdGhlIHBvcG92ZXJcblx0XHRcdHZpZXdwb3J0Q29uc3RyYWluOiB2aWV3Lm9wdCgncG9wb3ZlclZpZXdwb3J0Q29uc3RyYWluJyksXG5cdFx0XHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8ga2lsbCBldmVyeXRoaW5nIHdoZW4gdGhlIHBvcG92ZXIgaXMgaGlkZGVuXG5cdFx0XHRcdF90aGlzLnNlZ1BvcG92ZXIucmVtb3ZlRWxlbWVudCgpO1xuXHRcdFx0XHRfdGhpcy5zZWdQb3BvdmVyID0gbnVsbDtcblx0XHRcdFx0X3RoaXMucG9wb3ZlclNlZ3MgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBEZXRlcm1pbmUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuXHRcdC8vIFdlIHVzZSB0aGUgbW9yZVdyYXAgaW5zdGVhZCBvZiB0aGUgPHRkPiB0byBhdm9pZCBib3JkZXIgY29uZnVzaW9uLlxuXHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRvcHRpb25zLnJpZ2h0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCArIG1vcmVXcmFwLm91dGVyV2lkdGgoKSArIDE7IC8vICsxIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRvcHRpb25zLmxlZnQgPSBtb3JlV3JhcC5vZmZzZXQoKS5sZWZ0IC0gMTsgLy8gLTEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxuXHRcdH1cblxuXHRcdHRoaXMuc2VnUG9wb3ZlciA9IG5ldyBQb3BvdmVyKG9wdGlvbnMpO1xuXHRcdHRoaXMuc2VnUG9wb3Zlci5zaG93KCk7XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgdGhlIGlubmVyIERPTSBjb250ZW50cyBvZiB0aGUgc2VnbWVudCBwb3BvdmVyXG5cdHJlbmRlclNlZ1BvcG92ZXJDb250ZW50OiBmdW5jdGlvbihyb3csIGNvbCwgc2Vncykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBpc1RoZW1lID0gdmlldy5vcHQoJ3RoZW1lJyk7XG5cdFx0dmFyIHRpdGxlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCkuZm9ybWF0KHZpZXcub3B0KCdkYXlQb3BvdmVyRm9ybWF0JykpO1xuXHRcdHZhciBjb250ZW50ID0gJChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtaGVhZGVyICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJmYy1jbG9zZSAnICtcblx0XHRcdFx0XHQoaXNUaGVtZSA/ICd1aS1pY29uIHVpLWljb24tY2xvc2V0aGljaycgOiAnZmMtaWNvbiBmYy1pY29uLXgnKSArXG5cdFx0XHRcdCdcIj48L3NwYW4+JyArXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXG5cdFx0XHRcdFx0aHRtbEVzY2FwZSh0aXRsZSkgK1xuXHRcdFx0XHQnPC9zcGFuPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1ib2R5ICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcblx0XHRcdCc8L2Rpdj4nXG5cdFx0KTtcblx0XHR2YXIgc2VnQ29udGFpbmVyID0gY29udGVudC5maW5kKCcuZmMtZXZlbnQtY29udGFpbmVyJyk7XG5cdFx0dmFyIGk7XG5cblx0XHQvLyByZW5kZXIgZWFjaCBzZWcncyBgZWxgIGFuZCBvbmx5IHJldHVybiB0aGUgdmlzaWJsZSBzZWdzXG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2VncywgdHJ1ZSk7IC8vIGRpc2FibGVSZXNpemluZz10cnVlXG5cdFx0dGhpcy5wb3BvdmVyU2VncyA9IHNlZ3M7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHQvLyBiZWNhdXNlIHNlZ21lbnRzIGluIHRoZSBwb3BvdmVyIGFyZSBub3QgcGFydCBvZiBhIGdyaWQgY29vcmRpbmF0ZSBzeXN0ZW0sIHByb3ZpZGUgYSBoaW50IHRvIGFueVxuXHRcdFx0Ly8gZ3JpZHMgdGhhdCB3YW50IHRvIGRvIGRyYWctbi1kcm9wIGFib3V0IHdoaWNoIGNlbGwgaXQgY2FtZSBmcm9tXG5cdFx0XHR0aGlzLnByZXBhcmVIaXRzKCk7XG5cdFx0XHRzZWdzW2ldLmhpdCA9IHRoaXMuZ2V0Q2VsbEhpdChyb3csIGNvbCk7XG5cdFx0XHR0aGlzLnJlbGVhc2VIaXRzKCk7XG5cblx0XHRcdHNlZ0NvbnRhaW5lci5hcHBlbmQoc2Vnc1tpXS5lbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgZXZlbnRzIHdpdGhpbiBhbiBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMsIHJlc2xpY2UgdGhlbSB0byBiZSBpbiBhIHNpbmdsZSBkYXlcblx0cmVzbGljZURheVNlZ3M6IGZ1bmN0aW9uKHNlZ3MsIGRheURhdGUpIHtcblxuXHRcdC8vIGJ1aWxkIGFuIGFycmF5IG9mIHRoZSBvcmlnaW5hbCBldmVudHNcblx0XHR2YXIgZXZlbnRzID0gJC5tYXAoc2VncywgZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRyZXR1cm4gc2VnLmV2ZW50O1xuXHRcdH0pO1xuXG5cdFx0dmFyIGRheVN0YXJ0ID0gZGF5RGF0ZS5jbG9uZSgpO1xuXHRcdHZhciBkYXlFbmQgPSBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xuXHRcdHZhciBkYXlSYW5nZSA9IHsgc3RhcnQ6IGRheVN0YXJ0LCBlbmQ6IGRheUVuZCB9O1xuXG5cdFx0Ly8gc2xpY2UgdGhlIGV2ZW50cyB3aXRoIGEgY3VzdG9tIHNsaWNpbmcgZnVuY3Rpb25cblx0XHRzZWdzID0gdGhpcy5ldmVudHNUb1NlZ3MoXG5cdFx0XHRldmVudHMsXG5cdFx0XHRmdW5jdGlvbihyYW5nZSkge1xuXHRcdFx0XHR2YXIgc2VnID0gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZSk7IC8vIHVuZGVmaW5kIGlmIG5vIGludGVyc2VjdGlvblxuXHRcdFx0XHRyZXR1cm4gc2VnID8gWyBzZWcgXSA6IFtdOyAvLyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBzZWdtZW50c1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHQvLyBmb3JjZSBhbiBvcmRlciBiZWNhdXNlIGV2ZW50c1RvU2VncyBkb2Vzbid0IGd1YXJhbnRlZSBvbmVcblx0XHR0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBpbnNpZGUgYSBcIm1vcmVcIiBsaW5rLCBnaXZlbiB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpdCByZXByZXNlbnRzXG5cdGdldE1vcmVMaW5rVGV4dDogZnVuY3Rpb24obnVtKSB7XG5cdFx0dmFyIG9wdCA9IHRoaXMudmlldy5vcHQoJ2V2ZW50TGltaXRUZXh0Jyk7XG5cblx0XHRpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG9wdChudW0pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiAnKycgKyBudW0gKyAnICcgKyBvcHQ7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBzZWdtZW50cyB3aXRoaW4gYSBnaXZlbiBjZWxsLlxuXHQvLyBJZiBgc3RhcnRMZXZlbGAgaXMgc3BlY2lmaWVkLCByZXR1cm5zIG9ubHkgZXZlbnRzIGluY2x1ZGluZyBhbmQgYmVsb3cgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlIHJldHVybnMgYWxsIHNlZ3MuXG5cdGdldENlbGxTZWdzOiBmdW5jdGlvbihyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xuXHRcdHZhciBzZWdNYXRyaXggPSB0aGlzLnJvd1N0cnVjdHNbcm93XS5zZWdNYXRyaXg7XG5cdFx0dmFyIGxldmVsID0gc3RhcnRMZXZlbCB8fCAwO1xuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHNlZztcblxuXHRcdHdoaWxlIChsZXZlbCA8IHNlZ01hdHJpeC5sZW5ndGgpIHtcblx0XHRcdHNlZyA9IHNlZ01hdHJpeFtsZXZlbF1bY29sXTtcblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0c2Vncy5wdXNoKHNlZyk7XG5cdFx0XHR9XG5cdFx0XHRsZXZlbCsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFdlIG1peGluIERheVRhYmxlLCBldmVuIHRob3VnaCB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHJvdyBvZiBkYXlzXG5cbnZhciBUaW1lR3JpZCA9IEZDLlRpbWVHcmlkID0gR3JpZC5leHRlbmQoRGF5VGFibGVNaXhpbiwge1xuXG5cdHNsb3REdXJhdGlvbjogbnVsbCwgLy8gZHVyYXRpb24gb2YgYSBcInNsb3RcIiwgYSBkaXN0aW5jdCB0aW1lIHNlZ21lbnQgb24gZ2l2ZW4gZGF5LCB2aXN1YWxpemVkIGJ5IGxpbmVzXG5cdHNuYXBEdXJhdGlvbjogbnVsbCwgLy8gZ3JhbnVsYXJpdHkgb2YgdGltZSBmb3IgZHJhZ2dpbmcgYW5kIHNlbGVjdGluZ1xuXHRzbmFwc1BlclNsb3Q6IG51bGwsXG5cdG1pblRpbWU6IG51bGwsIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG5cdG1heFRpbWU6IG51bGwsIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcblx0bGFiZWxGb3JtYXQ6IG51bGwsIC8vIGZvcm1hdHRpbmcgc3RyaW5nIGZvciB0aW1lcyBydW5uaW5nIGFsb25nIHZlcnRpY2FsIGF4aXNcblx0bGFiZWxJbnRlcnZhbDogbnVsbCwgLy8gZHVyYXRpb24gb2YgaG93IG9mdGVuIGEgbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCBmb3IgYSBzbG90XG5cblx0Y29sRWxzOiBudWxsLCAvLyBjZWxscyBlbGVtZW50cyBpbiB0aGUgZGF5LXJvdyBiYWNrZ3JvdW5kXG5cdHNsYXRDb250YWluZXJFbDogbnVsbCwgLy8gZGl2IHRoYXQgd3JhcHMgYWxsIHRoZSBzbGF0IHJvd3Ncblx0c2xhdEVsczogbnVsbCwgLy8gZWxlbWVudHMgcnVubmluZyBob3Jpem9udGFsbHkgYWNyb3NzIGFsbCBjb2x1bW5zXG5cdG5vd0luZGljYXRvckVsczogbnVsbCxcblxuXHRjb2xDb29yZENhY2hlOiBudWxsLFxuXHRzbGF0Q29vcmRDYWNoZTogbnVsbCxcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRHcmlkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGwgdGhlIHN1cGVyLWNvbnN0cnVjdG9yXG5cblx0XHR0aGlzLnByb2Nlc3NPcHRpb25zKCk7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSB0aW1lIGdyaWQgaW50byBgdGhpcy5lbGAsIHdoaWNoIHNob3VsZCBhbHJlYWR5IGJlIGFzc2lnbmVkLlxuXHQvLyBSZWxpZXMgb24gdGhlIHZpZXcncyBjb2xDbnQuIEluIHRoZSBmdXR1cmUsIHRoaXMgY29tcG9uZW50IHNob3VsZCBwcm9iYWJseSBiZSBzZWxmLXN1ZmZpY2llbnQuXG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmh0bWwodGhpcy5yZW5kZXJIdG1sKCkpO1xuXHRcdHRoaXMuY29sRWxzID0gdGhpcy5lbC5maW5kKCcuZmMtZGF5Jyk7XG5cdFx0dGhpcy5zbGF0Q29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJy5mYy1zbGF0cycpO1xuXHRcdHRoaXMuc2xhdEVscyA9IHRoaXMuc2xhdENvbnRhaW5lckVsLmZpbmQoJ3RyJyk7XG5cblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZSh7XG5cdFx0XHRlbHM6IHRoaXMuY29sRWxzLFxuXHRcdFx0aXNIb3Jpem9udGFsOiB0cnVlXG5cdFx0fSk7XG5cdFx0dGhpcy5zbGF0Q29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlKHtcblx0XHRcdGVsczogdGhpcy5zbGF0RWxzLFxuXHRcdFx0aXNWZXJ0aWNhbDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGJhc2ljIEhUTUwgc2tlbGV0b24gZm9yIHRoZSBncmlkXG5cdHJlbmRlckh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJnXCI+JyArXG5cdFx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJCZ1RySHRtbCgwKSArIC8vIHJvdz0wXG5cdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1zbGF0c1wiPicgK1xuXHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyU2xhdFJvd0h0bWwoKSArXG5cdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2Pic7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cblx0cmVuZGVyU2xhdFJvd0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBpc1JUTCA9IHRoaXMuaXNSVEw7XG5cdFx0dmFyIGh0bWwgPSAnJztcblx0XHR2YXIgc2xvdFRpbWUgPSBtb21lbnQuZHVyYXRpb24oK3RoaXMubWluVGltZSk7IC8vIHdpc2ggdGhlcmUgd2FzIC5jbG9uZSgpIGZvciBkdXJhdGlvbnNcblx0XHR2YXIgc2xvdERhdGU7IC8vIHdpbGwgYmUgb24gdGhlIHZpZXcncyBmaXJzdCBkYXksIGJ1dCB3ZSBvbmx5IGNhcmUgYWJvdXQgaXRzIHRpbWVcblx0XHR2YXIgaXNMYWJlbGVkO1xuXHRcdHZhciBheGlzSHRtbDtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgdGltZSBmb3IgZWFjaCBzbG90XG5cdFx0d2hpbGUgKHNsb3RUaW1lIDwgdGhpcy5tYXhUaW1lKSB7XG5cdFx0XHRzbG90RGF0ZSA9IHRoaXMuc3RhcnQuY2xvbmUoKS50aW1lKHNsb3RUaW1lKTtcblx0XHRcdGlzTGFiZWxlZCA9IGlzSW50KGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihzbG90VGltZSwgdGhpcy5sYWJlbEludGVydmFsKSk7XG5cblx0XHRcdGF4aXNIdG1sID1cblx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWF4aXMgZmMtdGltZSAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0XHQoaXNMYWJlbGVkID9cblx0XHRcdFx0XHRcdCc8c3Bhbj4nICsgLy8gZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0XHRodG1sRXNjYXBlKHNsb3REYXRlLmZvcm1hdCh0aGlzLmxhYmVsRm9ybWF0KSkgK1xuXHRcdFx0XHRcdFx0Jzwvc3Bhbj4nIDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0JzwvdGQ+JztcblxuXHRcdFx0aHRtbCArPVxuXHRcdFx0XHQnPHRyIGRhdGEtdGltZT1cIicgKyBzbG90RGF0ZS5mb3JtYXQoJ0hIOm1tOnNzJykgKyAnXCInICtcblx0XHRcdFx0XHQoaXNMYWJlbGVkID8gJycgOiAnIGNsYXNzPVwiZmMtbWlub3JcIicpICtcblx0XHRcdFx0XHQnPicgK1xuXHRcdFx0XHRcdCghaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXG5cdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cIicgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIi8+JyArXG5cdFx0XHRcdFx0KGlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xuXHRcdFx0XHRcIjwvdHI+XCI7XG5cblx0XHRcdHNsb3RUaW1lLmFkZCh0aGlzLnNsb3REdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblxuXHQvKiBPcHRpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBQYXJzZXMgdmFyaW91cyBvcHRpb25zIGludG8gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdFxuXHRwcm9jZXNzT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHNsb3REdXJhdGlvbiA9IHZpZXcub3B0KCdzbG90RHVyYXRpb24nKTtcblx0XHR2YXIgc25hcER1cmF0aW9uID0gdmlldy5vcHQoJ3NuYXBEdXJhdGlvbicpO1xuXHRcdHZhciBpbnB1dDtcblxuXHRcdHNsb3REdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihzbG90RHVyYXRpb24pO1xuXHRcdHNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbiA/IG1vbWVudC5kdXJhdGlvbihzbmFwRHVyYXRpb24pIDogc2xvdER1cmF0aW9uO1xuXG5cdFx0dGhpcy5zbG90RHVyYXRpb24gPSBzbG90RHVyYXRpb247XG5cdFx0dGhpcy5zbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb247XG5cdFx0dGhpcy5zbmFwc1BlclNsb3QgPSBzbG90RHVyYXRpb24gLyBzbmFwRHVyYXRpb247IC8vIFRPRE86IGVuc3VyZSBhbiBpbnRlZ2VyIG11bHRpcGxlP1xuXG5cdFx0dGhpcy5taW5SZXNpemVEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjsgLy8gaGFja1xuXG5cdFx0dGhpcy5taW5UaW1lID0gbW9tZW50LmR1cmF0aW9uKHZpZXcub3B0KCdtaW5UaW1lJykpO1xuXHRcdHRoaXMubWF4VGltZSA9IG1vbWVudC5kdXJhdGlvbih2aWV3Lm9wdCgnbWF4VGltZScpKTtcblxuXHRcdC8vIG1pZ2h0IGJlIGFuIGFycmF5IHZhbHVlIChmb3IgVGltZWxpbmVWaWV3KS5cblx0XHQvLyBpZiBzbywgZ2V0dGluZyB0aGUgbW9zdCBncmFudWxhciBlbnRyeSAodGhlIGxhc3Qgb25lIHByb2JhYmx5KS5cblx0XHRpbnB1dCA9IHZpZXcub3B0KCdzbG90TGFiZWxGb3JtYXQnKTtcblx0XHRpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dFtpbnB1dC5sZW5ndGggLSAxXTtcblx0XHR9XG5cblx0XHR0aGlzLmxhYmVsRm9ybWF0ID1cblx0XHRcdGlucHV0IHx8XG5cdFx0XHR2aWV3Lm9wdCgnYXhpc0Zvcm1hdCcpIHx8IC8vIGRlcHJlY2F0ZWRcblx0XHRcdHZpZXcub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTsgLy8gdGhlIGNvbXB1dGVkIGRlZmF1bHRcblxuXHRcdGlucHV0ID0gdmlldy5vcHQoJ3Nsb3RMYWJlbEludGVydmFsJyk7XG5cdFx0dGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xuXHRcdFx0bW9tZW50LmR1cmF0aW9uKGlucHV0KSA6XG5cdFx0XHR0aGlzLmNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhbiBhdXRvbWF0aWMgdmFsdWUgZm9yIHNsb3RMYWJlbEludGVydmFsXG5cdGNvbXB1dGVMYWJlbEludGVydmFsOiBmdW5jdGlvbihzbG90RHVyYXRpb24pIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgbGFiZWxJbnRlcnZhbDtcblx0XHR2YXIgc2xvdHNQZXJMYWJlbDtcblxuXHRcdC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuXHRcdGZvciAoaSA9IEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsYWJlbEludGVydmFsID0gbW9tZW50LmR1cmF0aW9uKEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcblx0XHRcdHNsb3RzUGVyTGFiZWwgPSBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24obGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcblx0XHRcdGlmIChpc0ludChzbG90c1BlckxhYmVsKSAmJiBzbG90c1BlckxhYmVsID4gMSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxJbnRlcnZhbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7IC8vIGZhbGwgYmFjay4gY2xvbmVcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGB0aW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5cdGNvbXB1dGVFdmVudFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdub01lcmlkaWVtVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNjozMFwiIChubyBBTS9QTSlcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBgZGlzcGxheUV2ZW50RW5kYCB2YWx1ZSBpZiBvbmUgaXMgbm90IGV4cGxpY2x0eSBkZWZpbmVkXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0LyogSGl0IFN5c3RlbVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcblx0XHQvLyBOT1RFOiBkb24ndCBjbGVhciBzbGF0Q29vcmRDYWNoZSBiZWNhdXNlIHdlIHJlbHkgb24gaXQgZm9yIGNvbXB1dGVUaW1lVG9wXG5cdH0sXG5cblxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdFx0dmFyIHNuYXBzUGVyU2xvdCA9IHRoaXMuc25hcHNQZXJTbG90O1xuXHRcdHZhciBjb2xDb29yZENhY2hlID0gdGhpcy5jb2xDb29yZENhY2hlO1xuXHRcdHZhciBzbGF0Q29vcmRDYWNoZSA9IHRoaXMuc2xhdENvb3JkQ2FjaGU7XG5cdFx0dmFyIGNvbEluZGV4ID0gY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XG5cdFx0dmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZENhY2hlLmdldFZlcnRpY2FsSW5kZXgodG9wT2Zmc2V0KTtcblxuXHRcdGlmIChjb2xJbmRleCAhPSBudWxsICYmIHNsYXRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgc2xhdFRvcCA9IHNsYXRDb29yZENhY2hlLmdldFRvcE9mZnNldChzbGF0SW5kZXgpO1xuXHRcdFx0dmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KTtcblx0XHRcdHZhciBwYXJ0aWFsID0gKHRvcE9mZnNldCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuXHRcdFx0dmFyIGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XG5cdFx0XHR2YXIgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XG5cdFx0XHR2YXIgc25hcFRvcCA9IHNsYXRUb3AgKyAobG9jYWxTbmFwSW5kZXggLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcblx0XHRcdHZhciBzbmFwQm90dG9tID0gc2xhdFRvcCArICgobG9jYWxTbmFwSW5kZXggKyAxKSAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjb2w6IGNvbEluZGV4LFxuXHRcdFx0XHRzbmFwOiBzbmFwSW5kZXgsXG5cdFx0XHRcdGNvbXBvbmVudDogdGhpcywgLy8gbmVlZGVkIHVuZm9ydHVuYXRlbHkgOihcblx0XHRcdFx0bGVmdDogY29sQ29vcmRDYWNoZS5nZXRMZWZ0T2Zmc2V0KGNvbEluZGV4KSxcblx0XHRcdFx0cmlnaHQ6IGNvbENvb3JkQ2FjaGUuZ2V0UmlnaHRPZmZzZXQoY29sSW5kZXgpLFxuXHRcdFx0XHR0b3A6IHNuYXBUb3AsXG5cdFx0XHRcdGJvdHRvbTogc25hcEJvdHRvbVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKDAsIGhpdC5jb2wpOyAvLyByb3c9MFxuXHRcdHZhciB0aW1lID0gdGhpcy5jb21wdXRlU25hcFRpbWUoaGl0LnNuYXApOyAvLyBwYXNzIGluIHRoZSBzbmFwLWluZGV4XG5cdFx0dmFyIGVuZDtcblxuXHRcdHN0YXJ0LnRpbWUodGltZSk7XG5cdFx0ZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5zbmFwRHVyYXRpb24pO1xuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXHR9LFxuXG5cblx0Z2V0SGl0RWw6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHJldHVybiB0aGlzLmNvbEVscy5lcShoaXQuY29sKTtcblx0fSxcblxuXG5cdC8qIERhdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyYW5nZVVwZGF0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlRGF5VGFibGUoKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgcm93IG51bWJlciBvZiB0aGUgZ3JpZCwgcmVwcmVzZW50aW5nIGEgXCJzbmFwXCIsIHJldHVybnMgYSB0aW1lIChEdXJhdGlvbikgZnJvbSBpdHMgc3RhcnQtb2YtZGF5XG5cdGNvbXB1dGVTbmFwVGltZTogZnVuY3Rpb24oc25hcEluZGV4KSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih0aGlzLm1pblRpbWUgKyB0aGlzLnNuYXBEdXJhdGlvbiAqIHNuYXBJbmRleCk7XG5cdH0sXG5cblxuXHQvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG5cdHNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5VGltZXMoc3Bhbik7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdFx0c2Vnc1tpXS5jb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2Vnc1tpXS5kYXlJbmRleDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZWdzW2ldLmNvbCA9IHNlZ3NbaV0uZGF5SW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHRzbGljZVJhbmdlQnlUaW1lczogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgc2VncyA9IFtdO1xuXHRcdHZhciBzZWc7XG5cdFx0dmFyIGRheUluZGV4O1xuXHRcdHZhciBkYXlEYXRlO1xuXHRcdHZhciBkYXlSYW5nZTtcblxuXHRcdGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHRoaXMuZGF5c1BlclJvdzsgZGF5SW5kZXgrKykge1xuXHRcdFx0ZGF5RGF0ZSA9IHRoaXMuZGF5RGF0ZXNbZGF5SW5kZXhdLmNsb25lKCk7IC8vIFRPRE86IGJldHRlciBBUEkgZm9yIHRoaXM/XG5cdFx0XHRkYXlSYW5nZSA9IHtcblx0XHRcdFx0c3RhcnQ6IGRheURhdGUuY2xvbmUoKS50aW1lKHRoaXMubWluVGltZSksXG5cdFx0XHRcdGVuZDogZGF5RGF0ZS5jbG9uZSgpLnRpbWUodGhpcy5tYXhUaW1lKVxuXHRcdFx0fTtcblx0XHRcdHNlZyA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2UpOyAvLyBib3RoIHdpbGwgYmUgYW1iaWcgdGltZXpvbmVcblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0c2VnLmRheUluZGV4ID0gZGF5SW5kZXg7XG5cdFx0XHRcdHNlZ3MucHVzaChzZWcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0LyogQ29vcmRpbmF0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGlzUmVzaXplKSB7IC8vIE5PVCBhIHN0YW5kYXJkIEdyaWQgbWV0aG9kXG5cdFx0dGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xuXG5cdFx0aWYgKGlzUmVzaXplKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2Fscyhcblx0XHRcdFx0W10uY29uY2F0KHRoaXMuZmdTZWdzIHx8IFtdLCB0aGlzLmJnU2VncyB8fCBbXSwgdGhpcy5idXNpbmVzc1NlZ3MgfHwgW10pXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXG5cdGdldFRvdGFsU2xhdEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2xhdENvbnRhaW5lckVsLm91dGVySGVpZ2h0KCk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxuXHQvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxuXHRjb21wdXRlRGF0ZVRvcDogZnVuY3Rpb24oZGF0ZSwgc3RhcnRPZkRheURhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChcblx0XHRcdG1vbWVudC5kdXJhdGlvbihcblx0XHRcdFx0ZGF0ZSAtIHN0YXJ0T2ZEYXlEYXRlLmNsb25lKCkuc3RyaXBUaW1lKClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXG5cdGNvbXB1dGVUaW1lVG9wOiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMuc2xhdEVscy5sZW5ndGg7XG5cdFx0dmFyIHNsYXRDb3ZlcmFnZSA9ICh0aW1lIC0gdGhpcy5taW5UaW1lKSAvIHRoaXMuc2xvdER1cmF0aW9uOyAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcblx0XHR2YXIgc2xhdEluZGV4O1xuXHRcdHZhciBzbGF0UmVtYWluZGVyO1xuXG5cdFx0Ly8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cblx0XHQvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG5cdFx0Ly8gY29uc3RyYWluZWQgYmVjYXVzZSBtaW5UaW1lL21heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cblx0XHRzbGF0Q292ZXJhZ2UgPSBNYXRoLm1heCgwLCBzbGF0Q292ZXJhZ2UpO1xuXHRcdHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcblxuXHRcdC8vIGFuIGludGVnZXIgaW5kZXggb2YgdGhlIGZ1cnRoZXN0IHdob2xlIHNsYXRcblx0XHQvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXG5cdFx0c2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuXHRcdHNsYXRJbmRleCA9IE1hdGgubWluKHNsYXRJbmRleCwgbGVuIC0gMSk7XG5cblx0XHQvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cblx0XHQvLyBjb3VsZCBiZSAxLjAgaWYgc2xhdENvdmVyYWdlIGlzIGNvdmVyaW5nICphbGwqIHRoZSBzbG90c1xuXHRcdHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XG5cblx0XHRyZXR1cm4gdGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRUb3BQb3NpdGlvbihzbGF0SW5kZXgpICtcblx0XHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0SGVpZ2h0KHNsYXRJbmRleCkgKiBzbGF0UmVtYWluZGVyO1xuXHR9LFxuXG5cblxuXHQvKiBFdmVudCBEcmFnIFZpc3VhbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyBkcmFnZ2VkIG92ZXIgdGhlIHNwZWNpZmllZCBkYXRlKHMpLlxuXHQvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNlZykge1xuXG5cdFx0aWYgKHNlZykgeyAvLyBpZiB0aGVyZSBpcyBldmVudCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBkcmFnLCByZW5kZXIgYSBoZWxwZXIgZXZlbnRcblxuXHRcdFx0Ly8gcmV0dXJucyBtb2NrIGV2ZW50IGVsZW1lbnRzXG5cdFx0XHQvLyBzaWduYWwgdGhhdCBhIGhlbHBlciBoYXMgYmVlbiByZW5kZXJlZFxuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyRXZlbnRMb2NhdGlvbkhlbHBlcihldmVudExvY2F0aW9uLCBzZWcpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIG90aGVyd2lzZSwganVzdCByZW5kZXIgYSBoaWdobGlnaHRcblx0XHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHRoaXMuZXZlbnRUb1NwYW4oZXZlbnRMb2NhdGlvbikpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZFxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0cmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNlZykge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXIoZXZlbnRMb2NhdGlvbiwgc2VnKTsgLy8gcmV0dXJucyBtb2NrIGV2ZW50IGVsZW1lbnRzXG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0dW5yZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlcigpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgSGVscGVyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgb3JpZ2luYWwgc2VnbWVudCBvYmplY3QgYW5kIG1pZ2h0IGJlIG51bGwgKGFuIGV4dGVybmFsIGRyYWcpXG5cdHJlbmRlckhlbHBlcjogZnVuY3Rpb24oZXZlbnQsIHNvdXJjZVNlZykge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckhlbHBlclNlZ3ModGhpcy5ldmVudFRvU2VncyhldmVudCksIHNvdXJjZVNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSBtb2NrIGhlbHBlciBldmVudFxuXHR1bnJlbmRlckhlbHBlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlclNlZ3MoKTtcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRzID0gdGhpcy52aWV3LmNhbGVuZGFyLmdldEJ1c2luZXNzSG91cnNFdmVudHMoKTtcblx0XHR2YXIgc2VncyA9IHRoaXMuZXZlbnRzVG9TZWdzKGV2ZW50cyk7XG5cblx0XHR0aGlzLnJlbmRlckJ1c2luZXNzU2VncyhzZWdzKTtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckJ1c2luZXNzU2VncygpO1xuXHR9LFxuXG5cblx0LyogTm93IEluZGljYXRvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Z2V0Tm93SW5kaWNhdG9yVW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdtaW51dGUnOyAvLyB3aWxsIHJlZnJlc2ggb24gdGhlIG1pbnV0ZVxuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0Ly8gc2VnIHN5c3RlbSBtaWdodCBiZSBvdmVya2lsbCwgYnV0IGl0IGhhbmRsZXMgc2NlbmFyaW8gd2hlcmUgbGluZSBuZWVkcyB0byBiZSByZW5kZXJlZFxuXHRcdC8vICBtb3JlIHRoYW4gb25jZSBiZWNhdXNlIG9mIGNvbHVtbnMgd2l0aCB0aGUgc2FtZSBkYXRlIChyZXNvdXJjZXMgY29sdW1ucyBmb3IgZXhhbXBsZSlcblx0XHR2YXIgc2VncyA9IHRoaXMuc3BhblRvU2Vncyh7IHN0YXJ0OiBkYXRlLCBlbmQ6IGRhdGUgfSk7XG5cdFx0dmFyIHRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3AoZGF0ZSwgZGF0ZSk7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHQvLyByZW5kZXIgbGluZXMgd2l0aGluIHRoZSBjb2x1bW5zXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lXCI+PC9kaXY+Jylcblx0XHRcdFx0LmNzcygndG9wJywgdG9wKVxuXHRcdFx0XHQuYXBwZW5kVG8odGhpcy5jb2xDb250YWluZXJFbHMuZXEoc2Vnc1tpXS5jb2wpKVswXSk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcblx0XHRpZiAoc2Vncy5sZW5ndGggPiAwKSB7IC8vIGlzIHRoZSBjdXJyZW50IHRpbWUgaW4gdmlldz9cblx0XHRcdG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1hcnJvd1wiPjwvZGl2PicpXG5cdFx0XHRcdC5jc3MoJ3RvcCcsIHRvcClcblx0XHRcdFx0LmFwcGVuZFRvKHRoaXMuZWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24nKSlbMF0pO1xuXHRcdH1cblxuXHRcdHRoaXMubm93SW5kaWNhdG9yRWxzID0gJChub2Rlcyk7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMubm93SW5kaWNhdG9yRWxzKSB7XG5cdFx0XHR0aGlzLm5vd0luZGljYXRvckVscy5yZW1vdmUoKTtcblx0XHRcdHRoaXMubm93SW5kaWNhdG9yRWxzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0LCB3aGljaCB3YXMgdG8gc2ltcGx5IHJlbmRlciBhIGhpZ2hsaWdodC5cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0aWYgKHRoaXMudmlldy5vcHQoJ3NlbGVjdEhlbHBlcicpKSB7IC8vIHRoaXMgc2V0dGluZyBzaWduYWxzIHRoYXQgYSBtb2NrIGhlbHBlciBldmVudCBzaG91bGQgYmUgcmVuZGVyZWRcblxuXHRcdFx0Ly8gbm9ybWFsbHkgYWNjZXBzIGFuIGV2ZW50TG9jYXRpb24sIHNwYW4gaGFzIGEgc3RhcnQvZW5kLCB3aGljaCBpcyBnb29kIGVub3VnaFxuXHRcdFx0dGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKHNwYW4pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHNwYW4pO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvKiBIaWdobGlnaHRcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0U2Vncyh0aGlzLnNwYW5Ub1NlZ3Moc3BhbikpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHRTZWdzKCk7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIE1ldGhvZHMgZm9yIHJlbmRlcmluZyBTRUdNRU5UUywgcGllY2VzIG9mIGNvbnRlbnQgdGhhdCBsaXZlIG9uIHRoZSB2aWV3XG4gKCB0aGlzIGZpbGUgaXMgbm8gbG9uZ2VyIGp1c3QgZm9yIGV2ZW50cyApXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuVGltZUdyaWQubWl4aW4oe1xuXG5cdGNvbENvbnRhaW5lckVsczogbnVsbCwgLy8gY29udGFpbmVycyBmb3IgZWFjaCBjb2x1bW5cblxuXHQvLyBpbm5lci1jb250YWluZXJzIGZvciBlYWNoIGNvbHVtbiB3aGVyZSBkaWZmZXJlbnQgdHlwZXMgb2Ygc2VncyBsaXZlXG5cdGZnQ29udGFpbmVyRWxzOiBudWxsLFxuXHRiZ0NvbnRhaW5lckVsczogbnVsbCxcblx0aGVscGVyQ29udGFpbmVyRWxzOiBudWxsLFxuXHRoaWdobGlnaHRDb250YWluZXJFbHM6IG51bGwsXG5cdGJ1c2luZXNzQ29udGFpbmVyRWxzOiBudWxsLFxuXG5cdC8vIGFycmF5cyBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgZGlzcGxheWVkIHNlZ21lbnRzXG5cdGZnU2VnczogbnVsbCxcblx0YmdTZWdzOiBudWxsLFxuXHRoZWxwZXJTZWdzOiBudWxsLFxuXHRoaWdobGlnaHRTZWdzOiBudWxsLFxuXHRidXNpbmVzc1NlZ3M6IG51bGwsXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBET00gdGhhdCB0aGUgdmlldydzIGNvbnRlbnQgd2lsbCBsaXZlIGluXG5cdHJlbmRlckNvbnRlbnRTa2VsZXRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbGxIdG1sID0gJyc7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNrZWxldG9uRWw7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xuXHRcdFx0Y2VsbEh0bWwgKz1cblx0XHRcdFx0Jzx0ZD4nICtcblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtY29sXCI+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lciBmYy1oZWxwZXItY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1oaWdobGlnaHQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJnZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJ1c2luZXNzLWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzwvdGQ+Jztcblx0XHR9XG5cblx0XHRza2VsZXRvbkVsID0gJChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xuXHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArIGNlbGxIdG1sICsgJzwvdHI+JyArXG5cdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXG5cdFx0dGhpcy5jb2xDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1jb250ZW50LWNvbCcpO1xuXHRcdHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGVscGVyLWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuZmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1oZWxwZXItY29udGFpbmVyKScpO1xuXHRcdHRoaXMuYmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcblxuXHRcdHRoaXMuYm9va2VuZENlbGxzKHNrZWxldG9uRWwuZmluZCgndHInKSk7IC8vIFRPRE86IGRvIHRoaXMgb24gc3RyaW5nIGxldmVsXG5cdFx0dGhpcy5lbC5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdH0sXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyRmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMoc2VncywgdGhpcy5mZ0NvbnRhaW5lckVscyk7XG5cdFx0dGhpcy5mZ1NlZ3MgPSBzZWdzO1xuXHRcdHJldHVybiBzZWdzOyAvLyBuZWVkZWQgZm9yIEdyaWQ6OnJlbmRlckV2ZW50c1xuXHR9LFxuXG5cblx0dW5yZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2ZnU2VncycpO1xuXHR9LFxuXG5cblx0LyogRm9yZWdyb3VuZCBIZWxwZXIgRXZlbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJIZWxwZXJTZWdzOiBmdW5jdGlvbihzZWdzLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgaGVscGVyRWxzID0gW107XG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgc291cmNlRWw7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLmhlbHBlckNvbnRhaW5lckVscyk7XG5cblx0XHQvLyBUcnkgdG8gbWFrZSB0aGUgc2VnbWVudCB0aGF0IGlzIGluIHRoZSBzYW1lIHJvdyBhcyBzb3VyY2VTZWcgbG9vayB0aGUgc2FtZVxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcuY29sID09PSBzZWcuY29sKSB7XG5cdFx0XHRcdHNvdXJjZUVsID0gc291cmNlU2VnLmVsO1xuXHRcdFx0XHRzZWcuZWwuY3NzKHtcblx0XHRcdFx0XHRsZWZ0OiBzb3VyY2VFbC5jc3MoJ2xlZnQnKSxcblx0XHRcdFx0XHRyaWdodDogc291cmNlRWwuY3NzKCdyaWdodCcpLFxuXHRcdFx0XHRcdCdtYXJnaW4tbGVmdCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLWxlZnQnKSxcblx0XHRcdFx0XHQnbWFyZ2luLXJpZ2h0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tcmlnaHQnKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGhlbHBlckVscy5wdXNoKHNlZy5lbFswXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXJTZWdzID0gc2VncztcblxuXHRcdHJldHVybiAkKGhlbHBlckVscyk7IC8vIG11c3QgcmV0dXJuIHJlbmRlcmVkIGhlbHBlcnNcblx0fSxcblxuXG5cdHVucmVuZGVySGVscGVyU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnaGVscGVyU2VncycpO1xuXHR9LFxuXG5cblx0LyogQmFja2dyb3VuZCBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZpbGxTZWdFbHMoJ2JnRXZlbnQnLCBzZWdzKTsgLy8gVE9ETzogb2xkIGZpbGwgc3lzdGVtXG5cdFx0dGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2wodGhpcy5ncm91cFNlZ3NCeUNvbChzZWdzKSwgdGhpcy5iZ0NvbnRhaW5lckVscyk7XG5cdFx0dGhpcy5iZ1NlZ3MgPSBzZWdzO1xuXHRcdHJldHVybiBzZWdzOyAvLyBuZWVkZWQgZm9yIEdyaWQ6OnJlbmRlckV2ZW50c1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2JnU2VncycpO1xuXHR9LFxuXG5cblx0LyogSGlnaGxpZ2h0XG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJIaWdobGlnaHRTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnaGlnaGxpZ2h0Jywgc2Vncyk7IC8vIFRPRE86IG9sZCBmaWxsIHN5c3RlbVxuXHRcdHRoaXMudXBkYXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXR0YWNoU2Vnc0J5Q29sKHRoaXMuZ3JvdXBTZWdzQnlDb2woc2VncyksIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmhpZ2hsaWdodFNlZ3MgPSBzZWdzO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIaWdobGlnaHRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyTmFtZWRTZWdzKCdoaWdobGlnaHRTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnYnVzaW5lc3NIb3VycycsIHNlZ3MpOyAvLyBUT0RPOiBvbGQgZmlsbCBzeXN0ZW1cblx0XHR0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcblx0XHR0aGlzLmF0dGFjaFNlZ3NCeUNvbCh0aGlzLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmJ1c2luZXNzU2VncyA9IHNlZ3M7XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnYnVzaW5lc3NTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBTZWcgUmVuZGVyaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIGNvbFxuXHRncm91cFNlZ3NCeUNvbDogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBzZWdzQnlDb2wgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XG5cdFx0XHRzZWdzQnlDb2wucHVzaChbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vnc0J5Q29sO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gc2VnbWVudHMgZ3JvdXBlZCBieSBjb2x1bW4sIGluc2VydCB0aGUgc2VnbWVudHMnIGVsZW1lbnRzIGludG8gYSBwYXJhbGxlbCBhcnJheSBvZiBjb250YWluZXJcblx0Ly8gZWxlbWVudHMsIGVhY2ggbGl2aW5nIHdpdGhpbiBhIGNvbHVtbi5cblx0YXR0YWNoU2Vnc0J5Q29sOiBmdW5jdGlvbihzZWdzQnlDb2wsIGNvbnRhaW5lckVscykge1xuXHRcdHZhciBjb2w7XG5cdFx0dmFyIHNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykgeyAvLyBpdGVyYXRlIGVhY2ggY29sdW1uIGdyb3VwaW5nXG5cdFx0XHRzZWdzID0gc2Vnc0J5Q29sW2NvbF07XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnRhaW5lckVscy5lcShjb2wpLmFwcGVuZChzZWdzW2ldLmVsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgbmFtZSBvZiBhIHByb3BlcnR5IG9mIGB0aGlzYCBvYmplY3QsIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkgb2Ygc2VnbWVudHMsXG5cdC8vIGxvb3BzIHRocm91Z2ggZWFjaCBzZWdtZW50IGFuZCByZW1vdmVzIGZyb20gRE9NLiBXaWxsIG51bGwtb3V0IHRoZSBwcm9wZXJ0eSBhZnRlcndhcmRzLlxuXHR1bnJlbmRlck5hbWVkU2VnczogZnVuY3Rpb24ocHJvcE5hbWUpIHtcblx0XHR2YXIgc2VncyA9IHRoaXNbcHJvcE5hbWVdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNlZ3NbaV0uZWwucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50IFJlbmRlcmluZyBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2l2ZW4gYW4gYXJyYXkgb2YgZm9yZWdyb3VuZCBzZWdtZW50cywgcmVuZGVyIGEgRE9NIGVsZW1lbnQgZm9yIGVhY2gsIGNvbXB1dGVzIHBvc2l0aW9uLFxuXHQvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXG5cdHJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzOiBmdW5jdGlvbihzZWdzLCBjb250YWluZXJFbHMpIHtcblx0XHR2YXIgc2Vnc0J5Q29sO1xuXHRcdHZhciBjb2w7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTsgLy8gd2lsbCBjYWxsIGZnU2VnSHRtbFxuXHRcdHNlZ3NCeUNvbCA9IHRoaXMuZ3JvdXBTZWdzQnlDb2woc2Vncyk7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xuXHRcdFx0dGhpcy51cGRhdGVGZ1NlZ0Nvb3JkcyhzZWdzQnlDb2xbY29sXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2woc2Vnc0J5Q29sLCBjb250YWluZXJFbHMpO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCBzZWdtZW50J3MgZGVmYXVsdCByZW5kZXJpbmdcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREcmFnZ2FibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzU3RhcnQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0KGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNFbmQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbUVuZChldmVudCk7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kKTtcblx0XHR2YXIgc2tpbkNzcyA9IGNzc1RvU3RyKHRoaXMuZ2V0U2VnU2tpbkNzcyhzZWcpKTtcblx0XHR2YXIgdGltZVRleHQ7XG5cdFx0dmFyIGZ1bGxUaW1lVGV4dDsgLy8gbW9yZSB2ZXJib3NlIHRpbWUgdGV4dC4gZm9yIHRoZSBwcmludCBzdHlsZXNoZWV0XG5cdFx0dmFyIHN0YXJ0VGltZVRleHQ7IC8vIGp1c3QgdGhlIHN0YXJ0IHRpbWUgdGV4dFxuXG5cdFx0Y2xhc3Nlcy51bnNoaWZ0KCdmYy10aW1lLWdyaWQtZXZlbnQnLCAnZmMtdi1ldmVudCcpO1xuXG5cdFx0aWYgKHZpZXcuaXNNdWx0aURheUV2ZW50KGV2ZW50KSkgeyAvLyBpZiB0aGUgZXZlbnQgYXBwZWFycyB0byBzcGFuIG1vcmUgdGhhbiBvbmUgZGF5Li4uXG5cdFx0XHQvLyBEb24ndCBkaXNwbGF5IHRpbWUgdGV4dCBvbiBzZWdtZW50cyB0aGF0IHJ1biBlbnRpcmVseSB0aHJvdWdoIGEgZGF5LlxuXHRcdFx0Ly8gVGhhdCB3b3VsZCBhcHBlYXIgYXMgbWlkbmlnaHQtbWlkbmlnaHQgYW5kIHdvdWxkIGxvb2sgZHVtYi5cblx0XHRcdC8vIE90aGVyd2lzZSwgZGlzcGxheSB0aGUgdGltZSB0ZXh0IGZvciB0aGUgKnNlZ21lbnQncyogdGltZXMgKGxpa2UgNnBtLW1pZG5pZ2h0IG9yIG1pZG5pZ2h0LTEwYW0pXG5cdFx0XHRpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XG5cdFx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZyk7XG5cdFx0XHRcdGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChzZWcsICdMVCcpO1xuXHRcdFx0XHRzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZywgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcblx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50KTtcblx0XHRcdGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChldmVudCwgJ0xUJyk7XG5cdFx0XHRzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50LCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2Vcblx0XHR9XG5cblx0XHRyZXR1cm4gJzxhIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG5cdFx0XHQoZXZlbnQudXJsID9cblx0XHRcdFx0JyBocmVmPVwiJyArIGh0bWxFc2NhcGUoZXZlbnQudXJsKSArICdcIicgOlxuXHRcdFx0XHQnJ1xuXHRcdFx0XHQpICtcblx0XHRcdChza2luQ3NzID9cblx0XHRcdFx0JyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XG5cdFx0XHRcdCcnXG5cdFx0XHRcdCkgK1xuXHRcdFx0Jz4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1jb250ZW50XCI+JyArXG5cdFx0XHRcdFx0KHRpbWVUZXh0ID9cblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtdGltZVwiJyArXG5cdFx0XHRcdFx0XHQnIGRhdGEtc3RhcnQ9XCInICsgaHRtbEVzY2FwZShzdGFydFRpbWVUZXh0KSArICdcIicgK1xuXHRcdFx0XHRcdFx0JyBkYXRhLWZ1bGw9XCInICsgaHRtbEVzY2FwZShmdWxsVGltZVRleHQpICsgJ1wiJyArXG5cdFx0XHRcdFx0XHQnPicgK1xuXHRcdFx0XHRcdFx0XHQnPHNwYW4+JyArIGh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdCc8L2Rpdj4nIDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHQoZXZlbnQudGl0bGUgP1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy10aXRsZVwiPicgK1xuXHRcdFx0XHRcdFx0XHRodG1sRXNjYXBlKGV2ZW50LnRpdGxlKSArXG5cdFx0XHRcdFx0XHQnPC9kaXY+JyA6XG5cdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1iZ1wiLz4nICtcblx0XHRcdFx0LyogVE9ETzogd3JpdGUgQ1NTIGZvciB0aGlzXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21TdGFydCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdCovXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21FbmQgP1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdCc8L2E+Jztcblx0fSxcblxuXG5cdC8qIFNlZyBQb3NpdGlvbiBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBDU1MgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBmb3IgZWFjaCBzZWdtZW50IGVsZW1lbnQuXG5cdC8vIFdvcmtzIHdoZW4gY2FsbGVkIGFmdGVyIGluaXRpYWwgcmVuZGVyLCBhZnRlciBhIHdpbmRvdyByZXNpemUvem9vbSBmb3IgZXhhbXBsZS5cblx0dXBkYXRlU2VnVmVydGljYWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gRm9yIGVhY2ggc2VnbWVudCBpbiBhbiBhcnJheSwgY29tcHV0ZXMgYW5kIGFzc2lnbnMgaXRzIHRvcCBhbmQgYm90dG9tIHByb3BlcnRpZXNcblx0Y29tcHV0ZVNlZ1ZlcnRpY2FsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdHNlZy50b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgc2VnLnN0YXJ0KTtcblx0XHRcdHNlZy5ib3R0b20gPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIHNlZy5zdGFydCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhbHJlYWR5IGhhdmUgdGhlaXIgdG9wL2JvdHRvbSBwcm9wZXJ0aWVzIGNvbXB1dGVkLCBhcHBsaWVzIHRob3NlIHZhbHVlcyB0b1xuXHQvLyB0aGUgc2VnbWVudHMnIGVsZW1lbnRzLlxuXHRhc3NpZ25TZWdWZXJ0aWNhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMgZm9yIHRoZSB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIG9mIGEgc2VnbWVudCBlbGVtZW50XG5cdGdlbmVyYXRlU2VnVmVydGljYWxDc3M6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHNlZy50b3AsXG5cdFx0XHRib3R0b206IC1zZWcuYm90dG9tIC8vIGZsaXBwZWQgYmVjYXVzZSBuZWVkcyB0byBiZSBzcGFjZSBiZXlvbmQgYm90dG9tIGVkZ2Ugb2YgZXZlbnQgY29udGFpbmVyXG5cdFx0fTtcblx0fSxcblxuXG5cdC8qIEZvcmVncm91bmQgRXZlbnQgUG9zaXRpb25pbmcgVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdpdmVuIHNlZ21lbnRzIHRoYXQgYXJlIGFzc3VtZWQgdG8gYWxsIGxpdmUgaW4gdGhlICpzYW1lIGNvbHVtbiosXG5cdC8vIGNvbXB1dGUgdGhlaXIgdmVyaWNhbC9ob3Jpem9udGFsIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdG8gdGhlaXIgZWxlbWVudHMuXG5cdHVwZGF0ZUZnU2VnQ29vcmRzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpOyAvLyBob3Jpem9udGFscyByZWxpZXMgb24gdGhpc1xuXHRcdHRoaXMuY29tcHV0ZUZnU2VnSG9yaXpvbnRhbHMoc2Vncyk7IC8vIGNvbXB1dGUgaG9yaXpvbnRhbCBjb29yZGluYXRlcywgei1pbmRleCdzLCBhbmQgcmVvcmRlciB0aGUgYXJyYXlcblx0XHR0aGlzLmFzc2lnblNlZ1ZlcnRpY2FscyhzZWdzKTtcblx0XHR0aGlzLmFzc2lnbkZnU2VnSG9yaXpvbnRhbHMoc2Vncyk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGFyZSBhbGwgaW4gdGhlIHNhbWUgY29sdW1uLCBzZXRzIHRoZSBiYWNrd2FyZENvb3JkIGFuZCBmb3J3YXJkQ29vcmQgb24gZWFjaC5cblx0Ly8gTk9URTogQWxzbyByZW9yZGVycyB0aGUgZ2l2ZW4gYXJyYXkgYnkgZGF0ZSFcblx0Y29tcHV0ZUZnU2VnSG9yaXpvbnRhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgbGV2ZWxzO1xuXHRcdHZhciBsZXZlbDA7XG5cdFx0dmFyIGk7XG5cblx0XHR0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7IC8vIG9yZGVyIGJ5IGNlcnRhaW4gY3JpdGVyaWFcblx0XHRsZXZlbHMgPSBidWlsZFNsb3RTZWdMZXZlbHMoc2Vncyk7XG5cdFx0Y29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpO1xuXG5cdFx0aWYgKChsZXZlbDAgPSBsZXZlbHNbMF0pKSB7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZXZlbDAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMobGV2ZWwwW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsY3VsYXRlIHNlZy5mb3J3YXJkQ29vcmQgYW5kIHNlZy5iYWNrd2FyZENvb3JkIGZvciB0aGUgc2VnbWVudCwgd2hlcmUgYm90aCB2YWx1ZXMgcmFuZ2Vcblx0Ly8gZnJvbSAwIHRvIDEuIElmIHRoZSBjYWxlbmRhciBpcyBsZWZ0LXRvLXJpZ2h0LCB0aGUgc2VnLmJhY2t3YXJkQ29vcmQgbWFwcyB0byBcImxlZnRcIiBhbmRcblx0Ly8gc2VnLmZvcndhcmRDb29yZCBtYXBzIHRvIFwicmlnaHRcIiAodmlhIHBlcmNlbnRhZ2UpLiBWaWNlLXZlcnNhIGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LlxuXHQvL1xuXHQvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgXCJzZXJpZXNcIiwgd2hpY2ggbWVhbnMgY29uc2VjdXRpdmUgc2VnbWVudHMgd2l0aCB0aGUgc2FtZSBwcmVzc3VyZVxuXHQvLyB3aG8ncyB3aWR0aCBpcyB1bmtub3duIHVudGlsIGFuIGVkZ2UgaGFzIGJlZW4gaGl0LiBgc2VyaWVzQmFja3dhcmRQcmVzc3VyZWAgaXMgdGhlIG51bWJlciBvZlxuXHQvLyBzZWdtZW50cyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzLCBhbmQgYHNlcmllc0JhY2t3YXJkQ29vcmRgIGlzIHRoZSBzdGFydGluZ1xuXHQvLyBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBzZWdtZW50IGluIHRoZSBzZXJpZXMuXG5cdGNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrOiBmdW5jdGlvbihzZWcsIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUsIHNlcmllc0JhY2t3YXJkQ29vcmQpIHtcblx0XHR2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2VnLmZvcndhcmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7IC8vIG5vdCBhbHJlYWR5IGNvbXB1dGVkXG5cblx0XHRcdGlmICghZm9yd2FyZFNlZ3MubGVuZ3RoKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXG5cdFx0XHRcdHNlZy5mb3J3YXJkQ29vcmQgPSAxO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cblx0XHRcdFx0Ly8gc29ydCBoaWdoZXN0IHByZXNzdXJlIGZpcnN0XG5cdFx0XHRcdHRoaXMuc29ydEZvcndhcmRTZWdzKGZvcndhcmRTZWdzKTtcblxuXHRcdFx0XHQvLyB0aGlzIHNlZ21lbnQncyBmb3J3YXJkQ29vcmQgd2lsbCBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIGJhY2t3YXJkQ29vcmQgb2YgdGhlXG5cdFx0XHRcdC8vIGhpZ2hlc3QtcHJlc3N1cmUgZm9yd2FyZCBzZWdtZW50LlxuXHRcdFx0XHR0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XG5cdFx0XHRcdHNlZy5mb3J3YXJkQ29vcmQgPSBmb3J3YXJkU2Vnc1swXS5iYWNrd2FyZENvb3JkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXG5cdFx0XHRzZWcuYmFja3dhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQgLVxuXHRcdFx0XHQoc2VnLmZvcndhcmRDb29yZCAtIHNlcmllc0JhY2t3YXJkQ29vcmQpIC8gLy8gYXZhaWxhYmxlIHdpZHRoIGZvciBzZXJpZXNcblx0XHRcdFx0KHNlcmllc0JhY2t3YXJkUHJlc3N1cmUgKyAxKTsgLy8gIyBvZiBzZWdtZW50cyBpbiB0aGUgc2VyaWVzXG5cblx0XHRcdC8vIHVzZSB0aGlzIHNlZ21lbnQncyBjb29yZGluYXRlcyB0byBjb21wdXRlZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxlc3MtcHJlc3N1cml6ZWRcblx0XHRcdC8vIGZvcndhcmQgc2VnbWVudHNcblx0XHRcdGZvciAoaT0wOyBpPGZvcndhcmRTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2soZm9yd2FyZFNlZ3NbaV0sIDAsIHNlZy5mb3J3YXJkQ29vcmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdHNvcnRGb3J3YXJkU2VnczogZnVuY3Rpb24oZm9yd2FyZFNlZ3MpIHtcblx0XHRmb3J3YXJkU2Vncy5zb3J0KHByb3h5KHRoaXMsICdjb21wYXJlRm9yd2FyZFNlZ3MnKSk7XG5cdH0sXG5cblxuXHQvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggZm9yd2FyZCBzZWdtZW50IHRvIHJlbHkgb24gbW9yZSB3aGVuIGNvbXB1dGluZyBjb29yZGluYXRlcy5cblx0Y29tcGFyZUZvcndhcmRTZWdzOiBmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0Ly8gcHV0IGhpZ2hlci1wcmVzc3VyZSBmaXJzdFxuXHRcdHJldHVybiBzZWcyLmZvcndhcmRQcmVzc3VyZSAtIHNlZzEuZm9yd2FyZFByZXNzdXJlIHx8XG5cdFx0XHQvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxuXHRcdFx0KHNlZzEuYmFja3dhcmRDb29yZCB8fCAwKSAtIChzZWcyLmJhY2t3YXJkQ29vcmQgfHwgMCkgfHxcblx0XHRcdC8vIGRvIG5vcm1hbCBzb3J0aW5nLi4uXG5cdFx0XHR0aGlzLmNvbXBhcmVFdmVudFNlZ3Moc2VnMSwgc2VnMik7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGhhZCB0aGVpciBwb3NpdGlvbiBjb29yZGluYXRlcyBjb21wdXRlZCxcblx0Ly8gYXNzaWducyBwb3NpdGlvbi1yZWxhdGVkIENTUyB2YWx1ZXMgdG8gdGhlaXIgZWxlbWVudHMuXG5cdGFzc2lnbkZnU2VnSG9yaXpvbnRhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3Moc2VnKSk7XG5cblx0XHRcdC8vIGlmIHRoZSBoZWlnaHQgaXMgc2hvcnQsIGFkZCBhIGNsYXNzTmFtZSBmb3IgYWx0ZXJuYXRlIHN0eWxpbmdcblx0XHRcdGlmIChzZWcuYm90dG9tIC0gc2VnLnRvcCA8IDMwKSB7XG5cdFx0XHRcdHNlZy5lbC5hZGRDbGFzcygnZmMtc2hvcnQnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMvdmFsdWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW4gZXZlbnQgc2VnbWVudCBlbGVtZW50LlxuXHQvLyBDb250YWlucyBpbXBvcnRhbnQgcG9zaXRpb25pbmctcmVsYXRlZCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW55IGV2ZW50IGVsZW1lbnQsIGN1c3RvbWl6ZWQgb3Igbm90LlxuXHRnZW5lcmF0ZUZnU2VnSG9yaXpvbnRhbENzczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIHNob3VsZE92ZXJsYXAgPSB0aGlzLnZpZXcub3B0KCdzbG90RXZlbnRPdmVybGFwJyk7XG5cdFx0dmFyIGJhY2t3YXJkQ29vcmQgPSBzZWcuYmFja3dhcmRDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcblx0XHR2YXIgZm9yd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZDsgLy8gdGhlIHJpZ2h0IHNpZGUgaWYgTFRSLiB0aGUgbGVmdCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcblx0XHR2YXIgcHJvcHMgPSB0aGlzLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKTsgLy8gZ2V0IHRvcC9ib3R0b20gZmlyc3Rcblx0XHR2YXIgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuXHRcdHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcblxuXHRcdGlmIChzaG91bGRPdmVybGFwKSB7XG5cdFx0XHQvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxuXHRcdFx0Zm9yd2FyZENvb3JkID0gTWF0aC5taW4oMSwgYmFja3dhcmRDb29yZCArIChmb3J3YXJkQ29vcmQgLSBiYWNrd2FyZENvb3JkKSAqIDIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRsZWZ0ID0gMSAtIGZvcndhcmRDb29yZDtcblx0XHRcdHJpZ2h0ID0gYmFja3dhcmRDb29yZDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZWZ0ID0gYmFja3dhcmRDb29yZDtcblx0XHRcdHJpZ2h0ID0gMSAtIGZvcndhcmRDb29yZDtcblx0XHR9XG5cblx0XHRwcm9wcy56SW5kZXggPSBzZWcubGV2ZWwgKyAxOyAvLyBjb252ZXJ0IGZyb20gMC1iYXNlIHRvIDEtYmFzZWRcblx0XHRwcm9wcy5sZWZ0ID0gbGVmdCAqIDEwMCArICclJztcblx0XHRwcm9wcy5yaWdodCA9IHJpZ2h0ICogMTAwICsgJyUnO1xuXG5cdFx0aWYgKHNob3VsZE92ZXJsYXAgJiYgc2VnLmZvcndhcmRQcmVzc3VyZSkge1xuXHRcdFx0Ly8gYWRkIHBhZGRpbmcgdG8gdGhlIGVkZ2Ugc28gdGhhdCBmb3J3YXJkIHN0YWNrZWQgZXZlbnRzIGRvbid0IGNvdmVyIHRoZSByZXNpemVyJ3MgaWNvblxuXHRcdFx0cHJvcHNbdGhpcy5pc1JUTCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvcHM7XG5cdH1cblxufSk7XG5cblxuLy8gQnVpbGRzIGFuIGFycmF5IG9mIHNlZ21lbnRzIFwibGV2ZWxzXCIuIFRoZSBmaXJzdCBsZXZlbCB3aWxsIGJlIHRoZSBsZWZ0bW9zdCB0aWVyIG9mIHNlZ21lbnRzIGlmIHRoZSBjYWxlbmRhciBpc1xuLy8gbGVmdC10by1yaWdodCwgb3IgdGhlIHJpZ2h0bW9zdCBpZiB0aGUgY2FsZW5kYXIgaXMgcmlnaHQtdG8tbGVmdC4gQXNzdW1lcyB0aGUgc2VnbWVudHMgYXJlIGFscmVhZHkgb3JkZXJlZCBieSBkYXRlLlxuZnVuY3Rpb24gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpIHtcblx0dmFyIGxldmVscyA9IFtdO1xuXHR2YXIgaSwgc2VnO1xuXHR2YXIgajtcblxuXHRmb3IgKGk9MDsgaTxzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0c2VnID0gc2Vnc1tpXTtcblxuXHRcdC8vIGdvIHRocm91Z2ggYWxsIHRoZSBsZXZlbHMgYW5kIHN0b3Agb24gdGhlIGZpcnN0IGxldmVsIHdoZXJlIHRoZXJlIGFyZSBubyBjb2xsaXNpb25zXG5cdFx0Zm9yIChqPTA7IGo8bGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRpZiAoIWNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1tqXSkubGVuZ3RoKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlZy5sZXZlbCA9IGo7XG5cblx0XHQobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcblx0fVxuXG5cdHJldHVybiBsZXZlbHM7XG59XG5cblxuLy8gRm9yIGV2ZXJ5IHNlZ21lbnQsIGZpZ3VyZSBvdXQgdGhlIG90aGVyIHNlZ21lbnRzIHRoYXQgYXJlIGluIHN1YnNlcXVlbnRcbi8vIGxldmVscyB0aGF0IGFsc28gb2NjdXB5IHRoZSBzYW1lIHZlcnRpY2FsIHNwYWNlLiBBY2N1bXVsYXRlIGluIHNlZy5mb3J3YXJkU2Vnc1xuZnVuY3Rpb24gY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpIHtcblx0dmFyIGksIGxldmVsO1xuXHR2YXIgaiwgc2VnO1xuXHR2YXIgaztcblxuXHRmb3IgKGk9MDsgaTxsZXZlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRsZXZlbCA9IGxldmVsc1tpXTtcblxuXHRcdGZvciAoaj0wOyBqPGxldmVsLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRzZWcgPSBsZXZlbFtqXTtcblxuXHRcdFx0c2VnLmZvcndhcmRTZWdzID0gW107XG5cdFx0XHRmb3IgKGs9aSsxOyBrPGxldmVscy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNba10sIHNlZy5mb3J3YXJkU2Vncyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cblxuLy8gRmlndXJlIG91dCB3aGljaCBwYXRoIGZvcndhcmQgKHZpYSBzZWcuZm9yd2FyZFNlZ3MpIHJlc3VsdHMgaW4gdGhlIGxvbmdlc3QgcGF0aCB1bnRpbFxuLy8gdGhlIGZ1cnRoZXN0IGVkZ2UgaXMgcmVhY2hlZC4gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhdGggd2lsbCBiZSBzZWcuZm9yd2FyZFByZXNzdXJlXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhzZWcpIHtcblx0dmFyIGZvcndhcmRTZWdzID0gc2VnLmZvcndhcmRTZWdzO1xuXHR2YXIgZm9yd2FyZFByZXNzdXJlID0gMDtcblx0dmFyIGksIGZvcndhcmRTZWc7XG5cblx0aWYgKHNlZy5mb3J3YXJkUHJlc3N1cmUgPT09IHVuZGVmaW5lZCkgeyAvLyBub3QgYWxyZWFkeSBjb21wdXRlZFxuXG5cdFx0Zm9yIChpPTA7IGk8Zm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvcndhcmRTZWcgPSBmb3J3YXJkU2Vnc1tpXTtcblxuXHRcdFx0Ly8gZmlndXJlIG91dCB0aGUgY2hpbGQncyBtYXhpbXVtIGZvcndhcmQgcGF0aFxuXHRcdFx0Y29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoZm9yd2FyZFNlZyk7XG5cblx0XHRcdC8vIGVpdGhlciB1c2UgdGhlIGV4aXN0aW5nIG1heGltdW0sIG9yIHVzZSB0aGUgY2hpbGQncyBmb3J3YXJkIHByZXNzdXJlXG5cdFx0XHQvLyBwbHVzIG9uZSAoZm9yIHRoZSBmb3J3YXJkU2VnIGl0c2VsZilcblx0XHRcdGZvcndhcmRQcmVzc3VyZSA9IE1hdGgubWF4KFxuXHRcdFx0XHRmb3J3YXJkUHJlc3N1cmUsXG5cdFx0XHRcdDEgKyBmb3J3YXJkU2VnLmZvcndhcmRQcmVzc3VyZVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRzZWcuZm9yd2FyZFByZXNzdXJlID0gZm9yd2FyZFByZXNzdXJlO1xuXHR9XG59XG5cblxuLy8gRmluZCBhbGwgdGhlIHNlZ21lbnRzIGluIGBvdGhlclNlZ3NgIHRoYXQgdmVydGljYWxseSBjb2xsaWRlIHdpdGggYHNlZ2AuXG4vLyBBcHBlbmQgaW50byBhbiBvcHRpb25hbGx5LXN1cHBsaWVkIGByZXN1bHRzYCBhcnJheSBhbmQgcmV0dXJuLlxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgb3RoZXJTZWdzLCByZXN1bHRzKSB7XG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdGZvciAodmFyIGk9MDsgaTxvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoaXNTbG90U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzW2ldKSkge1xuXHRcdFx0cmVzdWx0cy5wdXNoKG90aGVyU2Vnc1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cblxuLy8gRG8gdGhlc2Ugc2VnbWVudHMgb2NjdXB5IHRoZSBzYW1lIHZlcnRpY2FsIHNwYWNlP1xuZnVuY3Rpb24gaXNTbG90U2VnQ29sbGlzaW9uKHNlZzEsIHNlZzIpIHtcblx0cmV0dXJuIHNlZzEuYm90dG9tID4gc2VnMi50b3AgJiYgc2VnMS50b3AgPCBzZWcyLmJvdHRvbTtcbn1cblxuOztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZnJvbSB3aGljaCBvdGhlciB2aWV3cyBpbmhlcml0IGZyb21cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgVmlldyA9IEZDLlZpZXcgPSBDbGFzcy5leHRlbmQoRW1pdHRlck1peGluLCBMaXN0ZW5lck1peGluLCB7XG5cblx0dHlwZTogbnVsbCwgLy8gc3ViY2xhc3MnIHZpZXcgbmFtZSAoc3RyaW5nKVxuXHRuYW1lOiBudWxsLCAvLyBkZXByZWNhdGVkLiB1c2UgYHR5cGVgIGluc3RlYWRcblx0dGl0bGU6IG51bGwsIC8vIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGhlYWRlcidzIHRpdGxlXG5cblx0Y2FsZW5kYXI6IG51bGwsIC8vIG93bmVyIENhbGVuZGFyIG9iamVjdFxuXHRvcHRpb25zOiBudWxsLCAvLyBoYXNoIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMuIGFscmVhZHkgbWVyZ2VkIHdpdGggdmlldy1zcGVjaWZpYy1vcHRpb25zXG5cdGVsOiBudWxsLCAvLyB0aGUgdmlldydzIGNvbnRhaW5pbmcgZWxlbWVudC4gc2V0IGJ5IENhbGVuZGFyXG5cblx0ZGlzcGxheWluZzogbnVsbCwgLy8gYSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgcmVuZGVyaW5nLiBudWxsIGlmIG5vIHJlbmRlciByZXF1ZXN0ZWRcblx0aXNTa2VsZXRvblJlbmRlcmVkOiBmYWxzZSxcblx0aXNFdmVudHNSZW5kZXJlZDogZmFsc2UsXG5cblx0Ly8gcmFuZ2UgdGhlIHZpZXcgaXMgYWN0dWFsbHkgZGlzcGxheWluZyAobW9tZW50cylcblx0c3RhcnQ6IG51bGwsXG5cdGVuZDogbnVsbCwgLy8gZXhjbHVzaXZlXG5cblx0Ly8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yIChtb21lbnRzKVxuXHQvLyBtYXkgYmUgZGlmZmVyZW50IGZyb20gc3RhcnQvZW5kLiBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcblx0aW50ZXJ2YWxTdGFydDogbnVsbCxcblx0aW50ZXJ2YWxFbmQ6IG51bGwsIC8vIGV4Y2x1c2l2ZVxuXHRpbnRlcnZhbER1cmF0aW9uOiBudWxsLFxuXHRpbnRlcnZhbFVuaXQ6IG51bGwsIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcblxuXHRpc1JUTDogZmFsc2UsXG5cdGlzU2VsZWN0ZWQ6IGZhbHNlLCAvLyBib29sZWFuIHdoZXRoZXIgYSByYW5nZSBvZiB0aW1lIGlzIHVzZXItc2VsZWN0ZWQgb3Igbm90XG5cdHNlbGVjdGVkRXZlbnQ6IG51bGwsXG5cblx0ZXZlbnRPcmRlclNwZWNzOiBudWxsLCAvLyBjcml0ZXJpYSBmb3Igb3JkZXJpbmcgZXZlbnRzIHdoZW4gdGhleSBoYXZlIHNhbWUgZGF0ZS90aW1lXG5cblx0Ly8gY2xhc3NOYW1lcyBzdHlsZWQgYnkganF1aSB0aGVtZXNcblx0d2lkZ2V0SGVhZGVyQ2xhc3M6IG51bGwsXG5cdHdpZGdldENvbnRlbnRDbGFzczogbnVsbCxcblx0aGlnaGxpZ2h0U3RhdGVDbGFzczogbnVsbCxcblxuXHQvLyBmb3IgZGF0ZSB1dGlscywgY29tcHV0ZWQgZnJvbSBvcHRpb25zXG5cdG5leHREYXlUaHJlc2hvbGQ6IG51bGwsXG5cdGlzSGlkZGVuRGF5SGFzaDogbnVsbCxcblxuXHQvLyBub3cgaW5kaWNhdG9yXG5cdGlzTm93SW5kaWNhdG9yUmVuZGVyZWQ6IG51bGwsXG5cdGluaXRpYWxOb3dEYXRlOiBudWxsLCAvLyByZXN1bHQgZmlyc3QgZ2V0Tm93IGNhbGxcblx0aW5pdGlhbE5vd1F1ZXJpZWRNczogbnVsbCwgLy8gbXMgdGltZSB0aGUgZ2V0Tm93IHdhcyBjYWxsZWRcblx0bm93SW5kaWNhdG9yVGltZW91dElEOiBudWxsLCAvLyBmb3IgcmVmcmVzaCB0aW1pbmcgb2Ygbm93IGluZGljYXRvclxuXHRub3dJbmRpY2F0b3JJbnRlcnZhbElEOiBudWxsLCAvLyBcIlxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKGNhbGVuZGFyLCB0eXBlLCBvcHRpb25zLCBpbnRlcnZhbER1cmF0aW9uKSB7XG5cblx0XHR0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG5cdFx0dGhpcy50eXBlID0gdGhpcy5uYW1lID0gdHlwZTsgLy8gLm5hbWUgaXMgZGVwcmVjYXRlZFxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5pbnRlcnZhbER1cmF0aW9uID0gaW50ZXJ2YWxEdXJhdGlvbiB8fCBtb21lbnQuZHVyYXRpb24oMSwgJ2RheScpO1xuXG5cdFx0dGhpcy5uZXh0RGF5VGhyZXNob2xkID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCduZXh0RGF5VGhyZXNob2xkJykpO1xuXHRcdHRoaXMuaW5pdFRoZW1pbmdQcm9wcygpO1xuXHRcdHRoaXMuaW5pdEhpZGRlbkRheXMoKTtcblx0XHR0aGlzLmlzUlRMID0gdGhpcy5vcHQoJ2lzUlRMJyk7XG5cblx0XHR0aGlzLmV2ZW50T3JkZXJTcGVjcyA9IHBhcnNlRmllbGRTcGVjcyh0aGlzLm9wdCgnZXZlbnRPcmRlcicpKTtcblxuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cblx0Ly8gQSBnb29kIHBsYWNlIGZvciBzdWJjbGFzc2VzIHRvIGluaXRpYWxpemUgbWVtYmVyIHZhcmlhYmxlc1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbiBvcHRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuXHRvcHQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgaGFuZGxlcnMgdGhhdCBhcmUgdmlldy1yZWxhdGVkLiBNb2RpZmllcyBhcmdzIGJlZm9yZSBwYXNzaW5nIHRvIGNhbGVuZGFyLlxuXHR0cmlnZ2VyOiBmdW5jdGlvbihuYW1lLCB0aGlzT2JqKSB7IC8vIGFyZ3VtZW50cyBiZXlvbmQgdGhpc09iaiBhcmUgcGFzc2VkIGFsb25nXG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcblxuXHRcdHJldHVybiBjYWxlbmRhci50cmlnZ2VyLmFwcGx5KFxuXHRcdFx0Y2FsZW5kYXIsXG5cdFx0XHRbbmFtZSwgdGhpc09iaiB8fCB0aGlzXS5jb25jYXQoXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIC8vIGFyZ3VtZW50cyBiZXlvbmQgdGhpc09ialxuXHRcdFx0XHRbIHRoaXMgXSAvLyBhbHdheXMgbWFrZSB0aGUgbGFzdCBhcmd1bWVudCBhIHJlZmVyZW5jZSB0byB0aGUgdmlldy4gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8qIERhdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBVcGRhdGVzIGFsbCBpbnRlcm5hbCBkYXRlcyB0byBjZW50ZXIgYXJvdW5kIHRoZSBnaXZlbiBjdXJyZW50IHVuem9uZWQgZGF0ZS5cblx0c2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHRoaXMuc2V0UmFuZ2UodGhpcy5jb21wdXRlUmFuZ2UoZGF0ZSkpO1xuXHR9LFxuXG5cblx0Ly8gVXBkYXRlcyBhbGwgaW50ZXJuYWwgZGF0ZXMgZm9yIGRpc3BsYXlpbmcgdGhlIGdpdmVuIHVuem9uZWQgcmFuZ2UuXG5cdHNldFJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdCQuZXh0ZW5kKHRoaXMsIHJhbmdlKTsgLy8gYXNzaWducyBldmVyeSBwcm9wZXJ0eSB0byB0aGlzIG9iamVjdCdzIG1lbWJlciB2YXJpYWJsZXNcblx0XHR0aGlzLnVwZGF0ZVRpdGxlKCk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHNpbmdsZSBjdXJyZW50IHVuem9uZWQgZGF0ZSwgcHJvZHVjZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHJhbmdlIHRvIGRpc3BsYXkuXG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlLiBNdXN0IHJldHVybiBhbGwgcHJvcGVydGllcy5cblx0Y29tcHV0ZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIGludGVydmFsVW5pdCA9IGNvbXB1dGVJbnRlcnZhbFVuaXQodGhpcy5pbnRlcnZhbER1cmF0aW9uKTtcblx0XHR2YXIgaW50ZXJ2YWxTdGFydCA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKGludGVydmFsVW5pdCk7XG5cdFx0dmFyIGludGVydmFsRW5kID0gaW50ZXJ2YWxTdGFydC5jbG9uZSgpLmFkZCh0aGlzLmludGVydmFsRHVyYXRpb24pO1xuXHRcdHZhciBzdGFydCwgZW5kO1xuXG5cdFx0Ly8gbm9ybWFsaXplIHRoZSByYW5nZSdzIHRpbWUtYW1iaWd1aXR5XG5cdFx0aWYgKC95ZWFyfG1vbnRofHdlZWt8ZGF5Ly50ZXN0KGludGVydmFsVW5pdCkpIHsgLy8gd2hvbGUtZGF5cz9cblx0XHRcdGludGVydmFsU3RhcnQuc3RyaXBUaW1lKCk7XG5cdFx0XHRpbnRlcnZhbEVuZC5zdHJpcFRpbWUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIG5lZWRzIHRvIGhhdmUgYSB0aW1lP1xuXHRcdFx0aWYgKCFpbnRlcnZhbFN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0XHRpbnRlcnZhbFN0YXJ0ID0gdGhpcy5jYWxlbmRhci50aW1lKDApOyAvLyBnaXZlIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHRcdGlmICghaW50ZXJ2YWxFbmQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdGludGVydmFsRW5kID0gdGhpcy5jYWxlbmRhci50aW1lKDApOyAvLyBnaXZlIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGFydCA9IGludGVydmFsU3RhcnQuY2xvbmUoKTtcblx0XHRzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuXHRcdGVuZCA9IGludGVydmFsRW5kLmNsb25lKCk7XG5cdFx0ZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKTsgLy8gZXhjbHVzaXZlbHkgbW92ZSBiYWNrd2FyZHNcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbnRlcnZhbFVuaXQ6IGludGVydmFsVW5pdCxcblx0XHRcdGludGVydmFsU3RhcnQ6IGludGVydmFsU3RhcnQsXG5cdFx0XHRpbnRlcnZhbEVuZDogaW50ZXJ2YWxFbmQsXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRlbmQ6IGVuZFxuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgbmV3IGRhdGUgd2hlbiB0aGUgdXNlciBoaXRzIHRoZSBwcmV2IGJ1dHRvbiwgZ2l2ZW4gdGhlIGN1cnJlbnQgZGF0ZVxuXHRjb21wdXRlUHJldkRhdGU6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXNzYWdlQ3VycmVudERhdGUoXG5cdFx0XHRkYXRlLmNsb25lKCkuc3RhcnRPZih0aGlzLmludGVydmFsVW5pdCkuc3VidHJhY3QodGhpcy5pbnRlcnZhbER1cmF0aW9uKSwgLTFcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIG5ldyBkYXRlIHdoZW4gdGhlIHVzZXIgaGl0cyB0aGUgbmV4dCBidXR0b24sIGdpdmVuIHRoZSBjdXJyZW50IGRhdGVcblx0Y29tcHV0ZU5leHREYXRlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFzc2FnZUN1cnJlbnREYXRlKFxuXHRcdFx0ZGF0ZS5jbG9uZSgpLnN0YXJ0T2YodGhpcy5pbnRlcnZhbFVuaXQpLmFkZCh0aGlzLmludGVydmFsRHVyYXRpb24pXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGFyYml0cmFyaWx5IGNhbGN1bGF0ZWQgY3VycmVudCBkYXRlIG9mIHRoZSBjYWxlbmRhciwgcmV0dXJucyBhIGRhdGUgdGhhdCBpcyBlbnN1cmVkIHRvIGJlIGNvbXBsZXRlbHlcblx0Ly8gdmlzaWJsZS4gYGRpcmVjdGlvbmAgaXMgb3B0aW9uYWwgYW5kIGluZGljYXRlcyB3aGljaCBkaXJlY3Rpb24gdGhlIGN1cnJlbnQgZGF0ZSB3YXMgYmVpbmdcblx0Ly8gaW5jcmVtZW50ZWQgb3IgZGVjcmVtZW50ZWQgKDEgb3IgLTEpLlxuXHRtYXNzYWdlQ3VycmVudERhdGU6IGZ1bmN0aW9uKGRhdGUsIGRpcmVjdGlvbikge1xuXHRcdGlmICh0aGlzLmludGVydmFsRHVyYXRpb24uYXMoJ2RheXMnKSA8PSAxKSB7IC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG5cdFx0XHRpZiAodGhpcy5pc0hpZGRlbkRheShkYXRlKSkge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuXHRcdFx0XHRkYXRlLnN0YXJ0T2YoJ2RheScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRlO1xuXHR9LFxuXG5cblx0LyogVGl0bGUgYW5kIERhdGUgRm9ybWF0dGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2V0cyB0aGUgdmlldydzIHRpdGxlIHByb3BlcnR5IHRvIHRoZSBtb3N0IHVwZGF0ZWQgY29tcHV0ZWQgdmFsdWVcblx0dXBkYXRlVGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGl0bGUgPSB0aGlzLmNvbXB1dGVUaXRsZSgpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcblx0Y29tcHV0ZVRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXRSYW5nZShcblx0XHRcdHtcblx0XHRcdFx0Ly8gaW4gY2FzZSBpbnRlcnZhbFN0YXJ0L0VuZCBoYXMgYSB0aW1lLCBtYWtlIHN1cmUgdGltZXpvbmUgaXMgY29ycmVjdFxuXHRcdFx0XHRzdGFydDogdGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHRoaXMuaW50ZXJ2YWxTdGFydCksXG5cdFx0XHRcdGVuZDogdGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHRoaXMuaW50ZXJ2YWxFbmQpXG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5vcHQoJ3RpdGxlRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlVGl0bGVGb3JtYXQoKSxcblx0XHRcdHRoaXMub3B0KCd0aXRsZVJhbmdlU2VwYXJhdG9yJylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuXHQvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuXHRjb21wdXRlVGl0bGVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmludGVydmFsVW5pdCA9PSAneWVhcicpIHtcblx0XHRcdHJldHVybiAnWVlZWSc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuaW50ZXJ2YWxVbml0ID09ICdtb250aCcpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdCgnbW9udGhZZWFyRm9ybWF0Jyk7IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuaW50ZXJ2YWxEdXJhdGlvbi5hcygnZGF5cycpID4gMSkge1xuXHRcdFx0cmV0dXJuICdsbCc7IC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICdMTCc7IC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFV0aWxpdHkgZm9yIGZvcm1hdHRpbmcgYSByYW5nZS4gQWNjZXB0cyBhIHJhbmdlIG9iamVjdCwgZm9ybWF0dGluZyBzdHJpbmcsIGFuZCBvcHRpb25hbCBzZXBhcmF0b3IuXG5cdC8vIERpc3BsYXlzIGFsbC1kYXkgcmFuZ2VzIG5hdHVyYWxseSwgd2l0aCBhbiBpbmNsdXNpdmUgZW5kLiBUYWtlcyB0aGUgY3VycmVudCBpc1JUTCBpbnRvIGFjY291bnQuXG5cdC8vIFRoZSB0aW1lem9uZXMgb2YgdGhlIGRhdGVzIHdpdGhpbiBgcmFuZ2VgIHdpbGwgYmUgcmVzcGVjdGVkLlxuXHRmb3JtYXRSYW5nZTogZnVuY3Rpb24ocmFuZ2UsIGZvcm1hdFN0ciwgc2VwYXJhdG9yKSB7XG5cdFx0dmFyIGVuZCA9IHJhbmdlLmVuZDtcblxuXHRcdGlmICghZW5kLmhhc1RpbWUoKSkgeyAvLyBhbGwtZGF5P1xuXHRcdFx0ZW5kID0gZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7IC8vIGNvbnZlcnQgdG8gaW5jbHVzaXZlLiBsYXN0IG1zIG9mIHByZXZpb3VzIGRheVxuXHRcdH1cblxuXHRcdHJldHVybiBmb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgZW5kLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgdGhpcy5vcHQoJ2lzUlRMJykpO1xuXHR9LFxuXG5cblx0LyogUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTZXRzIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSB2aWV3IHNob3VsZCByZW5kZXIgaW5zaWRlIG9mLlxuXHQvLyBEb2VzIG90aGVyIERPTS1yZWxhdGVkIGluaXRpYWxpemF0aW9ucy5cblx0c2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcblx0XHR0aGlzLmVsID0gZWw7XG5cdFx0dGhpcy5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcblx0fSxcblxuXG5cdC8vIFJlbW92ZXMgdGhlIHZpZXcncyBjb250YWluZXIgZWxlbWVudCBmcm9tIHRoZSBET00sIGNsZWFyaW5nIGFueSBjb250ZW50IGJlZm9yZWhhbmQuXG5cdC8vIFVuZG9lcyBhbnkgb3RoZXIgRE9NLXJlbGF0ZWQgYXR0YWNobWVudHMuXG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2xlYXIoKTsgLy8gY2xlYXJzIGFsbCBjb250ZW50XG5cblx0XHQvLyBjbGVhbiB1cCB0aGUgc2tlbGV0b25cblx0XHRpZiAodGhpcy5pc1NrZWxldG9uUmVuZGVyZWQpIHtcblx0XHRcdHRoaXMudW5yZW5kZXJTa2VsZXRvbigpO1xuXHRcdFx0dGhpcy5pc1NrZWxldG9uUmVuZGVyZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLnVuYmluZEdsb2JhbEhhbmRsZXJzKCk7XG5cblx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXG5cdFx0Ly8gTk9URTogZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBpbiBjYXNlIHRoZSBWaWV3IHdhcyBkZXN0cm95ZWQgd2l0aGluIGFuIEFQSSBjYWxsYmFjay5cblx0XHQvLyBXZSBkb24ndCBudWxsLW91dCB0aGUgVmlldydzIG90aGVyIGpRdWVyeSBlbGVtZW50IHJlZmVyZW5jZXMgdXBvbiBkZXN0cm95LFxuXHRcdC8vICBzbyB3ZSBzaG91bGRuJ3Qga2lsbCB0aGlzLmVsIGVpdGhlci5cblx0fSxcblxuXG5cdC8vIERvZXMgZXZlcnl0aGluZyBuZWNlc3NhcnkgdG8gZGlzcGxheSB0aGUgdmlldyBjZW50ZXJlZCBhcm91bmQgdGhlIGdpdmVuIHVuem9uZWQgZGF0ZS5cblx0Ly8gRG9lcyBldmVyeSB0eXBlIG9mIHJlbmRlcmluZyBFWENFUFQgcmVuZGVyaW5nIGV2ZW50cy5cblx0Ly8gSXMgYXN5Y2hyb25vdXMgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuXHRkaXNwbGF5OiBmdW5jdGlvbihkYXRlLCBleHBsaWNpdFNjcm9sbFN0YXRlKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgcHJldlNjcm9sbFN0YXRlID0gbnVsbDtcblxuXHRcdGlmIChleHBsaWNpdFNjcm9sbFN0YXRlICE9IG51bGwgJiYgdGhpcy5kaXNwbGF5aW5nKSB7IC8vIGRvbid0IG5lZWQgcHJldlNjcm9sbFN0YXRlIGlmIGV4cGxpY2l0U2Nyb2xsU3RhdGVcblx0XHRcdHByZXZTY3JvbGxTdGF0ZSA9IHRoaXMucXVlcnlTY3JvbGwoKTtcblx0XHR9XG5cblx0XHR0aGlzLmNhbGVuZGFyLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcblxuXHRcdHJldHVybiBzeW5jVGhlbih0aGlzLmNsZWFyKCksIGZ1bmN0aW9uKCkgeyAvLyBjbGVhciB0aGUgY29udGVudCBmaXJzdFxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0X3RoaXMuZGlzcGxheWluZyA9XG5cdFx0XHRcdFx0c3luY1RoZW4oX3RoaXMuZGlzcGxheVZpZXcoZGF0ZSksIGZ1bmN0aW9uKCkgeyAvLyBkaXNwbGF5VmlldyBtaWdodCByZXR1cm4gYSBwcm9taXNlXG5cblx0XHRcdFx0XHRcdC8vIGNhbGxlciBvZiBkaXNwbGF5KCkgd2FudHMgYSBzcGVjaWZpYyBzY3JvbGwgc3RhdGU/XG5cdFx0XHRcdFx0XHRpZiAoZXhwbGljaXRTY3JvbGxTdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHdlIG1ha2UgYW4gYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgTk9UIHRoZSBpbml0aWFsIHJlbmRlcixcblx0XHRcdFx0XHRcdFx0Ly8gYW5kIHRodXMgZG9uJ3QgbmVlZCBmb3JjZVNjcm9sbCAoaXMgaW5jb252ZW5pZW50bHkgYXN5bmNocm9ub3VzKVxuXHRcdFx0XHRcdFx0XHRfdGhpcy5zZXRTY3JvbGwoZXhwbGljaXRTY3JvbGxTdGF0ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0X3RoaXMuZm9yY2VTY3JvbGwoX3RoaXMuY29tcHV0ZUluaXRpYWxTY3JvbGwocHJldlNjcm9sbFN0YXRlKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF90aGlzLmNhbGVuZGFyLnVuZnJlZXplQ29udGVudEhlaWdodCgpO1xuXHRcdFx0XHRcdFx0X3RoaXMudHJpZ2dlclJlbmRlcigpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gRG9lcyBldmVyeXRoaW5nIG5lY2Vzc2FyeSB0byBjbGVhciB0aGUgY29udGVudCBvZiB0aGUgdmlldy5cblx0Ly8gQ2xlYXJzIGRhdGVzIGFuZCBldmVudHMuIERvZXMgbm90IGNsZWFyIHRoZSBza2VsZXRvbi5cblx0Ly8gSXMgYXN5Y2hyb25vdXMgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgZGlzcGxheWluZyA9IHRoaXMuZGlzcGxheWluZztcblxuXHRcdGlmIChkaXNwbGF5aW5nKSB7IC8vIHByZXZpb3VzbHkgZGlzcGxheWVkLCBvciBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyBkaXNwbGF5ZWQ/XG5cdFx0XHRyZXR1cm4gc3luY1RoZW4oZGlzcGxheWluZywgZnVuY3Rpb24oKSB7IC8vIHdhaXQgZm9yIHRoZSBkaXNwbGF5IHRvIGZpbmlzaFxuXHRcdFx0XHRfdGhpcy5kaXNwbGF5aW5nID0gbnVsbDtcblx0XHRcdFx0X3RoaXMuY2xlYXJFdmVudHMoKTtcblx0XHRcdFx0cmV0dXJuIF90aGlzLmNsZWFyVmlldygpOyAvLyBtaWdodCByZXR1cm4gYSBwcm9taXNlLiBjaGFpbiBpdFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICQud2hlbigpOyAvLyBhbiBpbW1lZGlhdGVseS1yZXNvbHZlZCBwcm9taXNlXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gRGlzcGxheXMgdGhlIHZpZXcncyBub24tZXZlbnQgY29udGVudCwgc3VjaCBhcyBkYXRlLXJlbGF0ZWQgY29udGVudCBvciBhbnl0aGluZyByZXF1aXJlZCBieSBldmVudHMuXG5cdC8vIFJlbmRlcnMgdGhlIHZpZXcncyBub24tY29udGVudCBza2VsZXRvbiBpZiBuZWNlc3NhcnkuXG5cdC8vIENhbiBiZSBhc3luY2hyb25vdXMgYW5kIHJldHVybiBhIHByb21pc2UuXG5cdGRpc3BsYXlWaWV3OiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0aWYgKCF0aGlzLmlzU2tlbGV0b25SZW5kZXJlZCkge1xuXHRcdFx0dGhpcy5yZW5kZXJTa2VsZXRvbigpO1xuXHRcdFx0dGhpcy5pc1NrZWxldG9uUmVuZGVyZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoZGF0ZSkge1xuXHRcdFx0dGhpcy5zZXREYXRlKGRhdGUpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5yZW5kZXIpIHtcblx0XHRcdHRoaXMucmVuZGVyKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdH1cblx0XHR0aGlzLnJlbmRlckRhdGVzKCk7XG5cdFx0dGhpcy51cGRhdGVTaXplKCk7XG5cdFx0dGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7IC8vIG1pZ2h0IG5lZWQgY29vcmRpbmF0ZXMsIHNvIHNob3VsZCBnbyBhZnRlciB1cGRhdGVTaXplKClcblx0XHR0aGlzLnN0YXJ0Tm93SW5kaWNhdG9yKCk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIHZpZXcgY29udGVudCB0aGF0IHdhcyByZW5kZXJlZCBpbiBkaXNwbGF5Vmlldy5cblx0Ly8gQ2FuIGJlIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJuIGEgcHJvbWlzZS5cblx0Y2xlYXJWaWV3OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVuc2VsZWN0KCk7XG5cdFx0dGhpcy5zdG9wTm93SW5kaWNhdG9yKCk7XG5cdFx0dGhpcy50cmlnZ2VyVW5yZW5kZXIoKTtcblx0XHR0aGlzLnVucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHRcdHRoaXMudW5yZW5kZXJEYXRlcygpO1xuXHRcdGlmICh0aGlzLmRlc3Ryb3kpIHtcblx0XHRcdHRoaXMuZGVzdHJveSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXcgYmVmb3JlIGFueSBjb250ZW50IGlzIHJlbmRlcmVkXG5cdHJlbmRlclNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSB2aWV3XG5cdHVucmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgdmlldydzIGRhdGUtcmVsYXRlZCBjb250ZW50LlxuXHQvLyBBc3N1bWVzIHNldFJhbmdlIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIGFuZCB0aGUgc2tlbGV0b24gaGFzIGFscmVhZHkgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHRoZSB2aWV3J3MgZGF0ZS1yZWxhdGVkIGNvbnRlbnRcblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcblx0fSxcblxuXG5cdC8vIFNpZ25hbHMgdGhhdCB0aGUgdmlldydzIGNvbnRlbnQgaGFzIGJlZW4gcmVuZGVyZWRcblx0dHJpZ2dlclJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmlnZ2VyKCd2aWV3UmVuZGVyJywgdGhpcywgdGhpcywgdGhpcy5lbCk7XG5cdH0sXG5cblxuXHQvLyBTaWduYWxzIHRoYXQgdGhlIHZpZXcncyBjb250ZW50IGlzIGFib3V0IHRvIGJlIHVucmVuZGVyZWRcblx0dHJpZ2dlclVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ3ZpZXdEZXN0cm95JywgdGhpcywgdGhpcywgdGhpcy5lbCk7XG5cdH0sXG5cblxuXHQvLyBCaW5kcyBET00gaGFuZGxlcnMgdG8gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgdmlldyBjb250YWluZXIsIHN1Y2ggYXMgdGhlIGRvY3VtZW50XG5cdGJpbmRHbG9iYWxIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd24pO1xuXHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICd0b3VjaHN0YXJ0JywgdGhpcy5wcm9jZXNzVW5zZWxlY3QpO1xuXHR9LFxuXG5cblx0Ly8gVW5iaW5kcyBET00gaGFuZGxlcnMgZnJvbSBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lclxuXHR1bmJpbmRHbG9iYWxIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xuXHR9LFxuXG5cblx0Ly8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gdGhlbWluZ1xuXHRpbml0VGhlbWluZ1Byb3BzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG0gPSB0aGlzLm9wdCgndGhlbWUnKSA/ICd1aScgOiAnZmMnO1xuXG5cdFx0dGhpcy53aWRnZXRIZWFkZXJDbGFzcyA9IHRtICsgJy13aWRnZXQtaGVhZGVyJztcblx0XHR0aGlzLndpZGdldENvbnRlbnRDbGFzcyA9IHRtICsgJy13aWRnZXQtY29udGVudCc7XG5cdFx0dGhpcy5oaWdobGlnaHRTdGF0ZUNsYXNzID0gdG0gKyAnLXN0YXRlLWhpZ2hsaWdodCc7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBidXNpbmVzcy1ob3VycyBvbnRvIHRoZSB2aWV3LiBBc3N1bWVzIHVwZGF0ZVNpemUgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHByZXZpb3VzbHktcmVuZGVyZWQgYnVzaW5lc3MtaG91cnNcblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIE5vdyBJbmRpY2F0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEltbWVkaWF0ZWx5IHJlbmRlciB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgYmVnaW5zIHJlLXJlbmRlcmluZyBpdCBhdCBhbiBpbnRlcnZhbCxcblx0Ly8gd2hpY2ggaXMgZGVmaW5lZCBieSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKS5cblx0Ly8gVE9ETzogc29tZWhvdyBkbyB0aGlzIGZvciB0aGUgY3VycmVudCB3aG9sZSBkYXkncyBiYWNrZ3JvdW5kIHRvb1xuXHRzdGFydE5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdW5pdDtcblx0XHR2YXIgdXBkYXRlO1xuXHRcdHZhciBkZWxheTsgLy8gbXMgd2FpdCB2YWx1ZVxuXG5cdFx0aWYgKHRoaXMub3B0KCdub3dJbmRpY2F0b3InKSkge1xuXHRcdFx0dW5pdCA9IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xuXHRcdFx0aWYgKHVuaXQpIHtcblx0XHRcdFx0dXBkYXRlID0gcHJveHkodGhpcywgJ3VwZGF0ZU5vd0luZGljYXRvcicpOyAvLyBiaW5kIHRvIGB0aGlzYFxuXG5cdFx0XHRcdHRoaXMuaW5pdGlhbE5vd0RhdGUgPSB0aGlzLmNhbGVuZGFyLmdldE5vdygpO1xuXHRcdFx0XHR0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSArbmV3IERhdGUoKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IodGhpcy5pbml0aWFsTm93RGF0ZSk7XG5cdFx0XHRcdHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCA9IHRydWU7XG5cblx0XHRcdFx0Ly8gd2FpdCB1bnRpbCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGludGVydmFsXG5cdFx0XHRcdGRlbGF5ID0gdGhpcy5pbml0aWFsTm93RGF0ZS5jbG9uZSgpLnN0YXJ0T2YodW5pdCkuYWRkKDEsIHVuaXQpIC0gdGhpcy5pbml0aWFsTm93RGF0ZTtcblx0XHRcdFx0dGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF90aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCA9IG51bGw7XG5cdFx0XHRcdFx0dXBkYXRlKCk7XG5cdFx0XHRcdFx0ZGVsYXkgPSArbW9tZW50LmR1cmF0aW9uKDEsIHVuaXQpO1xuXHRcdFx0XHRcdGRlbGF5ID0gTWF0aC5tYXgoMTAwLCBkZWxheSk7IC8vIHByZXZlbnQgdG9vIGZyZXF1ZW50XG5cdFx0XHRcdFx0X3RoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IHNldEludGVydmFsKHVwZGF0ZSwgZGVsYXkpOyAvLyB1cGRhdGUgZXZlcnkgaW50ZXJ2YWxcblx0XHRcdFx0fSwgZGVsYXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIHJlcmVuZGVycyB0aGUgbm93IGluZGljYXRvciwgY29tcHV0aW5nIHRoZSBuZXcgY3VycmVudCB0aW1lIGZyb20gdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZFxuXHQvLyBzaW5jZSB0aGUgaW5pdGlhbCBnZXROb3cgY2FsbC5cblx0dXBkYXRlTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7XG5cdFx0XHR0aGlzLnJlbmRlck5vd0luZGljYXRvcihcblx0XHRcdFx0dGhpcy5pbml0aWFsTm93RGF0ZS5jbG9uZSgpLmFkZChuZXcgRGF0ZSgpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSAvLyBhZGQgbXNcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gSW1tZWRpYXRlbHkgdW5yZW5kZXJzIHRoZSB2aWV3J3MgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgc3RvcHMgYW55IHJlLXJlbmRlcmluZyB0aW1lcnMuXG5cdC8vIFdvbid0IGNhdXNlIHNpZGUgZWZmZWN0cyBpZiBpbmRpY2F0b3IgaXNuJ3QgcmVuZGVyZWQuXG5cdHN0b3BOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcblxuXHRcdFx0aWYgKHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCk7XG5cdFx0XHRcdHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCk7XG5cdFx0XHRcdHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcblx0XHRcdHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgdW5pdCwgbGlrZSAnc2Vjb25kJyBvciAnbWludXRlJyB0aGF0IGRlZmluZWQgaG93IG9mdGVuIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yXG5cdC8vIHNob3VsZCBiZSByZWZyZXNoZWQuIElmIHNvbWV0aGluZyBmYWxzeSBpcyByZXR1cm5lZCwgbm8gdGltZSBpbmRpY2F0b3IgaXMgcmVuZGVyZWQgYXQgYWxsLlxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGF0IHRoZSBnaXZlbiBkYXRldGltZVxuXHRyZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVuZG9lcyB0aGUgcmVuZGVyaW5nIGFjdGlvbnMgZnJvbSByZW5kZXJOb3dJbmRpY2F0b3Jcblx0dW5yZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogRGltZW5zaW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIGFueXRoaW5nIGRlcGVuZGFudCB1cG9uIHNpemluZyBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQgb2YgdGhlIGdyaWRcblx0dXBkYXRlU2l6ZTogZnVuY3Rpb24oaXNSZXNpemUpIHtcblx0XHR2YXIgc2Nyb2xsU3RhdGU7XG5cblx0XHRpZiAoaXNSZXNpemUpIHtcblx0XHRcdHNjcm9sbFN0YXRlID0gdGhpcy5xdWVyeVNjcm9sbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlSGVpZ2h0KGlzUmVzaXplKTtcblx0XHR0aGlzLnVwZGF0ZVdpZHRoKGlzUmVzaXplKTtcblx0XHR0aGlzLnVwZGF0ZU5vd0luZGljYXRvcigpO1xuXG5cdFx0aWYgKGlzUmVzaXplKSB7XG5cdFx0XHR0aGlzLnNldFNjcm9sbChzY3JvbGxTdGF0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIGNhbGVuZGFyXG5cdHVwZGF0ZVdpZHRoOiBmdW5jdGlvbihpc1Jlc2l6ZSkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSBjYWxlbmRhclxuXHR1cGRhdGVIZWlnaHQ6IGZ1bmN0aW9uKGlzUmVzaXplKSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjsgLy8gd2UgcG9sbCB0aGUgY2FsZW5kYXIgZm9yIGhlaWdodCBpbmZvcm1hdGlvblxuXG5cdFx0dGhpcy5zZXRIZWlnaHQoXG5cdFx0XHRjYWxlbmRhci5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0KCksXG5cdFx0XHRjYWxlbmRhci5pc0hlaWdodEF1dG8oKVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSBjYWxlbmRhciB0byB0aGUgc3BlY2lmaWVkIGhlaWdodC5cblx0Ly8gaWYgYGlzQXV0b2AgaXMgc2V0IHRvIHRydWUsIGhlaWdodCBiZWNvbWVzIG1lcmVseSBhIHN1Z2dlc3Rpb24gYW5kIHRoZSB2aWV3IHNob3VsZCB1c2UgaXRzIFwibmF0dXJhbFwiIGhlaWdodC5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIGlzQXV0bykge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogU2Nyb2xsZXJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIHRoZSBpbml0aWFsIHByZS1jb25maWd1cmVkIHNjcm9sbCBzdGF0ZSBwcmlvciB0byBhbGxvd2luZyB0aGUgdXNlciB0byBjaGFuZ2UgaXQuXG5cdC8vIEdpdmVuIHRoZSBzY3JvbGwgc3RhdGUgZnJvbSB0aGUgcHJldmlvdXMgcmVuZGVyaW5nLiBJZiBmaXJzdCB0aW1lIHJlbmRlcmluZywgZ2l2ZW4gbnVsbC5cblx0Y29tcHV0ZUluaXRpYWxTY3JvbGw6IGZ1bmN0aW9uKHByZXZpb3VzU2Nyb2xsU3RhdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyB0aGUgdmlldydzIGN1cnJlbnQgbmF0dXJhbCBzY3JvbGwgc3RhdGUuIENhbiByZXR1cm4gYW4gYXJiaXRyYXJ5IGZvcm1hdC5cblx0cXVlcnlTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFNldHMgdGhlIHZpZXcncyBzY3JvbGwgc3RhdGUuIFdpbGwgYWNjZXB0IHRoZSBzYW1lIGZvcm1hdCBjb21wdXRlSW5pdGlhbFNjcm9sbCBhbmQgcXVlcnlTY3JvbGwgcHJvZHVjZS5cblx0c2V0U2Nyb2xsOiBmdW5jdGlvbihzY3JvbGxTdGF0ZSkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFNldHMgdGhlIHNjcm9sbCBzdGF0ZSwgbWFraW5nIHN1cmUgdG8gb3ZlcmNvbWUgYW55IHByZWRlZmluZWQgc2Nyb2xsIHZhbHVlIHRoZSBicm93c2VyIGhhcyBpbiBtaW5kXG5cdGZvcmNlU2Nyb2xsOiBmdW5jdGlvbihzY3JvbGxTdGF0ZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLnNldFNjcm9sbChzY3JvbGxTdGF0ZSk7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLnNldFNjcm9sbChzY3JvbGxTdGF0ZSk7XG5cdFx0fSwgMCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBFbGVtZW50cyAvIFNlZ21lbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBEb2VzIGV2ZXJ5dGhpbmcgbmVjZXNzYXJ5IHRvIGRpc3BsYXkgdGhlIGdpdmVuIGV2ZW50cyBvbnRvIHRoZSBjdXJyZW50IHZpZXdcblx0ZGlzcGxheUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIHNjcm9sbFN0YXRlID0gdGhpcy5xdWVyeVNjcm9sbCgpO1xuXG5cdFx0dGhpcy5jbGVhckV2ZW50cygpO1xuXHRcdHRoaXMucmVuZGVyRXZlbnRzKGV2ZW50cyk7XG5cdFx0dGhpcy5pc0V2ZW50c1JlbmRlcmVkID0gdHJ1ZTtcblx0XHR0aGlzLnNldFNjcm9sbChzY3JvbGxTdGF0ZSk7XG5cdFx0dGhpcy50cmlnZ2VyRXZlbnRSZW5kZXIoKTtcblx0fSxcblxuXG5cdC8vIERvZXMgZXZlcnl0aGluZyBuZWNlc3NhcnkgdG8gY2xlYXIgdGhlIHZpZXcncyBjdXJyZW50bHktcmVuZGVyZWQgZXZlbnRzXG5cdGNsZWFyRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsU3RhdGU7XG5cblx0XHRpZiAodGhpcy5pc0V2ZW50c1JlbmRlcmVkKSB7XG5cblx0XHRcdC8vIFRPRE86IG9wdGltaXplOiBpZiB3ZSBrbm93IHRoaXMgaXMgcGFydCBvZiBhIGRpc3BsYXlFdmVudHMgY2FsbCwgZG9uJ3QgcXVlcnlTY3JvbGwvc2V0U2Nyb2xsXG5cdFx0XHRzY3JvbGxTdGF0ZSA9IHRoaXMucXVlcnlTY3JvbGwoKTtcblxuXHRcdFx0dGhpcy50cmlnZ2VyRXZlbnRVbnJlbmRlcigpO1xuXHRcdFx0aWYgKHRoaXMuZGVzdHJveUV2ZW50cykge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3lFdmVudHMoKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyRXZlbnRzKCk7XG5cdFx0XHR0aGlzLnNldFNjcm9sbChzY3JvbGxTdGF0ZSk7XG5cdFx0XHR0aGlzLmlzRXZlbnRzUmVuZGVyZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBldmVudHMgb250byB0aGUgdmlldy5cblx0cmVuZGVyRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbW92ZXMgZXZlbnQgZWxlbWVudHMgZnJvbSB0aGUgdmlldy5cblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gU2lnbmFscyB0aGF0IGFsbCBldmVudHMgaGF2ZSBiZWVuIHJlbmRlcmVkXG5cdHRyaWdnZXJFdmVudFJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdHRoaXMudHJpZ2dlcignZXZlbnRBZnRlclJlbmRlcicsIHNlZy5ldmVudCwgc2VnLmV2ZW50LCBzZWcuZWwpO1xuXHRcdH0pO1xuXHRcdHRoaXMudHJpZ2dlcignZXZlbnRBZnRlckFsbFJlbmRlcicpO1xuXHR9LFxuXG5cblx0Ly8gU2lnbmFscyB0aGF0IGFsbCBldmVudCBlbGVtZW50cyBhcmUgYWJvdXQgdG8gYmUgcmVtb3ZlZFxuXHR0cmlnZ2VyRXZlbnRVbnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdHRoaXMudHJpZ2dlcignZXZlbnREZXN0cm95Jywgc2VnLmV2ZW50LCBzZWcuZXZlbnQsIHNlZy5lbCk7XG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCBhbmQgdGhlIGRlZmF1bHQgZWxlbWVudCB1c2VkIGZvciByZW5kZXJpbmcsIHJldHVybnMgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYWN0dWFsbHkgYmUgdXNlZC5cblx0Ly8gQmFzaWNhbGx5IHJ1bnMgZXZlbnRzIGFuZCBlbGVtZW50cyB0aHJvdWdoIHRoZSBldmVudFJlbmRlciBob29rLlxuXHRyZXNvbHZlRXZlbnRFbDogZnVuY3Rpb24oZXZlbnQsIGVsKSB7XG5cdFx0dmFyIGN1c3RvbSA9IHRoaXMudHJpZ2dlcignZXZlbnRSZW5kZXInLCBldmVudCwgZXZlbnQsIGVsKTtcblxuXHRcdGlmIChjdXN0b20gPT09IGZhbHNlKSB7IC8vIG1lYW5zIGRvbid0IHJlbmRlciBhdCBhbGxcblx0XHRcdGVsID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY3VzdG9tICYmIGN1c3RvbSAhPT0gdHJ1ZSkge1xuXHRcdFx0ZWwgPSAkKGN1c3RvbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsO1xuXHR9LFxuXG5cblx0Ly8gSGlkZXMgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcblx0c2hvd0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xuXHRcdH0sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIFNob3dzIGFsbCByZW5kZXJlZCBldmVudCBzZWdtZW50cyBsaW5rZWQgdG8gdGhlIGdpdmVuIGV2ZW50XG5cdGhpZGVFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0c2VnLmVsLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcblx0XHR9LCBldmVudCk7XG5cdH0sXG5cblxuXHQvLyBJdGVyYXRlcyB0aHJvdWdoIGV2ZW50IHNlZ21lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkIChoYXZlIGFuIGVsKS4gR29lcyB0aHJvdWdoIGFsbCBieSBkZWZhdWx0LlxuXHQvLyBJZiB0aGUgb3B0aW9uYWwgYGV2ZW50YCBhcmd1bWVudCBpcyBzcGVjaWZpZWQsIG9ubHkgaXRlcmF0ZXMgdGhyb3VnaCBzZWdtZW50cyBsaW5rZWQgdG8gdGhhdCBldmVudC5cblx0Ly8gVGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSB0aGUgdmlldy5cblx0cmVuZGVyZWRFdmVudFNlZ0VhY2g6IGZ1bmN0aW9uKGZ1bmMsIGV2ZW50KSB7XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLmdldEV2ZW50U2VncygpO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghZXZlbnQgfHwgc2Vnc1tpXS5ldmVudC5faWQgPT09IGV2ZW50Ll9pZCkge1xuXHRcdFx0XHRpZiAoc2Vnc1tpXS5lbCkge1xuXHRcdFx0XHRcdGZ1bmMuY2FsbCh0aGlzLCBzZWdzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbGwgdGhlIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBmb3IgdGhlIHZpZXdcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdFx0cmV0dXJuIFtdO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgRHJhZy1uLURyb3Bcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIGRyYWdnZWQgYnkgdGhlIHVzZXJcblx0aXNFdmVudERyYWdnYWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIGZpcnN0RGVmaW5lZChcblx0XHRcdGV2ZW50LnN0YXJ0RWRpdGFibGUsXG5cdFx0XHRzb3VyY2Uuc3RhcnRFZGl0YWJsZSxcblx0XHRcdHRoaXMub3B0KCdldmVudFN0YXJ0RWRpdGFibGUnKSxcblx0XHRcdGV2ZW50LmVkaXRhYmxlLFxuXHRcdFx0c291cmNlLmVkaXRhYmxlLFxuXHRcdFx0dGhpcy5vcHQoJ2VkaXRhYmxlJylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpbiB0aGUgdmlldyBpcyBkcm9wcGVkIG9udG8gbmV3IGxvY2F0aW9uLlxuXHQvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXG5cdHJlcG9ydEV2ZW50RHJvcDogZnVuY3Rpb24oZXZlbnQsIGRyb3BMb2NhdGlvbiwgbGFyZ2VVbml0LCBlbCwgZXYpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuXHRcdHZhciBtdXRhdGVSZXN1bHQgPSBjYWxlbmRhci5tdXRhdGVFdmVudChldmVudCwgZHJvcExvY2F0aW9uLCBsYXJnZVVuaXQpO1xuXHRcdHZhciB1bmRvRnVuYyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bXV0YXRlUmVzdWx0LnVuZG8oKTtcblx0XHRcdGNhbGVuZGFyLnJlcG9ydEV2ZW50Q2hhbmdlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMudHJpZ2dlckV2ZW50RHJvcChldmVudCwgbXV0YXRlUmVzdWx0LmRhdGVEZWx0YSwgdW5kb0Z1bmMsIGVsLCBldik7XG5cdFx0Y2FsZW5kYXIucmVwb3J0RXZlbnRDaGFuZ2UoKTsgLy8gd2lsbCByZXJlbmRlciBldmVudHNcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGV2ZW50LWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcblx0dHJpZ2dlckV2ZW50RHJvcDogZnVuY3Rpb24oZXZlbnQsIGRhdGVEZWx0YSwgdW5kb0Z1bmMsIGVsLCBldikge1xuXHRcdHRoaXMudHJpZ2dlcignZXZlbnREcm9wJywgZWxbMF0sIGV2ZW50LCBkYXRlRGVsdGEsIHVuZG9GdW5jLCBldiwge30pOyAvLyB7fSA9IGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZy1uLURyb3Bcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCwgdmlhIGpRdWVyeSBVSSwgaGFzIGJlZW4gZHJvcHBlZCBvbnRvIHRoZSBjYWxlbmRhci5cblx0Ly8gYG1ldGFgIGlzIHRoZSBwYXJzZWQgZGF0YSB0aGF0IGhhcyBiZWVuIGVtYmVkZGVkIGludG8gdGhlIGRyYWdnaW5nIGV2ZW50LlxuXHQvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXG5cdHJlcG9ydEV4dGVybmFsRHJvcDogZnVuY3Rpb24obWV0YSwgZHJvcExvY2F0aW9uLCBlbCwgZXYsIHVpKSB7XG5cdFx0dmFyIGV2ZW50UHJvcHMgPSBtZXRhLmV2ZW50UHJvcHM7XG5cdFx0dmFyIGV2ZW50SW5wdXQ7XG5cdFx0dmFyIGV2ZW50O1xuXG5cdFx0Ly8gVHJ5IHRvIGJ1aWxkIGFuIGV2ZW50IG9iamVjdCBhbmQgcmVuZGVyIGl0LiBUT0RPOiBkZWNvdXBsZSB0aGUgdHdvXG5cdFx0aWYgKGV2ZW50UHJvcHMpIHtcblx0XHRcdGV2ZW50SW5wdXQgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcywgZHJvcExvY2F0aW9uKTtcblx0XHRcdGV2ZW50ID0gdGhpcy5jYWxlbmRhci5yZW5kZXJFdmVudChldmVudElucHV0LCBtZXRhLnN0aWNrKVswXTsgLy8gcmVuZGVyRXZlbnQgcmV0dXJucyBhbiBhcnJheVxuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlckV4dGVybmFsRHJvcChldmVudCwgZHJvcExvY2F0aW9uLCBlbCwgZXYsIHVpKTtcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGV4dGVybmFsLWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcblx0dHJpZ2dlckV4dGVybmFsRHJvcDogZnVuY3Rpb24oZXZlbnQsIGRyb3BMb2NhdGlvbiwgZWwsIGV2LCB1aSkge1xuXG5cdFx0Ly8gdHJpZ2dlciAnZHJvcCcgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGVsZW1lbnQgcmVwcmVzZW50cyBhbiBldmVudFxuXHRcdHRoaXMudHJpZ2dlcignZHJvcCcsIGVsWzBdLCBkcm9wTG9jYXRpb24uc3RhcnQsIGV2LCB1aSk7XG5cblx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdHRoaXMudHJpZ2dlcignZXZlbnRSZWNlaXZlJywgbnVsbCwgZXZlbnQpOyAvLyBzaWduYWwgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRHJhZy1uLURyb3AgUmVuZGVyaW5nIChmb3IgYm90aCBldmVudHMgYW5kIGV4dGVybmFsIGVsZW1lbnRzKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgZXZlbnQgb3IgZXh0ZXJuYWwtZWxlbWVudCBkcmFnIG92ZXIgdGhlIGdpdmVuIGRyb3Agem9uZS5cblx0Ly8gSWYgYW4gZXh0ZXJuYWwtZWxlbWVudCwgc2VnIHdpbGwgYmUgYG51bGxgLlxuXHQvLyBNdXN0IHJldHVybiBlbGVtZW50cyB1c2VkIGZvciBhbnkgbW9jayBldmVudHMuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGRyb3BMb2NhdGlvbiwgc2VnKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwtZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIEV2ZW50IFJlc2l6aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIHN0YXJ0aW5nIGVkZ2Vcblx0aXNFdmVudFJlc2l6YWJsZUZyb21TdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHQoJ2V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0JykgJiYgdGhpcy5pc0V2ZW50UmVzaXphYmxlKGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgZnJvbSBpdHMgZW5kaW5nIGVkZ2Vcblx0aXNFdmVudFJlc2l6YWJsZUZyb21FbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNFdmVudFJlc2l6YWJsZShldmVudCk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGJ5IHRoZSB1c2VyIGF0IGFsbFxuXHRpc0V2ZW50UmVzaXphYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwge307XG5cblx0XHRyZXR1cm4gZmlyc3REZWZpbmVkKFxuXHRcdFx0ZXZlbnQuZHVyYXRpb25FZGl0YWJsZSxcblx0XHRcdHNvdXJjZS5kdXJhdGlvbkVkaXRhYmxlLFxuXHRcdFx0dGhpcy5vcHQoJ2V2ZW50RHVyYXRpb25FZGl0YWJsZScpLFxuXHRcdFx0ZXZlbnQuZWRpdGFibGUsXG5cdFx0XHRzb3VyY2UuZWRpdGFibGUsXG5cdFx0XHR0aGlzLm9wdCgnZWRpdGFibGUnKVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGluIHRoZSB2aWV3IGhhcyBiZWVuIHJlc2l6ZWQgdG8gYSBuZXcgbGVuZ3RoXG5cdHJlcG9ydEV2ZW50UmVzaXplOiBmdW5jdGlvbihldmVudCwgcmVzaXplTG9jYXRpb24sIGxhcmdlVW5pdCwgZWwsIGV2KSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcblx0XHR2YXIgbXV0YXRlUmVzdWx0ID0gY2FsZW5kYXIubXV0YXRlRXZlbnQoZXZlbnQsIHJlc2l6ZUxvY2F0aW9uLCBsYXJnZVVuaXQpO1xuXHRcdHZhciB1bmRvRnVuYyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bXV0YXRlUmVzdWx0LnVuZG8oKTtcblx0XHRcdGNhbGVuZGFyLnJlcG9ydEV2ZW50Q2hhbmdlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMudHJpZ2dlckV2ZW50UmVzaXplKGV2ZW50LCBtdXRhdGVSZXN1bHQuZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGVsLCBldik7XG5cdFx0Y2FsZW5kYXIucmVwb3J0RXZlbnRDaGFuZ2UoKTsgLy8gd2lsbCByZXJlbmRlciBldmVudHNcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGV2ZW50LXJlc2l6ZSBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxuXHR0cmlnZ2VyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50LCBkdXJhdGlvbkRlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdldmVudFJlc2l6ZScsIGVsWzBdLCBldmVudCwgZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGV2LCB7fSk7IC8vIHt9ID0ganF1aSBkdW1teVxuXHR9LFxuXG5cblx0LyogU2VsZWN0aW9uICh0aW1lIHJhbmdlKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2VsZWN0cyBhIGRhdGUgc3BhbiBvbiB0aGUgdmlldy4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIGJvdGggTW9tZW50cy5cblx0Ly8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnaW4gdGhlIGludGVyYWN0aW9uLlxuXHRzZWxlY3Q6IGZ1bmN0aW9uKHNwYW4sIGV2KSB7XG5cdFx0dGhpcy51bnNlbGVjdChldik7XG5cdFx0dGhpcy5yZW5kZXJTZWxlY3Rpb24oc3Bhbik7XG5cdFx0dGhpcy5yZXBvcnRTZWxlY3Rpb24oc3BhbiwgZXYpO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHRoZSBzZWxlY3Rpb25cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBhIG5ldyBzZWxlY3Rpb24gaXMgbWFkZS4gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXG5cdHJlcG9ydFNlbGVjdGlvbjogZnVuY3Rpb24oc3BhbiwgZXYpIHtcblx0XHR0aGlzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdHRoaXMudHJpZ2dlclNlbGVjdChzcGFuLCBldik7XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBoYW5kbGVycyB0byAnc2VsZWN0J1xuXHR0cmlnZ2VyU2VsZWN0OiBmdW5jdGlvbihzcGFuLCBldikge1xuXHRcdHRoaXMudHJpZ2dlcihcblx0XHRcdCdzZWxlY3QnLFxuXHRcdFx0bnVsbCxcblx0XHRcdHRoaXMuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShzcGFuLnN0YXJ0KSwgLy8gY29udmVydCB0byBjYWxlbmRhcidzIHR6IGZvciBleHRlcm5hbCBBUElcblx0XHRcdHRoaXMuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShzcGFuLmVuZCksIC8vIFwiXG5cdFx0XHRldlxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBVbmRvZXMgYSBzZWxlY3Rpb24uIHVwZGF0ZXMgaW4gdGhlIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cblx0Ly8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnYW4gdGhlIGludGVyYWN0aW9uLlxuXHR1bnNlbGVjdDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAodGhpcy5pc1NlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLmRlc3Ryb3lTZWxlY3Rpb24pIHtcblx0XHRcdFx0dGhpcy5kZXN0cm95U2VsZWN0aW9uKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51bnJlbmRlclNlbGVjdGlvbigpO1xuXHRcdFx0dGhpcy50cmlnZ2VyKCd1bnNlbGVjdCcsIG51bGwsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBzZWxlY3Rpb25cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogRXZlbnQgU2VsZWN0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRzZWxlY3RFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0ZWRFdmVudCB8fCB0aGlzLnNlbGVjdGVkRXZlbnQgIT09IGV2ZW50KSB7XG5cdFx0XHR0aGlzLnVuc2VsZWN0RXZlbnQoKTtcblx0XHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRcdHNlZy5lbC5hZGRDbGFzcygnZmMtc2VsZWN0ZWQnKTtcblx0XHRcdH0sIGV2ZW50KTtcblx0XHRcdHRoaXMuc2VsZWN0ZWRFdmVudCA9IGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXG5cdHVuc2VsZWN0RXZlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnNlbGVjdGVkRXZlbnQpIHtcblx0XHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRcdHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtc2VsZWN0ZWQnKTtcblx0XHRcdH0sIHRoaXMuc2VsZWN0ZWRFdmVudCk7XG5cdFx0XHR0aGlzLnNlbGVjdGVkRXZlbnQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdGlzRXZlbnRTZWxlY3RlZDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBldmVudCByZWZlcmVuY2VzIG1pZ2h0IGNoYW5nZSBvbiByZWZldGNoRXZlbnRzKCksIHdoaWxlIHNlbGVjdGVkRXZlbnQgZG9lc24ndCxcblx0XHQvLyBzbyBjb21wYXJlIElEc1xuXHRcdHJldHVybiB0aGlzLnNlbGVjdGVkRXZlbnQgJiYgdGhpcy5zZWxlY3RlZEV2ZW50Ll9pZCA9PT0gZXZlbnQuX2lkO1xuXHR9LFxuXG5cblx0LyogTW91c2UgLyBUb3VjaCBVbnNlbGVjdGluZyAodGltZSByYW5nZSAmIGV2ZW50IHVuc2VsZWN0aW9uKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBtb3ZlIGNvbnNpc3RlbnRseSB0byBkb3duL3N0YXJ0IG9yIHVwL2VuZD9cblx0Ly8gVE9ETzogZG9uJ3Qga2lsbCBwcmV2aW91cyBzZWxlY3Rpb24gaWYgdG91Y2ggc2Nyb2xsaW5nXG5cblxuXHRoYW5kbGVEb2N1bWVudE1vdXNlZG93bjogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3NVbnNlbGVjdChldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0cHJvY2Vzc1Vuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMucHJvY2Vzc1JhbmdlVW5zZWxlY3QoZXYpO1xuXHRcdHRoaXMucHJvY2Vzc0V2ZW50VW5zZWxlY3QoZXYpO1xuXHR9LFxuXG5cblx0cHJvY2Vzc1JhbmdlVW5zZWxlY3Q6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGlnbm9yZTtcblxuXHRcdC8vIGlzIHRoZXJlIGEgdGltZS1yYW5nZSBzZWxlY3Rpb24/XG5cdFx0aWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLm9wdCgndW5zZWxlY3RBdXRvJykpIHtcblx0XHRcdC8vIG9ubHkgdW5zZWxlY3QgaWYgdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBub3QgaWRlbnRpY2FsIHRvIG9yIGluc2lkZSBvZiBhbiAndW5zZWxlY3RDYW5jZWwnIGVsZW1lbnRcblx0XHRcdGlnbm9yZSA9IHRoaXMub3B0KCd1bnNlbGVjdENhbmNlbCcpO1xuXHRcdFx0aWYgKCFpZ25vcmUgfHwgISQoZXYudGFyZ2V0KS5jbG9zZXN0KGlnbm9yZSkubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMudW5zZWxlY3QoZXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdHByb2Nlc3NFdmVudFVuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLnNlbGVjdGVkRXZlbnQpIHtcblx0XHRcdGlmICghJChldi50YXJnZXQpLmNsb3Nlc3QoJy5mYy1zZWxlY3RlZCcpLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnVuc2VsZWN0RXZlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvKiBEYXkgQ2xpY2tcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdkYXlDbGljaydcblx0Ly8gU3BhbiBoYXMgc3RhcnQvZW5kIG9mIHRoZSBjbGlja2VkIGFyZWEuIE9ubHkgdGhlIHN0YXJ0IGlzIHVzZWZ1bC5cblx0dHJpZ2dlckRheUNsaWNrOiBmdW5jdGlvbihzcGFuLCBkYXlFbCwgZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoXG5cdFx0XHQnZGF5Q2xpY2snLFxuXHRcdFx0ZGF5RWwsXG5cdFx0XHR0aGlzLmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3Bhbi5zdGFydCksIC8vIGNvbnZlcnQgdG8gY2FsZW5kYXIncyB0aW1lem9uZSBmb3IgZXh0ZXJuYWwgQVBJXG5cdFx0XHRldlxuXHRcdCk7XG5cdH0sXG5cblxuXHQvKiBEYXRlIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG5cdGluaXRIaWRkZW5EYXlzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGlkZGVuRGF5cyA9IHRoaXMub3B0KCdoaWRkZW5EYXlzJykgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG5cdFx0dmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG5cdFx0dmFyIGRheUNudCA9IDA7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAodGhpcy5vcHQoJ3dlZWtlbmRzJykgPT09IGZhbHNlKSB7XG5cdFx0XHRoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhKGlzSGlkZGVuRGF5SGFzaFtpXSA9ICQuaW5BcnJheShpLCBoaWRkZW5EYXlzKSAhPT0gLTEpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZGF5Q250Kys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFkYXlDbnQpIHtcblx0XHRcdHRocm93ICdpbnZhbGlkIGhpZGRlbkRheXMnOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuXHRcdH1cblxuXHRcdHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuXHR9LFxuXG5cblx0Ly8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cblx0Ly8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBNb21lbnRcblx0aXNIaWRkZW5EYXk6IGZ1bmN0aW9uKGRheSkge1xuXHRcdGlmIChtb21lbnQuaXNNb21lbnQoZGF5KSkge1xuXHRcdFx0ZGF5ID0gZGF5LmRheSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcblx0fSxcblxuXG5cdC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cblx0Ly8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuXHQvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuXHQvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxuXHRza2lwSGlkZGVuRGF5czogZnVuY3Rpb24oZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xuXHRcdHZhciBvdXQgPSBkYXRlLmNsb25lKCk7XG5cdFx0aW5jID0gaW5jIHx8IDE7XG5cdFx0d2hpbGUgKFxuXHRcdFx0dGhpcy5pc0hpZGRlbkRheUhhc2hbKG91dC5kYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XVxuXHRcdCkge1xuXHRcdFx0b3V0LmFkZChpbmMsICdkYXlzJyk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIHRoZSBkYXRlIHJhbmdlIG9mIHRoZSBmdWxsIGRheXMgdGhlIGdpdmVuIHJhbmdlIHZpc3VhbGx5IGFwcGVhcnMgdG8gb2NjdXB5LlxuXHQvLyBSZXR1cm5zIGEgbmV3IHJhbmdlIG9iamVjdC5cblx0Y29tcHV0ZURheVJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHZhciBzdGFydERheSA9IHJhbmdlLnN0YXJ0LmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG5cdFx0dmFyIGVuZCA9IHJhbmdlLmVuZDtcblx0XHR2YXIgZW5kRGF5ID0gbnVsbDtcblx0XHR2YXIgZW5kVGltZU1TO1xuXG5cdFx0aWYgKGVuZCkge1xuXHRcdFx0ZW5kRGF5ID0gZW5kLmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2UgZXhjbHVzaXZlbHkgZW5kc1xuXHRcdFx0ZW5kVGltZU1TID0gK2VuZC50aW1lKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcblxuXHRcdFx0Ly8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuXHRcdFx0Ly8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBsZWF2aW5nIGl0IGFzIGluY2x1c2l2ZSB3aWxsIGNhdXNlIGl0IHRvIGV4Y2x1ZGUgYGVuZERheWAuXG5cdFx0XHRpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSB0aGlzLm5leHREYXlUaHJlc2hvbGQpIHtcblx0XHRcdFx0ZW5kRGF5LmFkZCgxLCAnZGF5cycpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIG5vIGVuZCB3YXMgc3BlY2lmaWVkLCBvciBpZiBpdCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCxcblx0XHQvLyBhc3NpZ24gdGhlIGRlZmF1bHQgZHVyYXRpb24gb2Ygb25lIGRheS5cblx0XHRpZiAoIWVuZCB8fCBlbmREYXkgPD0gc3RhcnREYXkpIHtcblx0XHRcdGVuZERheSA9IHN0YXJ0RGF5LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xuXHR9LFxuXG5cblx0Ly8gRG9lcyB0aGUgZ2l2ZW4gZXZlbnQgdmlzdWFsbHkgYXBwZWFyIHRvIG9jY3VweSBtb3JlIHRoYW4gb25lIGRheT9cblx0aXNNdWx0aURheUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciByYW5nZSA9IHRoaXMuY29tcHV0ZURheVJhbmdlKGV2ZW50KTsgLy8gZXZlbnQgaXMgcmFuZ2UtaXNoXG5cblx0XHRyZXR1cm4gcmFuZ2UuZW5kLmRpZmYocmFuZ2Uuc3RhcnQsICdkYXlzJykgPiAxO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKlxuRW1ib2RpZXMgYSBkaXYgdGhhdCBoYXMgcG90ZW50aWFsIHNjcm9sbGJhcnNcbiovXG52YXIgU2Nyb2xsZXIgPSBGQy5TY3JvbGxlciA9IENsYXNzLmV4dGVuZCh7XG5cblx0ZWw6IG51bGwsIC8vIHRoZSBndWFyYW50ZWVkIG91dGVyIGVsZW1lbnRcblx0c2Nyb2xsRWw6IG51bGwsIC8vIHRoZSBlbGVtZW50IHdpdGggdGhlIHNjcm9sbGJhcnNcblx0b3ZlcmZsb3dYOiBudWxsLFxuXHRvdmVyZmxvd1k6IG51bGwsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHRoaXMub3ZlcmZsb3dYID0gb3B0aW9ucy5vdmVyZmxvd1ggfHwgb3B0aW9ucy5vdmVyZmxvdyB8fCAnYXV0byc7XG5cdFx0dGhpcy5vdmVyZmxvd1kgPSBvcHRpb25zLm92ZXJmbG93WSB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcblx0fSxcblxuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbCA9IHRoaXMucmVuZGVyRWwoKTtcblx0XHR0aGlzLmFwcGx5T3ZlcmZsb3coKTtcblx0fSxcblxuXG5cdHJlbmRlckVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuc2Nyb2xsRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtc2Nyb2xsZXJcIj48L2Rpdj4nKSk7XG5cdH0sXG5cblxuXHQvLyBzZXRzIHRvIG5hdHVyYWwgaGVpZ2h0LCB1bmxvY2tzIG92ZXJmbG93XG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNldEhlaWdodCgnYXV0bycpO1xuXHRcdHRoaXMuYXBwbHlPdmVyZmxvdygpO1xuXHR9LFxuXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbC5yZW1vdmUoKTtcblx0fSxcblxuXG5cdC8vIE92ZXJmbG93XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRhcHBseU92ZXJmbG93OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNjcm9sbEVsLmNzcyh7XG5cdFx0XHQnb3ZlcmZsb3cteCc6IHRoaXMub3ZlcmZsb3dYLFxuXHRcdFx0J292ZXJmbG93LXknOiB0aGlzLm92ZXJmbG93WVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gQ2F1c2VzIGFueSAnYXV0bycgb3ZlcmZsb3cgdmFsdWVzIHRvIHJlc29sdmVzIHRvICdzY3JvbGwnIG9yICdoaWRkZW4nLlxuXHQvLyBVc2VmdWwgZm9yIHByZXNlcnZpbmcgc2Nyb2xsYmFyIHdpZHRocyByZWdhcmRsZXNzIG9mIGZ1dHVyZSByZXNpemVzLlxuXHQvLyBDYW4gcGFzcyBpbiBzY3JvbGxiYXJXaWR0aHMgZm9yIG9wdGltaXphdGlvbi5cblx0bG9ja092ZXJmbG93OiBmdW5jdGlvbihzY3JvbGxiYXJXaWR0aHMpIHtcblx0XHR2YXIgb3ZlcmZsb3dYID0gdGhpcy5vdmVyZmxvd1g7XG5cdFx0dmFyIG92ZXJmbG93WSA9IHRoaXMub3ZlcmZsb3dZO1xuXG5cdFx0c2Nyb2xsYmFyV2lkdGhzID0gc2Nyb2xsYmFyV2lkdGhzIHx8IHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG5cblx0XHRpZiAob3ZlcmZsb3dYID09PSAnYXV0bycpIHtcblx0XHRcdG92ZXJmbG93WCA9IChcblx0XHRcdFx0XHRzY3JvbGxiYXJXaWR0aHMudG9wIHx8IHNjcm9sbGJhcldpZHRocy5ib3R0b20gfHwgLy8gaG9yaXpvbnRhbCBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cblx0XHRcdFx0XHR0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbFdpZHRoIC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50V2lkdGhcblx0XHRcdFx0XHRcdC8vIHN1YnRyYWN0IDEgYmVjYXVzZSBvZiBJRSBvZmYtYnktb25lIGlzc3VlXG5cdFx0XHRcdCkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xuXHRcdH1cblxuXHRcdGlmIChvdmVyZmxvd1kgPT09ICdhdXRvJykge1xuXHRcdFx0b3ZlcmZsb3dZID0gKFxuXHRcdFx0XHRcdHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCB8fCAvLyB2ZXJ0aWNhbCBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cblx0XHRcdFx0XHR0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbEhlaWdodCAtIDEgPiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudEhlaWdodFxuXHRcdFx0XHRcdFx0Ly8gc3VidHJhY3QgMSBiZWNhdXNlIG9mIElFIG9mZi1ieS1vbmUgaXNzdWVcblx0XHRcdFx0KSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxFbC5jc3MoeyAnb3ZlcmZsb3cteCc6IG92ZXJmbG93WCwgJ292ZXJmbG93LXknOiBvdmVyZmxvd1kgfSk7XG5cdH0sXG5cblxuXHQvLyBHZXR0ZXJzIC8gU2V0dGVyc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLnNjcm9sbEVsLmhlaWdodChoZWlnaHQpO1xuXHR9LFxuXG5cblx0Z2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AoKTtcblx0fSxcblxuXG5cdHNldFNjcm9sbFRvcDogZnVuY3Rpb24odG9wKSB7XG5cdFx0dGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AodG9wKTtcblx0fSxcblxuXG5cdGdldENsaWVudFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aDtcblx0fSxcblxuXG5cdGdldENsaWVudEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0O1xuXHR9LFxuXG5cblx0Z2V0U2Nyb2xsYmFyV2lkdGhzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0U2Nyb2xsYmFyV2lkdGhzKHRoaXMuc2Nyb2xsRWwpO1xuXHR9XG5cbn0pO1xuXG47O1xuXG52YXIgQ2FsZW5kYXIgPSBGQy5DYWxlbmRhciA9IENsYXNzLmV4dGVuZCh7XG5cblx0ZGlyRGVmYXVsdHM6IG51bGwsIC8vIG9wdGlvbiBkZWZhdWx0cyByZWxhdGVkIHRvIExUUiBvciBSVExcblx0bGFuZ0RlZmF1bHRzOiBudWxsLCAvLyBvcHRpb24gZGVmYXVsdHMgcmVsYXRlZCB0byBjdXJyZW50IGxvY2FsZVxuXHRvdmVycmlkZXM6IG51bGwsIC8vIG9wdGlvbiBvdmVycmlkZXMgZ2l2ZW4gdG8gdGhlIGZ1bGxDYWxlbmRhciBjb25zdHJ1Y3RvclxuXHRkeW5hbWljT3ZlcnJpZGVzOiBudWxsLCAvLyBvcHRpb25zIHNldCB3aXRoIGR5bmFtaWMgc2V0dGVyIG1ldGhvZC4gaGlnaGVyIHByZWNlZGVuY2UgdGhhbiB2aWV3IG92ZXJyaWRlcy5cblx0b3B0aW9uczogbnVsbCwgLy8gYWxsIGRlZmF1bHRzIGNvbWJpbmVkIHdpdGggb3ZlcnJpZGVzXG5cdHZpZXdTcGVjQ2FjaGU6IG51bGwsIC8vIGNhY2hlIG9mIHZpZXcgZGVmaW5pdGlvbnNcblx0dmlldzogbnVsbCwgLy8gY3VycmVudCBWaWV3IG9iamVjdFxuXHRoZWFkZXI6IG51bGwsXG5cdGxvYWRpbmdMZXZlbDogMCwgLy8gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBsb2FkaW5nIHRhc2tzXG5cblxuXHQvLyBhIGxvdCBvZiB0aGlzIGNsYXNzJyBPT1AgbG9naWMgaXMgc2NvcGVkIHdpdGhpbiB0aGlzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLFxuXHQvLyBidXQgaW4gdGhlIGZ1dHVyZSwgd3JpdGUgaW5kaXZpZHVhbCBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGUuXG5cdGNvbnN0cnVjdG9yOiBDYWxlbmRhcl9jb25zdHJ1Y3RvcixcblxuXG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uIGxvZ2ljIGFmdGVyIHRoZSBjb25zdHJ1Y3RvciBoYXMgYmVlbiBjYWxsZWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIG9wdGlvbnMgaGFzaCBmb3IgdGhlIGNhbGVuZGFyIGFuZCBhc3NpZ25zIHRvIGB0aGlzLm9wdGlvbnNgLlxuXHQvLyBBc3N1bWVzIHRoaXMub3ZlcnJpZGVzIGFuZCB0aGlzLmR5bmFtaWNPdmVycmlkZXMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuXG5cdHBvcHVsYXRlT3B0aW9uc0hhc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYW5nLCBsYW5nRGVmYXVsdHM7XG5cdFx0dmFyIGlzUlRMLCBkaXJEZWZhdWx0cztcblxuXHRcdGxhbmcgPSBmaXJzdERlZmluZWQoIC8vIGV4cGxpY2l0IGxhbmcgb3B0aW9uIGdpdmVuP1xuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmxhbmcsXG5cdFx0XHR0aGlzLm92ZXJyaWRlcy5sYW5nXG5cdFx0KTtcblx0XHRsYW5nRGVmYXVsdHMgPSBsYW5nT3B0aW9uSGFzaFtsYW5nXTtcblx0XHRpZiAoIWxhbmdEZWZhdWx0cykgeyAvLyBleHBsaWNpdCBsYW5nIG9wdGlvbiBub3QgZ2l2ZW4gb3IgaW52YWxpZD9cblx0XHRcdGxhbmcgPSBDYWxlbmRhci5kZWZhdWx0cy5sYW5nO1xuXHRcdFx0bGFuZ0RlZmF1bHRzID0gbGFuZ09wdGlvbkhhc2hbbGFuZ10gfHwge307XG5cdFx0fVxuXG5cdFx0aXNSVEwgPSBmaXJzdERlZmluZWQoIC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmlzUlRMLFxuXHRcdFx0dGhpcy5vdmVycmlkZXMuaXNSVEwsXG5cdFx0XHRsYW5nRGVmYXVsdHMuaXNSVEwsXG5cdFx0XHRDYWxlbmRhci5kZWZhdWx0cy5pc1JUTFxuXHRcdCk7XG5cdFx0ZGlyRGVmYXVsdHMgPSBpc1JUTCA/IENhbGVuZGFyLnJ0bERlZmF1bHRzIDoge307XG5cblx0XHR0aGlzLmRpckRlZmF1bHRzID0gZGlyRGVmYXVsdHM7XG5cdFx0dGhpcy5sYW5nRGVmYXVsdHMgPSBsYW5nRGVmYXVsdHM7XG5cdFx0dGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFsgLy8gbWVyZ2UgZGVmYXVsdHMgYW5kIG92ZXJyaWRlcy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdFx0Q2FsZW5kYXIuZGVmYXVsdHMsIC8vIGdsb2JhbCBkZWZhdWx0c1xuXHRcdFx0ZGlyRGVmYXVsdHMsXG5cdFx0XHRsYW5nRGVmYXVsdHMsXG5cdFx0XHR0aGlzLm92ZXJyaWRlcyxcblx0XHRcdHRoaXMuZHluYW1pY092ZXJyaWRlc1xuXHRcdF0pO1xuXHRcdHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyh0aGlzLm9wdGlvbnMpOyAvLyBmaWxsIGluIGdhcHMgd2l0aCBjb21wdXRlZCBvcHRpb25zXG5cdH0sXG5cblxuXHQvLyBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0byBjcmVhdGUgYSB2aWV3LiBXaWxsIHVzZSBhIGNhY2hlLlxuXHRnZXRWaWV3U3BlYzogZnVuY3Rpb24odmlld1R5cGUpIHtcblx0XHR2YXIgY2FjaGUgPSB0aGlzLnZpZXdTcGVjQ2FjaGU7XG5cblx0XHRyZXR1cm4gY2FjaGVbdmlld1R5cGVdIHx8IChjYWNoZVt2aWV3VHlwZV0gPSB0aGlzLmJ1aWxkVmlld1NwZWModmlld1R5cGUpKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cblx0Ly8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuXHRnZXRVbml0Vmlld1NwZWM6IGZ1bmN0aW9uKHVuaXQpIHtcblx0XHR2YXIgdmlld1R5cGVzO1xuXHRcdHZhciBpO1xuXHRcdHZhciBzcGVjO1xuXG5cdFx0aWYgKCQuaW5BcnJheSh1bml0LCBpbnRlcnZhbFVuaXRzKSAhPSAtMSkge1xuXG5cdFx0XHQvLyBwdXQgdmlld3MgdGhhdCBoYXZlIGJ1dHRvbnMgZmlyc3QuIHRoZXJlIHdpbGwgYmUgZHVwbGljYXRlcywgYnV0IG9oIHdlbGxcblx0XHRcdHZpZXdUeXBlcyA9IHRoaXMuaGVhZGVyLmdldFZpZXdzV2l0aEJ1dHRvbnMoKTtcblx0XHRcdCQuZWFjaChGQy52aWV3cywgZnVuY3Rpb24odmlld1R5cGUpIHsgLy8gYWxsIHZpZXdzXG5cdFx0XHRcdHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNwZWMgPSB0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlc1tpXSk7XG5cdFx0XHRcdGlmIChzcGVjKSB7XG5cdFx0XHRcdFx0aWYgKHNwZWMuc2luZ2xlVW5pdCA9PSB1bml0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3BlYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gb24gaG93IHRvIGNyZWF0ZSBhIGdpdmVuIHZpZXdcblx0YnVpbGRWaWV3U3BlYzogZnVuY3Rpb24ocmVxdWVzdGVkVmlld1R5cGUpIHtcblx0XHR2YXIgdmlld092ZXJyaWRlcyA9IHRoaXMub3ZlcnJpZGVzLnZpZXdzIHx8IHt9O1xuXHRcdHZhciBzcGVjQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxuXHRcdHZhciBkZWZhdWx0c0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcblx0XHR2YXIgb3ZlcnJpZGVzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxuXHRcdHZhciB2aWV3VHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xuXHRcdHZhciBzcGVjOyAvLyBmb3IgdGhlIHZpZXdcblx0XHR2YXIgb3ZlcnJpZGVzOyAvLyBmb3IgdGhlIHZpZXdcblx0XHR2YXIgZHVyYXRpb247XG5cdFx0dmFyIHVuaXQ7XG5cblx0XHQvLyBpdGVyYXRlIGZyb20gdGhlIHNwZWNpZmljIHZpZXcgZGVmaW5pdGlvbiB0byBhIG1vcmUgZ2VuZXJhbCBvbmUgdW50aWwgd2UgaGl0IGFuIGFjdHVhbCBWaWV3IGNsYXNzXG5cdFx0d2hpbGUgKHZpZXdUeXBlKSB7XG5cdFx0XHRzcGVjID0gZmNWaWV3c1t2aWV3VHlwZV07XG5cdFx0XHRvdmVycmlkZXMgPSB2aWV3T3ZlcnJpZGVzW3ZpZXdUeXBlXTtcblx0XHRcdHZpZXdUeXBlID0gbnVsbDsgLy8gY2xlYXIuIG1pZ2h0IHJlcG9wdWxhdGUgZm9yIGFub3RoZXIgaXRlcmF0aW9uXG5cblx0XHRcdGlmICh0eXBlb2Ygc3BlYyA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBUT0RPOiBkZXByZWNhdGVcblx0XHRcdFx0c3BlYyA9IHsgJ2NsYXNzJzogc3BlYyB9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3BlYykge1xuXHRcdFx0XHRzcGVjQ2hhaW4udW5zaGlmdChzcGVjKTtcblx0XHRcdFx0ZGVmYXVsdHNDaGFpbi51bnNoaWZ0KHNwZWMuZGVmYXVsdHMgfHwge30pO1xuXHRcdFx0XHRkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IHNwZWMuZHVyYXRpb247XG5cdFx0XHRcdHZpZXdUeXBlID0gdmlld1R5cGUgfHwgc3BlYy50eXBlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3ZlcnJpZGVzKSB7XG5cdFx0XHRcdG92ZXJyaWRlc0NoYWluLnVuc2hpZnQob3ZlcnJpZGVzKTsgLy8gdmlldy1zcGVjaWZpYyBvcHRpb24gaGFzaGVzIGhhdmUgb3B0aW9ucyBhdCB6ZXJvLWxldmVsXG5cdFx0XHRcdGR1cmF0aW9uID0gZHVyYXRpb24gfHwgb3ZlcnJpZGVzLmR1cmF0aW9uO1xuXHRcdFx0XHR2aWV3VHlwZSA9IHZpZXdUeXBlIHx8IG92ZXJyaWRlcy50eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNwZWMgPSBtZXJnZVByb3BzKHNwZWNDaGFpbik7XG5cdFx0c3BlYy50eXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XG5cdFx0aWYgKCFzcGVjWydjbGFzcyddKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGR1cmF0aW9uKSB7XG5cdFx0XHRkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbik7XG5cdFx0XHRpZiAoZHVyYXRpb24udmFsdWVPZigpKSB7IC8vIHZhbGlkP1xuXHRcdFx0XHRzcGVjLmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0XHRcdHVuaXQgPSBjb21wdXRlSW50ZXJ2YWxVbml0KGR1cmF0aW9uKTtcblxuXHRcdFx0XHQvLyB2aWV3IGlzIGEgc2luZ2xlLXVuaXQgZHVyYXRpb24sIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIlxuXHRcdFx0XHQvLyBpbmNvcnBvcmF0ZSBvcHRpb25zIGZvciB0aGlzLiBsb3dlc3QgcHJpb3JpdHlcblx0XHRcdFx0aWYgKGR1cmF0aW9uLmFzKHVuaXQpID09PSAxKSB7XG5cdFx0XHRcdFx0c3BlYy5zaW5nbGVVbml0ID0gdW5pdDtcblx0XHRcdFx0XHRvdmVycmlkZXNDaGFpbi51bnNoaWZ0KHZpZXdPdmVycmlkZXNbdW5pdF0gfHwge30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3BlYy5kZWZhdWx0cyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0c0NoYWluKTtcblx0XHRzcGVjLm92ZXJyaWRlcyA9IG1lcmdlT3B0aW9ucyhvdmVycmlkZXNDaGFpbik7XG5cblx0XHR0aGlzLmJ1aWxkVmlld1NwZWNPcHRpb25zKHNwZWMpO1xuXHRcdHRoaXMuYnVpbGRWaWV3U3BlY0J1dHRvblRleHQoc3BlYywgcmVxdWVzdGVkVmlld1R5cGUpO1xuXG5cdFx0cmV0dXJuIHNwZWM7XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBvcHRpb25zIG9iamVjdCBmcm9tIGl0cyBhbHJlYWR5LWFzc2lnbmVkIGRlZmF1bHRzIGFuZCBvdmVycmlkZXNcblx0YnVpbGRWaWV3U3BlY09wdGlvbnM6IGZ1bmN0aW9uKHNwZWMpIHtcblx0XHRzcGVjLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoWyAvLyBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxuXHRcdFx0Q2FsZW5kYXIuZGVmYXVsdHMsIC8vIGdsb2JhbCBkZWZhdWx0c1xuXHRcdFx0c3BlYy5kZWZhdWx0cywgLy8gdmlldydzIGRlZmF1bHRzIChmcm9tIFZpZXdTdWJjbGFzcy5kZWZhdWx0cylcblx0XHRcdHRoaXMuZGlyRGVmYXVsdHMsXG5cdFx0XHR0aGlzLmxhbmdEZWZhdWx0cywgLy8gbG9jYWxlIGFuZCBkaXIgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdmlldydzIGRlZmF1bHRzIVxuXHRcdFx0dGhpcy5vdmVycmlkZXMsIC8vIGNhbGVuZGFyJ3Mgb3ZlcnJpZGVzIChvcHRpb25zIGdpdmVuIHRvIGNvbnN0cnVjdG9yKVxuXHRcdFx0c3BlYy5vdmVycmlkZXMsIC8vIHZpZXcncyBvdmVycmlkZXMgKHZpZXctc3BlY2lmaWMgb3B0aW9ucylcblx0XHRcdHRoaXMuZHluYW1pY092ZXJyaWRlcyAvLyBkeW5hbWljYWxseSBzZXQgdmlhIHNldHRlci4gaGlnaGVzdCBwcmVjZWRlbmNlXG5cdFx0XSk7XG5cdFx0cG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKHNwZWMub3B0aW9ucyk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhbmQgYXNzaWducyBhIHZpZXcgc3BlYydzIGJ1dHRvblRleHQtcmVsYXRlZCBvcHRpb25zXG5cdGJ1aWxkVmlld1NwZWNCdXR0b25UZXh0OiBmdW5jdGlvbihzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSkge1xuXG5cdFx0Ly8gZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIHBvc3NpYmxlIGBidXR0b25UZXh0YCBoYXNoLCBsb29rdXAgdGhlIGJ1dHRvblRleHQgZm9yIHRoZVxuXHRcdC8vIHJlcXVlc3RlZCB2aWV3LCBmYWxsaW5nIGJhY2sgdG8gYSBnZW5lcmljIHVuaXQgZW50cnkgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXG5cdFx0ZnVuY3Rpb24gcXVlcnlCdXR0b25UZXh0KG9wdGlvbnMpIHtcblx0XHRcdHZhciBidXR0b25UZXh0ID0gb3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xuXHRcdFx0cmV0dXJuIGJ1dHRvblRleHRbcmVxdWVzdGVkVmlld1R5cGVdIHx8XG5cdFx0XHRcdChzcGVjLnNpbmdsZVVuaXQgPyBidXR0b25UZXh0W3NwZWMuc2luZ2xlVW5pdF0gOiBudWxsKTtcblx0XHR9XG5cblx0XHQvLyBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eVxuXHRcdHNwZWMuYnV0dG9uVGV4dE92ZXJyaWRlID1cblx0XHRcdHF1ZXJ5QnV0dG9uVGV4dCh0aGlzLmR5bmFtaWNPdmVycmlkZXMpIHx8XG5cdFx0XHRxdWVyeUJ1dHRvblRleHQodGhpcy5vdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2Vcblx0XHRcdHNwZWMub3ZlcnJpZGVzLmJ1dHRvblRleHQ7IC8vIGBidXR0b25UZXh0YCBmb3Igdmlldy1zcGVjaWZpYyBvcHRpb25zIGlzIGEgc3RyaW5nXG5cblx0XHQvLyBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eS4gbWlycm9ycyBidWlsZFZpZXdTcGVjT3B0aW9uc1xuXHRcdHNwZWMuYnV0dG9uVGV4dERlZmF1bHQgPVxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMubGFuZ0RlZmF1bHRzKSB8fFxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMuZGlyRGVmYXVsdHMpIHx8XG5cdFx0XHRzcGVjLmRlZmF1bHRzLmJ1dHRvblRleHQgfHwgLy8gYSBzaW5nbGUgc3RyaW5nLiBmcm9tIFZpZXdTdWJjbGFzcy5kZWZhdWx0c1xuXHRcdFx0cXVlcnlCdXR0b25UZXh0KENhbGVuZGFyLmRlZmF1bHRzKSB8fFxuXHRcdFx0KHNwZWMuZHVyYXRpb24gPyB0aGlzLmh1bWFuaXplRHVyYXRpb24oc3BlYy5kdXJhdGlvbikgOiBudWxsKSB8fCAvLyBsaWtlIFwiMyBkYXlzXCJcblx0XHRcdHJlcXVlc3RlZFZpZXdUeXBlOyAvLyBmYWxsIGJhY2sgdG8gZ2l2ZW4gdmlldyBuYW1lXG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxuXHRpbnN0YW50aWF0ZVZpZXc6IGZ1bmN0aW9uKHZpZXdUeXBlKSB7XG5cdFx0dmFyIHNwZWMgPSB0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKTtcblxuXHRcdHJldHVybiBuZXcgc3BlY1snY2xhc3MnXSh0aGlzLCB2aWV3VHlwZSwgc3BlYy5vcHRpb25zLCBzcGVjLmR1cmF0aW9uKTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIHZpZXcgaXMgb2theSB0byBpbnN0YW50aWF0ZSBhdCBzb21lIHBvaW50XG5cdGlzVmFsaWRWaWV3VHlwZTogZnVuY3Rpb24odmlld1R5cGUpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKSk7XG5cdH0sXG5cblxuXHQvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBiZWdpbnNcblx0cHVzaExvYWRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghKHRoaXMubG9hZGluZ0xldmVsKyspKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRpbmcnLCBudWxsLCB0cnVlLCB0aGlzLnZpZXcpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGNvbXBsZXRlc1xuXHRwb3BMb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoISgtLXRoaXMubG9hZGluZ0xldmVsKSkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkaW5nJywgbnVsbCwgZmFsc2UsIHRoaXMudmlldyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYXJndW1lbnRzIHRvIHRoZSBzZWxlY3QgbWV0aG9kIGluIHRoZSBBUEksIHJldHVybnMgYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgaW5mbylcblx0YnVpbGRTZWxlY3RTcGFuOiBmdW5jdGlvbih6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLm1vbWVudCh6b25lZFN0YXJ0SW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdHZhciBlbmQ7XG5cblx0XHRpZiAoem9uZWRFbmRJbnB1dCkge1xuXHRcdFx0ZW5kID0gdGhpcy5tb21lbnQoem9uZWRFbmRJbnB1dCkuc3RyaXBab25lKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0ZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH1cblxufSk7XG5cblxuQ2FsZW5kYXIubWl4aW4oRW1pdHRlck1peGluKTtcblxuXG5mdW5jdGlvbiBDYWxlbmRhcl9jb25zdHJ1Y3RvcihlbGVtZW50LCBvdmVycmlkZXMpIHtcblx0dmFyIHQgPSB0aGlzO1xuXG5cblx0Ly8gRXhwb3J0c1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdHQucmVuZGVyID0gcmVuZGVyO1xuXHR0LmRlc3Ryb3kgPSBkZXN0cm95O1xuXHR0LnJlZmV0Y2hFdmVudHMgPSByZWZldGNoRXZlbnRzO1xuXHR0LnJlZmV0Y2hFdmVudFNvdXJjZXMgPSByZWZldGNoRXZlbnRTb3VyY2VzO1xuXHR0LnJlcG9ydEV2ZW50cyA9IHJlcG9ydEV2ZW50cztcblx0dC5yZXBvcnRFdmVudENoYW5nZSA9IHJlcG9ydEV2ZW50Q2hhbmdlO1xuXHR0LnJlcmVuZGVyRXZlbnRzID0gcmVuZGVyRXZlbnRzOyAvLyBgcmVuZGVyRXZlbnRzYCBzZXJ2ZXMgYXMgYSByZXJlbmRlci4gYW4gQVBJIG1ldGhvZFxuXHR0LmNoYW5nZVZpZXcgPSByZW5kZXJWaWV3OyAvLyBgcmVuZGVyVmlld2Agd2lsbCBzd2l0Y2ggdG8gYW5vdGhlciB2aWV3XG5cdHQuc2VsZWN0ID0gc2VsZWN0O1xuXHR0LnVuc2VsZWN0ID0gdW5zZWxlY3Q7XG5cdHQucHJldiA9IHByZXY7XG5cdHQubmV4dCA9IG5leHQ7XG5cdHQucHJldlllYXIgPSBwcmV2WWVhcjtcblx0dC5uZXh0WWVhciA9IG5leHRZZWFyO1xuXHR0LnRvZGF5ID0gdG9kYXk7XG5cdHQuZ290b0RhdGUgPSBnb3RvRGF0ZTtcblx0dC5pbmNyZW1lbnREYXRlID0gaW5jcmVtZW50RGF0ZTtcblx0dC56b29tVG8gPSB6b29tVG87XG5cdHQuZ2V0RGF0ZSA9IGdldERhdGU7XG5cdHQuZ2V0Q2FsZW5kYXIgPSBnZXRDYWxlbmRhcjtcblx0dC5nZXRWaWV3ID0gZ2V0Vmlldztcblx0dC5vcHRpb24gPSBvcHRpb247IC8vIGdldHRlci9zZXR0ZXIgbWV0aG9kXG5cdHQudHJpZ2dlciA9IHRyaWdnZXI7XG5cblxuXHQvLyBPcHRpb25zXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0dC5keW5hbWljT3ZlcnJpZGVzID0ge307XG5cdHQudmlld1NwZWNDYWNoZSA9IHt9O1xuXHR0Lm9wdGlvbkhhbmRsZXJzID0ge307IC8vIGZvciBDYWxlbmRhci5vcHRpb25zLmpzXG5cblx0Ly8gY29udmVydCBsZWdhY3kgb3B0aW9ucyBpbnRvIG5vbi1sZWdhY3kgb25lcy5cblx0Ly8gaW4gdGhlIGZ1dHVyZSwgd2hlbiB0aGlzIGlzIHJlbW92ZWQsIGRvbid0IHVzZSBgb3ZlcnJpZGVzYCByZWZlcmVuY2UuIG1ha2UgYSBjb3B5LlxuXHR0Lm92ZXJyaWRlcyA9IG1hc3NhZ2VPdmVycmlkZXMob3ZlcnJpZGVzIHx8IHt9KTtcblxuXHR0LnBvcHVsYXRlT3B0aW9uc0hhc2goKTsgLy8gc2V0cyB0aGlzLm9wdGlvbnNcblxuXG5cblx0Ly8gTGFuZ3VhZ2UtZGF0YSBJbnRlcm5hbHNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gQXBwbHkgb3ZlcnJpZGVzIHRvIHRoZSBjdXJyZW50IGxhbmd1YWdlJ3MgZGF0YVxuXG5cdHZhciBsb2NhbGVEYXRhO1xuXG5cdC8vIENhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHdoZW4gYW55IG9mIHRoZSBvcHRpb25zIGNoYW5nZS5cblx0Ly8gSGFwcGVucyBiZWZvcmUgYW55IGludGVybmFsIG9iamVjdHMgcmVidWlsZCBvciByZXJlbmRlciwgYmVjYXVzZSB0aGlzIGlzIHZlcnkgY29yZS5cblx0dC5iaW5kT3B0aW9ucyhbXG5cdFx0J2xhbmcnLCAnbW9udGhOYW1lcycsICdtb250aE5hbWVzU2hvcnQnLCAnZGF5TmFtZXMnLCAnZGF5TmFtZXNTaG9ydCcsICdmaXJzdERheScsICd3ZWVrTnVtYmVyQ2FsY3VsYXRpb24nXG5cdF0sIGZ1bmN0aW9uKGxhbmcsIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCwgZGF5TmFtZXMsIGRheU5hbWVzU2hvcnQsIGZpcnN0RGF5LCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24pIHtcblxuXHRcdGxvY2FsZURhdGEgPSBjcmVhdGVPYmplY3QoIC8vIG1ha2UgYSBjaGVhcCBjb3B5XG5cdFx0XHRnZXRNb21lbnRMb2NhbGVEYXRhKGxhbmcpIC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXG5cdFx0KTtcblxuXHRcdGlmIChtb250aE5hbWVzKSB7XG5cdFx0XHRsb2NhbGVEYXRhLl9tb250aHMgPSBtb250aE5hbWVzO1xuXHRcdH1cblx0XHRpZiAobW9udGhOYW1lc1Nob3J0KSB7XG5cdFx0XHRsb2NhbGVEYXRhLl9tb250aHNTaG9ydCA9IG1vbnRoTmFtZXNTaG9ydDtcblx0XHR9XG5cdFx0aWYgKGRheU5hbWVzKSB7XG5cdFx0XHRsb2NhbGVEYXRhLl93ZWVrZGF5cyA9IGRheU5hbWVzO1xuXHRcdH1cblx0XHRpZiAoZGF5TmFtZXNTaG9ydCkge1xuXHRcdFx0bG9jYWxlRGF0YS5fd2Vla2RheXNTaG9ydCA9IGRheU5hbWVzU2hvcnQ7XG5cdFx0fVxuXHRcdGlmIChmaXJzdERheSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgX3dlZWsgPSBjcmVhdGVPYmplY3QobG9jYWxlRGF0YS5fd2Vlayk7IC8vIF93ZWVrOiB7IGRvdzogIyB9XG5cdFx0XHRfd2Vlay5kb3cgPSBmaXJzdERheTtcblx0XHRcdGxvY2FsZURhdGEuX3dlZWsgPSBfd2Vlaztcblx0XHR9XG5cblx0XHRpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnaXNvJykge1xuXHRcdFx0d2Vla051bWJlckNhbGN1bGF0aW9uID0gJ0lTTyc7IC8vIG5vcm1hbGl6ZVxuXHRcdH1cblx0XHRpZiAoIC8vIHdoaXRlbGlzdCBjZXJ0YWluIGtpbmRzIG9mIGlucHV0XG5cdFx0XHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nIHx8XG5cdFx0XHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdsb2NhbCcgfHxcblx0XHRcdHR5cGVvZiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbidcblx0XHQpIHtcblx0XHRcdGxvY2FsZURhdGEuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYyA9IHdlZWtOdW1iZXJDYWxjdWxhdGlvbjsgLy8gbW9tZW50LWV4dCB3aWxsIGtub3cgd2hhdCB0byBkbyB3aXRoIGl0XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGludGVybmFsIGN1cnJlbnQgZGF0ZSBvYmplY3QgYWxyZWFkeSBleGlzdHMsIG1vdmUgdG8gbmV3IGxvY2FsZS5cblx0XHQvLyBXZSBkbyBOT1QgbmVlZCB0byBkbyB0aGlzIHRlY2huaXF1ZSBmb3IgZXZlbnQgZGF0ZXMsIGJlY2F1c2UgdGhpcyBoYXBwZW5zIHdoZW4gY29udmVydGluZyB0byBcInNlZ21lbnRzXCIuXG5cdFx0aWYgKGRhdGUpIHtcblx0XHRcdGxvY2FsaXplTW9tZW50KGRhdGUpOyAvLyBzZXRzIHRvIGxvY2FsZURhdGFcblx0XHR9XG5cdH0pO1xuXG5cblxuXHQvLyBDYWxlbmRhci1zcGVjaWZpYyBEYXRlIFV0aWxpdGllc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0dC5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbih0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuXHR0LmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuXG5cblx0Ly8gQnVpbGRzIGEgbW9tZW50IHVzaW5nIHRoZSBzZXR0aW5ncyBvZiB0aGUgY3VycmVudCBjYWxlbmRhcjogdGltZXpvbmUgYW5kIGxhbmd1YWdlLlxuXHQvLyBBY2NlcHRzIGFueXRoaW5nIHRoZSB2YW5pbGxhIG1vbWVudCgpIGNvbnN0cnVjdG9yIGFjY2VwdHMuXG5cdHQubW9tZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vbTtcblxuXHRcdGlmICh0Lm9wdGlvbnMudGltZXpvbmUgPT09ICdsb2NhbCcpIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBGb3JjZSB0aGUgbW9tZW50IHRvIGJlIGxvY2FsLCBiZWNhdXNlIEZDLm1vbWVudCBkb2Vzbid0IGd1YXJhbnRlZSBpdC5cblx0XHRcdGlmIChtb20uaGFzVGltZSgpKSB7IC8vIGRvbid0IGdpdmUgYW1iaWd1b3VzbHktdGltZWQgbW9tZW50cyBhIGxvY2FsIHpvbmVcblx0XHRcdFx0bW9tLmxvY2FsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHQub3B0aW9ucy50aW1lem9uZSA9PT0gJ1VUQycpIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC51dGMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgLy8gcHJvY2VzcyBhcyBVVENcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtb20gPSBGQy5tb21lbnQucGFyc2Vab25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IC8vIGxldCB0aGUgaW5wdXQgZGVjaWRlIHRoZSB6b25lXG5cdFx0fVxuXG5cdFx0bG9jYWxpemVNb21lbnQobW9tKTtcblxuXHRcdHJldHVybiBtb207XG5cdH07XG5cblxuXHQvLyBVcGRhdGVzIHRoZSBnaXZlbiBtb21lbnQncyBsb2NhbGUgc2V0dGluZ3MgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIgbG9jYWxlIHNldHRpbmdzLlxuXHRmdW5jdGlvbiBsb2NhbGl6ZU1vbWVudChtb20pIHtcblx0XHRpZiAoJ19sb2NhbGUnIGluIG1vbSkgeyAvLyBtb21lbnQgMi44IGFuZCBhYm92ZVxuXHRcdFx0bW9tLl9sb2NhbGUgPSBsb2NhbGVEYXRhO1xuXHRcdH1cblx0XHRlbHNlIHsgLy8gcHJlLW1vbWVudC0yLjhcblx0XHRcdG1vbS5fbGFuZyA9IGxvY2FsZURhdGE7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsZW5kYXIga25vd3MgaG93IHRvIGNhbGN1bGF0ZVxuXHQvLyB0aGUgdGltZXpvbmUgb2Zmc2V0IG9mIGFyYml0cmFyeSBkYXRlcyBpbiB0aGUgY3VycmVudCB0aW1lem9uZS5cblx0dC5nZXRJc0FtYmlnVGltZXpvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdC5vcHRpb25zLnRpbWV6b25lICE9PSAnbG9jYWwnICYmIHQub3B0aW9ucy50aW1lem9uZSAhPT0gJ1VUQyc7XG5cdH07XG5cblxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgY3VycmVudCB0aW1lem9uZS4gSGFzIG5vIGVmZmVjdCBvbiBkYXRlcyB3aXRob3V0IHRpbWVzLlxuXHR0LmFwcGx5VGltZXpvbmUgPSBmdW5jdGlvbihkYXRlKSB7XG5cdFx0aWYgKCFkYXRlLmhhc1RpbWUoKSkge1xuXHRcdFx0cmV0dXJuIGRhdGUuY2xvbmUoKTtcblx0XHR9XG5cblx0XHR2YXIgem9uZWREYXRlID0gdC5tb21lbnQoZGF0ZS50b0FycmF5KCkpO1xuXHRcdHZhciB0aW1lQWRqdXN0ID0gZGF0ZS50aW1lKCkgLSB6b25lZERhdGUudGltZSgpO1xuXHRcdHZhciBhZGp1c3RlZFpvbmVkRGF0ZTtcblxuXHRcdC8vIFNhZmFyaSBzb21ldGltZXMgaGFzIHByb2JsZW1zIHdpdGggdGhpcyBjb2Vyc2lvbiB3aGVuIG5lYXIgRFNULiBBZGp1c3QgaWYgbmVjZXNzYXJ5LiAoYnVnICMyMzk2KVxuXHRcdGlmICh0aW1lQWRqdXN0KSB7IC8vIGlzIHRoZSB0aW1lIHJlc3VsdCBkaWZmZXJlbnQgdGhhbiBleHBlY3RlZD9cblx0XHRcdGFkanVzdGVkWm9uZWREYXRlID0gem9uZWREYXRlLmNsb25lKCkuYWRkKHRpbWVBZGp1c3QpOyAvLyBhZGQgbWlsbGlzZWNvbmRzXG5cdFx0XHRpZiAoZGF0ZS50aW1lKCkgLSBhZGp1c3RlZFpvbmVkRGF0ZS50aW1lKCkgPT09IDApIHsgLy8gZG9lcyBpdCBtYXRjaCBwZXJmZWN0bHkgbm93P1xuXHRcdFx0XHR6b25lZERhdGUgPSBhZGp1c3RlZFpvbmVkRGF0ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gem9uZWREYXRlO1xuXHR9O1xuXG5cblx0Ly8gUmV0dXJucyBhIG1vbWVudCBmb3IgdGhlIGN1cnJlbnQgZGF0ZSwgYXMgZGVmaW5lZCBieSB0aGUgY2xpZW50J3MgY29tcHV0ZXIgb3IgZnJvbSB0aGUgYG5vd2Agb3B0aW9uLlxuXHQvLyBXaWxsIHJldHVybiBhbiBtb21lbnQgd2l0aCBhbiBhbWJpZ3VvdXMgdGltZXpvbmUuXG5cdHQuZ2V0Tm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IHQub3B0aW9ucy5ub3c7XG5cdFx0aWYgKHR5cGVvZiBub3cgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG5vdyA9IG5vdygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdC5tb21lbnQobm93KS5zdHJpcFpvbmUoKTtcblx0fTtcblxuXG5cdC8vIEdldCBhbiBldmVudCdzIG5vcm1hbGl6ZWQgZW5kIGRhdGUuIElmIG5vdCBwcmVzZW50LCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZGVmYXVsdHMuXG5cdHQuZ2V0RXZlbnRFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmIChldmVudC5lbmQpIHtcblx0XHRcdHJldHVybiBldmVudC5lbmQuY2xvbmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gdC5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuYWxsRGF5LCBldmVudC5zdGFydCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuXHQvLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuXHR0LmdldERlZmF1bHRFdmVudEVuZCA9IGZ1bmN0aW9uKGFsbERheSwgem9uZWRTdGFydCkge1xuXHRcdHZhciBlbmQgPSB6b25lZFN0YXJ0LmNsb25lKCk7XG5cblx0XHRpZiAoYWxsRGF5KSB7XG5cdFx0XHRlbmQuc3RyaXBUaW1lKCkuYWRkKHQuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGVuZC5hZGQodC5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRpZiAodC5nZXRJc0FtYmlnVGltZXpvbmUoKSkge1xuXHRcdFx0ZW5kLnN0cmlwWm9uZSgpOyAvLyB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHR6byBzaG91bGQgYmVcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5kO1xuXHR9O1xuXG5cblx0Ly8gUHJvZHVjZXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0Ly8gU2lkZS1lZmZlY3Q6IGNoYW5nZXMgdGhlIGxvY2FsZSBvZiB0aGUgZ2l2ZW4gZHVyYXRpb24uXG5cdHQuaHVtYW5pemVEdXJhdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG5cdFx0cmV0dXJuIChkdXJhdGlvbi5sb2NhbGUgfHwgZHVyYXRpb24ubGFuZykuY2FsbChkdXJhdGlvbiwgdC5vcHRpb25zLmxhbmcpIC8vIHdvcmtzIG1vbWVudC1wcmUtMi44XG5cdFx0XHQuaHVtYW5pemUoKTtcblx0fTtcblxuXG5cdFxuXHQvLyBJbXBvcnRzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRFdmVudE1hbmFnZXIuY2FsbCh0KTtcblx0dmFyIGlzRmV0Y2hOZWVkZWQgPSB0LmlzRmV0Y2hOZWVkZWQ7XG5cdHZhciBmZXRjaEV2ZW50cyA9IHQuZmV0Y2hFdmVudHM7XG5cdHZhciBmZXRjaEV2ZW50U291cmNlcyA9IHQuZmV0Y2hFdmVudFNvdXJjZXM7XG5cblxuXG5cdC8vIExvY2Fsc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0dmFyIF9lbGVtZW50ID0gZWxlbWVudFswXTtcblx0dmFyIGhlYWRlcjtcblx0dmFyIGNvbnRlbnQ7XG5cdHZhciB0bTsgLy8gZm9yIG1ha2luZyB0aGVtZSBjbGFzc2VzXG5cdHZhciBjdXJyZW50VmlldzsgLy8gTk9URToga2VlcCB0aGlzIGluIHN5bmMgd2l0aCB0aGlzLnZpZXdcblx0dmFyIHZpZXdzQnlUeXBlID0ge307IC8vIGhvbGRzIGFsbCBpbnN0YW50aWF0ZWQgdmlldyBpbnN0YW5jZXMsIGN1cnJlbnQgb3Igbm90XG5cdHZhciBzdWdnZXN0ZWRWaWV3SGVpZ2h0O1xuXHR2YXIgd2luZG93UmVzaXplUHJveHk7IC8vIHdyYXBzIHRoZSB3aW5kb3dSZXNpemUgZnVuY3Rpb25cblx0dmFyIGlnbm9yZVdpbmRvd1Jlc2l6ZSA9IDA7XG5cdHZhciBldmVudHMgPSBbXTtcblx0dmFyIGRhdGU7IC8vIHVuem9uZWRcblx0XG5cdFxuXHRcblx0Ly8gTWFpbiBSZW5kZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxuXHRpZiAodC5vcHRpb25zLmRlZmF1bHREYXRlICE9IG51bGwpIHtcblx0XHRkYXRlID0gdC5tb21lbnQodC5vcHRpb25zLmRlZmF1bHREYXRlKS5zdHJpcFpvbmUoKTtcblx0fVxuXHRlbHNlIHtcblx0XHRkYXRlID0gdC5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0aWYgKCFjb250ZW50KSB7XG5cdFx0XHRpbml0aWFsUmVuZGVyKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGVsZW1lbnRWaXNpYmxlKCkpIHtcblx0XHRcdC8vIG1haW5seSBmb3IgdGhlIHB1YmxpYyBBUElcblx0XHRcdGNhbGNTaXplKCk7XG5cdFx0XHRyZW5kZXJWaWV3KCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gaW5pdGlhbFJlbmRlcigpIHtcblx0XHRlbGVtZW50LmFkZENsYXNzKCdmYycpO1xuXG5cdFx0Ly8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlXG5cdFx0dC5iaW5kT3B0aW9uKCd0aGVtZScsIGZ1bmN0aW9uKHRoZW1lKSB7XG5cdFx0XHR0bSA9IHRoZW1lID8gJ3VpJyA6ICdmYyc7IC8vIGFmZmVjdHMgYSBsYXJnZXIgc2NvcGVcblx0XHRcdGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ3VpLXdpZGdldCcsIHRoZW1lKTtcblx0XHRcdGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2ZjLXVudGhlbWVkJywgIXRoZW1lKTtcblx0XHR9KTtcblxuXHRcdC8vIGNhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHVwb24gb3B0aW9uIGNoYW5nZS5cblx0XHQvLyBIQUNLOiBsYW5nIG9mdGVuIGFmZmVjdHMgaXNSVEwsIHNvIHdlIGV4cGxpY2l0bHkgbGlzdGVuIHRvIHRoYXQgdG9vLlxuXHRcdHQuYmluZE9wdGlvbnMoWyAnaXNSVEwnLCAnbGFuZycgXSwgZnVuY3Rpb24oaXNSVEwpIHtcblx0XHRcdGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2ZjLWx0cicsICFpc1JUTCk7XG5cdFx0XHRlbGVtZW50LnRvZ2dsZUNsYXNzKCdmYy1ydGwnLCBpc1JUTCk7XG5cdFx0fSk7XG5cblx0XHRjb250ZW50ID0gJChcIjxkaXYgY2xhc3M9J2ZjLXZpZXctY29udGFpbmVyJy8+XCIpLnByZXBlbmRUbyhlbGVtZW50KTtcblxuXHRcdGhlYWRlciA9IHQuaGVhZGVyID0gbmV3IEhlYWRlcih0KTtcblx0XHRyZW5kZXJIZWFkZXIoKTtcblxuXHRcdHJlbmRlclZpZXcodC5vcHRpb25zLmRlZmF1bHRWaWV3KTtcblxuXHRcdGlmICh0Lm9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplKSB7XG5cdFx0XHR3aW5kb3dSZXNpemVQcm94eSA9IGRlYm91bmNlKHdpbmRvd1Jlc2l6ZSwgdC5vcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KTsgLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcblx0XHRcdCQod2luZG93KS5yZXNpemUod2luZG93UmVzaXplUHJveHkpO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBIZWFkZXIgd2lsbCByZXJlbmRlclxuXHRmdW5jdGlvbiByZW5kZXJIZWFkZXIoKSB7XG5cdFx0aGVhZGVyLnJlbmRlcigpO1xuXHRcdGlmIChoZWFkZXIuZWwpIHtcblx0XHRcdGVsZW1lbnQucHJlcGVuZChoZWFkZXIuZWwpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cblx0XHRpZiAoY3VycmVudFZpZXcpIHtcblx0XHRcdGN1cnJlbnRWaWV3LnJlbW92ZUVsZW1lbnQoKTtcblxuXHRcdFx0Ly8gTk9URTogZG9uJ3QgbnVsbC1vdXQgY3VycmVudFZpZXcvdC52aWV3IGluIGNhc2UgQVBJIG1ldGhvZHMgYXJlIGNhbGxlZCBhZnRlciBkZXN0cm95LlxuXHRcdFx0Ly8gSXQgaXMgc3RpbGwgdGhlIFwiY3VycmVudFwiIHZpZXcsIGp1c3Qgbm90IHJlbmRlcmVkLlxuXHRcdH1cblxuXHRcdGhlYWRlci5yZW1vdmVFbGVtZW50KCk7XG5cdFx0Y29udGVudC5yZW1vdmUoKTtcblx0XHRlbGVtZW50LnJlbW92ZUNsYXNzKCdmYyBmYy1sdHIgZmMtcnRsIGZjLXVudGhlbWVkIHVpLXdpZGdldCcpO1xuXG5cdFx0aWYgKHdpbmRvd1Jlc2l6ZVByb3h5KSB7XG5cdFx0XHQkKHdpbmRvdykudW5iaW5kKCdyZXNpemUnLCB3aW5kb3dSZXNpemVQcm94eSk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZWxlbWVudFZpc2libGUoKSB7XG5cdFx0cmV0dXJuIGVsZW1lbnQuaXMoJzp2aXNpYmxlJyk7XG5cdH1cblx0XG5cdFxuXG5cdC8vIFZpZXcgUmVuZGVyaW5nXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlldyBiZWNhdXNlIG9mIGEgZGF0ZSBjaGFuZ2UsIHZpZXctdHlwZSBjaGFuZ2UsIG9yIGZvciB0aGUgZmlyc3QgdGltZS5cblx0Ly8gSWYgbm90IGdpdmVuIGEgdmlld1R5cGUsIGtlZXAgdGhlIGN1cnJlbnQgdmlldyBidXQgcmVuZGVyIGRpZmZlcmVudCBkYXRlcy5cblx0Ly8gQWNjZXB0cyBhbiBvcHRpb25hbCBzY3JvbGwgc3RhdGUgdG8gcmVzdG9yZSB0by5cblx0ZnVuY3Rpb24gcmVuZGVyVmlldyh2aWV3VHlwZSwgZXhwbGljaXRTY3JvbGxTdGF0ZSkge1xuXHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZSsrO1xuXG5cdFx0Ly8gaWYgdmlld1R5cGUgaXMgY2hhbmdpbmcsIHJlbW92ZSB0aGUgb2xkIHZpZXcncyByZW5kZXJpbmdcblx0XHRpZiAoY3VycmVudFZpZXcgJiYgdmlld1R5cGUgJiYgY3VycmVudFZpZXcudHlwZSAhPT0gdmlld1R5cGUpIHtcblx0XHRcdGZyZWV6ZUNvbnRlbnRIZWlnaHQoKTsgLy8gcHJldmVudCBhIHNjcm9sbCBqdW1wIHdoZW4gdmlldyBlbGVtZW50IGlzIHJlbW92ZWRcblx0XHRcdGNsZWFyVmlldygpO1xuXHRcdH1cblxuXHRcdC8vIGlmIHZpZXdUeXBlIGNoYW5nZWQsIG9yIHRoZSB2aWV3IHdhcyBuZXZlciBjcmVhdGVkLCBjcmVhdGUgYSBmcmVzaCB2aWV3XG5cdFx0aWYgKCFjdXJyZW50VmlldyAmJiB2aWV3VHlwZSkge1xuXHRcdFx0Y3VycmVudFZpZXcgPSB0LnZpZXcgPVxuXHRcdFx0XHR2aWV3c0J5VHlwZVt2aWV3VHlwZV0gfHxcblx0XHRcdFx0KHZpZXdzQnlUeXBlW3ZpZXdUeXBlXSA9IHQuaW5zdGFudGlhdGVWaWV3KHZpZXdUeXBlKSk7XG5cblx0XHRcdGN1cnJlbnRWaWV3LnNldEVsZW1lbnQoXG5cdFx0XHRcdCQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3IGZjLVwiICsgdmlld1R5cGUgKyBcIi12aWV3JyAvPlwiKS5hcHBlbmRUbyhjb250ZW50KVxuXHRcdFx0KTtcblx0XHRcdGhlYWRlci5hY3RpdmF0ZUJ1dHRvbih2aWV3VHlwZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGN1cnJlbnRWaWV3KSB7XG5cblx0XHRcdC8vIGluIGNhc2UgdGhlIHZpZXcgc2hvdWxkIHJlbmRlciBhIHBlcmlvZCBvZiB0aW1lIHRoYXQgaXMgY29tcGxldGVseSBoaWRkZW5cblx0XHRcdGRhdGUgPSBjdXJyZW50Vmlldy5tYXNzYWdlQ3VycmVudERhdGUoZGF0ZSk7XG5cblx0XHRcdC8vIHJlbmRlciBvciByZXJlbmRlciB0aGUgdmlld1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhY3VycmVudFZpZXcuZGlzcGxheWluZyB8fFxuXHRcdFx0XHQhZGF0ZS5pc1dpdGhpbihjdXJyZW50Vmlldy5pbnRlcnZhbFN0YXJ0LCBjdXJyZW50Vmlldy5pbnRlcnZhbEVuZCkgLy8gaW1wbGljaXQgZGF0ZSB3aW5kb3cgY2hhbmdlXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnRWaXNpYmxlKCkpIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRWaWV3LmRpc3BsYXkoZGF0ZSwgZXhwbGljaXRTY3JvbGxTdGF0ZSk7IC8vIHdpbGwgY2FsbCBmcmVlemVDb250ZW50SGVpZ2h0XG5cdFx0XHRcdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7IC8vIGltbWVkaWF0ZWx5IHVuZnJlZXplIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBkaXNwbGF5IGlzIGFzeW5jXG5cblx0XHRcdFx0XHQvLyBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgVmlldzo6cmVuZGVyLCBzbyBkYXRlcyBhcmUgY2FsY3VsYXRlZFxuXHRcdFx0XHRcdHVwZGF0ZUhlYWRlclRpdGxlKCk7XG5cdFx0XHRcdFx0dXBkYXRlVG9kYXlCdXR0b24oKTtcblxuXHRcdFx0XHRcdGdldEFuZFJlbmRlckV2ZW50cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7IC8vIHVuZG8gYW55IGxvbmUgZnJlZXplQ29udGVudEhlaWdodCBjYWxsc1xuXHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZS0tO1xuXHR9XG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGN1cnJlbnQgdmlldyBhbmQgcmVmbGVjdHMgdGhpcyBjaGFuZ2UgaW4gdGhlIEhlYWRlci5cblx0Ly8gVW5yZWdzaXRlcnMgdGhlIGBjdXJyZW50Vmlld2AsIGJ1dCBkb2VzIG5vdCByZW1vdmUgZnJvbSB2aWV3QnlUeXBlIGhhc2guXG5cdGZ1bmN0aW9uIGNsZWFyVmlldygpIHtcblx0XHRoZWFkZXIuZGVhY3RpdmF0ZUJ1dHRvbihjdXJyZW50Vmlldy50eXBlKTtcblx0XHRjdXJyZW50Vmlldy5yZW1vdmVFbGVtZW50KCk7XG5cdFx0Y3VycmVudFZpZXcgPSB0LnZpZXcgPSBudWxsO1xuXHR9XG5cblxuXHQvLyBEZXN0cm95cyB0aGUgdmlldywgaW5jbHVkaW5nIHRoZSB2aWV3IG9iamVjdC4gVGhlbiwgcmUtaW5zdGFudGlhdGVzIGl0IGFuZCByZW5kZXJzIGl0LlxuXHQvLyBNYWludGFpbnMgdGhlIHNhbWUgc2Nyb2xsIHN0YXRlLlxuXHQvLyBUT0RPOiBtYWludGFpbiBhbnkgb3RoZXIgdXNlci1tYW5pcHVsYXRlZCBzdGF0ZS5cblx0ZnVuY3Rpb24gcmVpbml0VmlldygpIHtcblx0XHRpZ25vcmVXaW5kb3dSZXNpemUrKztcblx0XHRmcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cblx0XHR2YXIgdmlld1R5cGUgPSBjdXJyZW50Vmlldy50eXBlO1xuXHRcdHZhciBzY3JvbGxTdGF0ZSA9IGN1cnJlbnRWaWV3LnF1ZXJ5U2Nyb2xsKCk7XG5cdFx0Y2xlYXJWaWV3KCk7XG5cdFx0cmVuZGVyVmlldyh2aWV3VHlwZSwgc2Nyb2xsU3RhdGUpO1xuXG5cdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cdFx0aWdub3JlV2luZG93UmVzaXplLS07XG5cdH1cblxuXHRcblxuXHQvLyBSZXNpemluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0dC5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHN1Z2dlc3RlZFZpZXdIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FsY1NpemUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN1Z2dlc3RlZFZpZXdIZWlnaHQ7XG5cdH07XG5cblxuXHR0LmlzSGVpZ2h0QXV0byA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0Lm9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nIHx8IHQub3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiB1cGRhdGVTaXplKHNob3VsZFJlY2FsYykge1xuXHRcdGlmIChlbGVtZW50VmlzaWJsZSgpKSB7XG5cblx0XHRcdGlmIChzaG91bGRSZWNhbGMpIHtcblx0XHRcdFx0X2NhbGNTaXplKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZSsrO1xuXHRcdFx0Y3VycmVudFZpZXcudXBkYXRlU2l6ZSh0cnVlKTsgLy8gaXNSZXNpemU9dHJ1ZS4gd2lsbCBwb2xsIGdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSBhbmQgaXNIZWlnaHRBdXRvKClcblx0XHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZS0tO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIHN1Y2Nlc3Ncblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNhbGNTaXplKCkge1xuXHRcdGlmIChlbGVtZW50VmlzaWJsZSgpKSB7XG5cdFx0XHRfY2FsY1NpemUoKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfY2FsY1NpemUoKSB7IC8vIGFzc3VtZXMgZWxlbWVudFZpc2libGVcblx0XHRpZiAodHlwZW9mIHQub3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnbnVtYmVyJykgeyAvLyBleGlzdHMgYW5kIG5vdCAnYXV0bydcblx0XHRcdHN1Z2dlc3RlZFZpZXdIZWlnaHQgPSB0Lm9wdGlvbnMuY29udGVudEhlaWdodDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHQub3B0aW9ucy5oZWlnaHQgPT09ICdudW1iZXInKSB7IC8vIGV4aXN0cyBhbmQgbm90ICdhdXRvJ1xuXHRcdFx0c3VnZ2VzdGVkVmlld0hlaWdodCA9IHQub3B0aW9ucy5oZWlnaHQgLSAoaGVhZGVyLmVsID8gaGVhZGVyLmVsLm91dGVySGVpZ2h0KHRydWUpIDogMCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3VnZ2VzdGVkVmlld0hlaWdodCA9IE1hdGgucm91bmQoY29udGVudC53aWR0aCgpIC8gTWF0aC5tYXgodC5vcHRpb25zLmFzcGVjdFJhdGlvLCAuNSkpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHdpbmRvd1Jlc2l6ZShldikge1xuXHRcdGlmIChcblx0XHRcdCFpZ25vcmVXaW5kb3dSZXNpemUgJiZcblx0XHRcdGV2LnRhcmdldCA9PT0gd2luZG93ICYmIC8vIHNvIHdlIGRvbid0IHByb2Nlc3MganF1aSBcInJlc2l6ZVwiIGV2ZW50cyB0aGF0IGhhdmUgYnViYmxlZCB1cFxuXHRcdFx0Y3VycmVudFZpZXcuc3RhcnQgLy8gdmlldyBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlcmVkXG5cdFx0KSB7XG5cdFx0XHRpZiAodXBkYXRlU2l6ZSh0cnVlKSkge1xuXHRcdFx0XHRjdXJyZW50Vmlldy50cmlnZ2VyKCd3aW5kb3dSZXNpemUnLCBfZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0XG5cdC8qIEV2ZW50IEZldGNoaW5nL1JlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIFRPRE86IGdvaW5nIGZvcndhcmQsIG1vc3Qgb2YgdGhpcyBzdHVmZiBzaG91bGQgYmUgZGlyZWN0bHkgaGFuZGxlZCBieSB0aGUgdmlld1xuXG5cblx0ZnVuY3Rpb24gcmVmZXRjaEV2ZW50cygpIHsgLy8gY2FuIGJlIGNhbGxlZCBhcyBhbiBBUEkgbWV0aG9kXG5cdFx0ZmV0Y2hBbmRSZW5kZXJFdmVudHMoKTtcblx0fVxuXG5cblx0Ly8gVE9ETzogbW92ZSB0aGlzIGludG8gRXZlbnRNYW5hZ2VyP1xuXHRmdW5jdGlvbiByZWZldGNoRXZlbnRTb3VyY2VzKG1hdGNoSW5wdXRzKSB7XG5cdFx0ZmV0Y2hFdmVudFNvdXJjZXModC5nZXRFdmVudFNvdXJjZXNCeU1hdGNoQXJyYXkobWF0Y2hJbnB1dHMpKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVuZGVyRXZlbnRzKCkgeyAvLyBkZXN0cm95cyBvbGQgZXZlbnRzIGlmIHByZXZpb3VzbHkgcmVuZGVyZWRcblx0XHRpZiAoZWxlbWVudFZpc2libGUoKSkge1xuXHRcdFx0ZnJlZXplQ29udGVudEhlaWdodCgpO1xuXHRcdFx0Y3VycmVudFZpZXcuZGlzcGxheUV2ZW50cyhldmVudHMpO1xuXHRcdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cdFx0fVxuXHR9XG5cdFxuXG5cdGZ1bmN0aW9uIGdldEFuZFJlbmRlckV2ZW50cygpIHtcblx0XHRpZiAoIXQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHwgaXNGZXRjaE5lZWRlZChjdXJyZW50Vmlldy5zdGFydCwgY3VycmVudFZpZXcuZW5kKSkge1xuXHRcdFx0ZmV0Y2hBbmRSZW5kZXJFdmVudHMoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW5kZXJFdmVudHMoKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZldGNoQW5kUmVuZGVyRXZlbnRzKCkge1xuXHRcdGZldGNoRXZlbnRzKGN1cnJlbnRWaWV3LnN0YXJ0LCBjdXJyZW50Vmlldy5lbmQpO1xuXHRcdFx0Ly8gLi4uIHdpbGwgY2FsbCByZXBvcnRFdmVudHNcblx0XHRcdC8vIC4uLiB3aGljaCB3aWxsIGNhbGwgcmVuZGVyRXZlbnRzXG5cdH1cblxuXHRcblx0Ly8gY2FsbGVkIHdoZW4gZXZlbnQgZGF0YSBhcnJpdmVzXG5cdGZ1bmN0aW9uIHJlcG9ydEV2ZW50cyhfZXZlbnRzKSB7XG5cdFx0ZXZlbnRzID0gX2V2ZW50cztcblx0XHRyZW5kZXJFdmVudHMoKTtcblx0fVxuXG5cblx0Ly8gY2FsbGVkIHdoZW4gYSBzaW5nbGUgZXZlbnQncyBkYXRhIGhhcyBiZWVuIGNoYW5nZWRcblx0ZnVuY3Rpb24gcmVwb3J0RXZlbnRDaGFuZ2UoKSB7XG5cdFx0cmVuZGVyRXZlbnRzKCk7XG5cdH1cblxuXG5cblx0LyogSGVhZGVyIFVwZGF0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUhlYWRlclRpdGxlKCkge1xuXHRcdGhlYWRlci51cGRhdGVUaXRsZShjdXJyZW50Vmlldy50aXRsZSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVRvZGF5QnV0dG9uKCkge1xuXHRcdHZhciBub3cgPSB0LmdldE5vdygpO1xuXHRcdGlmIChub3cuaXNXaXRoaW4oY3VycmVudFZpZXcuaW50ZXJ2YWxTdGFydCwgY3VycmVudFZpZXcuaW50ZXJ2YWxFbmQpKSB7XG5cdFx0XHRoZWFkZXIuZGlzYWJsZUJ1dHRvbigndG9kYXknKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRoZWFkZXIuZW5hYmxlQnV0dG9uKCd0b2RheScpO1xuXHRcdH1cblx0fVxuXHRcblxuXG5cdC8qIFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXG5cdC8vIHRoaXMgcHVibGljIG1ldGhvZCByZWNlaXZlcyBzdGFydC9lbmQgZGF0ZXMgaW4gYW55IGZvcm1hdCwgd2l0aCBhbnkgdGltZXpvbmVcblx0ZnVuY3Rpb24gc2VsZWN0KHpvbmVkU3RhcnRJbnB1dCwgem9uZWRFbmRJbnB1dCkge1xuXHRcdGN1cnJlbnRWaWV3LnNlbGVjdChcblx0XHRcdHQuYnVpbGRTZWxlY3RTcGFuLmFwcGx5KHQsIGFyZ3VtZW50cylcblx0XHQpO1xuXHR9XG5cdFxuXG5cdGZ1bmN0aW9uIHVuc2VsZWN0KCkgeyAvLyBzYWZlIHRvIGJlIGNhbGxlZCBiZWZvcmUgcmVuZGVyVmlld1xuXHRcdGlmIChjdXJyZW50Vmlldykge1xuXHRcdFx0Y3VycmVudFZpZXcudW5zZWxlY3QoKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyogRGF0ZVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHRcblx0ZnVuY3Rpb24gcHJldigpIHtcblx0XHRkYXRlID0gY3VycmVudFZpZXcuY29tcHV0ZVByZXZEYXRlKGRhdGUpO1xuXHRcdHJlbmRlclZpZXcoKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0ZGF0ZSA9IGN1cnJlbnRWaWV3LmNvbXB1dGVOZXh0RGF0ZShkYXRlKTtcblx0XHRyZW5kZXJWaWV3KCk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBwcmV2WWVhcigpIHtcblx0XHRkYXRlLmFkZCgtMSwgJ3llYXJzJyk7XG5cdFx0cmVuZGVyVmlldygpO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gbmV4dFllYXIoKSB7XG5cdFx0ZGF0ZS5hZGQoMSwgJ3llYXJzJyk7XG5cdFx0cmVuZGVyVmlldygpO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gdG9kYXkoKSB7XG5cdFx0ZGF0ZSA9IHQuZ2V0Tm93KCk7XG5cdFx0cmVuZGVyVmlldygpO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZ290b0RhdGUoem9uZWREYXRlSW5wdXQpIHtcblx0XHRkYXRlID0gdC5tb21lbnQoem9uZWREYXRlSW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdHJlbmRlclZpZXcoKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGluY3JlbWVudERhdGUoZGVsdGEpIHtcblx0XHRkYXRlLmFkZChtb21lbnQuZHVyYXRpb24oZGVsdGEpKTtcblx0XHRyZW5kZXJWaWV3KCk7XG5cdH1cblxuXG5cdC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG5cdC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxuXHRmdW5jdGlvbiB6b29tVG8obmV3RGF0ZSwgdmlld1R5cGUpIHtcblx0XHR2YXIgc3BlYztcblxuXHRcdHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cblx0XHRzcGVjID0gdC5nZXRWaWV3U3BlYyh2aWV3VHlwZSkgfHwgdC5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuXG5cdFx0ZGF0ZSA9IG5ld0RhdGUuY2xvbmUoKTtcblx0XHRyZW5kZXJWaWV3KHNwZWMgPyBzcGVjLnR5cGUgOiBudWxsKTtcblx0fVxuXHRcblx0XG5cdC8vIGZvciBleHRlcm5hbCBBUElcblx0ZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcblx0XHRyZXR1cm4gdC5hcHBseVRpbWV6b25lKGRhdGUpOyAvLyBpbmZ1c2UgdGhlIGNhbGVuZGFyJ3MgdGltZXpvbmVcblx0fVxuXG5cblxuXHQvKiBIZWlnaHQgXCJGcmVlemluZ1wiXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gVE9ETzogbW92ZSB0aGlzIGludG8gdGhlIHZpZXdcblxuXHR0LmZyZWV6ZUNvbnRlbnRIZWlnaHQgPSBmcmVlemVDb250ZW50SGVpZ2h0O1xuXHR0LnVuZnJlZXplQ29udGVudEhlaWdodCA9IHVuZnJlZXplQ29udGVudEhlaWdodDtcblxuXG5cdGZ1bmN0aW9uIGZyZWV6ZUNvbnRlbnRIZWlnaHQoKSB7XG5cdFx0Y29udGVudC5jc3Moe1xuXHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdGhlaWdodDogY29udGVudC5oZWlnaHQoKSxcblx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiB1bmZyZWV6ZUNvbnRlbnRIZWlnaHQoKSB7XG5cdFx0Y29udGVudC5jc3Moe1xuXHRcdFx0d2lkdGg6ICcnLFxuXHRcdFx0aGVpZ2h0OiAnJyxcblx0XHRcdG92ZXJmbG93OiAnJ1xuXHRcdH0pO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qIE1pc2Ncblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblxuXHRmdW5jdGlvbiBnZXRDYWxlbmRhcigpIHtcblx0XHRyZXR1cm4gdDtcblx0fVxuXG5cdFxuXHRmdW5jdGlvbiBnZXRWaWV3KCkge1xuXHRcdHJldHVybiBjdXJyZW50Vmlldztcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIG9wdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBuZXdPcHRpb25IYXNoO1xuXG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgLy8gZ2V0dGVyXG5cdFx0XHRcdHJldHVybiB0Lm9wdGlvbnNbbmFtZV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gc2V0dGVyIGZvciBpbmRpdmlkdWFsIG9wdGlvblxuXHRcdFx0XHRuZXdPcHRpb25IYXNoID0ge307XG5cdFx0XHRcdG5ld09wdGlvbkhhc2hbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0c2V0T3B0aW9ucyhuZXdPcHRpb25IYXNoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7IC8vIGNvbXBvdW5kIHNldHRlciB3aXRoIG9iamVjdCBpbnB1dFxuXHRcdFx0c2V0T3B0aW9ucyhuYW1lKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNldE9wdGlvbnMobmV3T3B0aW9uSGFzaCkge1xuXHRcdHZhciBvcHRpb25DbnQgPSAwO1xuXHRcdHZhciBvcHRpb25OYW1lO1xuXG5cdFx0Zm9yIChvcHRpb25OYW1lIGluIG5ld09wdGlvbkhhc2gpIHtcblx0XHRcdHQuZHluYW1pY092ZXJyaWRlc1tvcHRpb25OYW1lXSA9IG5ld09wdGlvbkhhc2hbb3B0aW9uTmFtZV07XG5cdFx0fVxuXG5cdFx0dC52aWV3U3BlY0NhY2hlID0ge307IC8vIHRoZSBkeW5hbWljIG92ZXJyaWRlIGludmFsaWRhdGVzIHRoZSBvcHRpb25zIGluIHRoaXMgY2FjaGUsIHNvIGp1c3QgY2xlYXIgaXRcblx0XHR0LnBvcHVsYXRlT3B0aW9uc0hhc2goKTsgLy8gdGhpcy5vcHRpb25zIG5lZWRzIHRvIGJlIHJlY29tcHV0ZWQgYWZ0ZXIgdGhlIGR5bmFtaWMgb3ZlcnJpZGVcblxuXHRcdC8vIHRyaWdnZXIgaGFuZGxlcnMgYWZ0ZXIgdGhpcy5vcHRpb25zIGhhcyBiZWVuIHVwZGF0ZWRcblx0XHRmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xuXHRcdFx0dC50cmlnZ2VyT3B0aW9uSGFuZGxlcnMob3B0aW9uTmFtZSk7IC8vIHJlY2FsbCBiaW5kT3B0aW9uL2JpbmRPcHRpb25zXG5cdFx0XHRvcHRpb25DbnQrKztcblx0XHR9XG5cblx0XHQvLyBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2Ygc2luZ2xlIG9wdGlvbiBjaGFuZ2UuXG5cdFx0Ly8gaWYgb25seSBvbmUgb3B0aW9uIGNoYW5nZSwgYG9wdGlvbk5hbWVgIHdpbGwgYmUgaXRzIG5hbWUuXG5cdFx0aWYgKG9wdGlvbkNudCA9PT0gMSkge1xuXHRcdFx0aWYgKG9wdGlvbk5hbWUgPT09ICdoZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdjb250ZW50SGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnYXNwZWN0UmF0aW8nKSB7XG5cdFx0XHRcdHVwZGF0ZVNpemUodHJ1ZSk7IC8vIHRydWUgPSBhbGxvdyByZWNhbGN1bGF0aW9uIG9mIGhlaWdodFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvcHRpb25OYW1lID09PSAnZGVmYXVsdERhdGUnKSB7XG5cdFx0XHRcdHJldHVybjsgLy8gY2FuJ3QgY2hhbmdlIGRhdGUgdGhpcyB3YXkuIHVzZSBnb3RvRGF0ZSBpbnN0ZWFkXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvcHRpb25OYW1lID09PSAnYnVzaW5lc3NIb3VycycpIHtcblx0XHRcdFx0aWYgKGN1cnJlbnRWaWV3KSB7XG5cdFx0XHRcdFx0Y3VycmVudFZpZXcudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0XHRcdFx0Y3VycmVudFZpZXcucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICd0aW1lem9uZScpIHtcblx0XHRcdFx0dC5yZXpvbmVBcnJheUV2ZW50U291cmNlcygpO1xuXHRcdFx0XHRyZWZldGNoRXZlbnRzKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjYXRjaC1hbGwuIHJlcmVuZGVyIHRoZSBoZWFkZXIgYW5kIHJlYnVpbGQvcmVyZW5kZXIgdGhlIGN1cnJlbnQgdmlld1xuXHRcdHJlbmRlckhlYWRlcigpO1xuXHRcdHZpZXdzQnlUeXBlID0ge307IC8vIGV2ZW4gbm9uLWN1cnJlbnQgdmlld3Mgd2lsbCBiZSBhZmZlY3RlZCBieSB0aGlzIG9wdGlvbiBjaGFuZ2UuIGRvIGJlZm9yZSByZXJlbmRlclxuXHRcdHJlaW5pdFZpZXcoKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHRyaWdnZXIobmFtZSwgdGhpc09iaikgeyAvLyBvdmVycmlkZXMgdGhlIEVtaXR0ZXIncyB0cmlnZ2VyIG1ldGhvZCA6KFxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblxuXHRcdHRoaXNPYmogPSB0aGlzT2JqIHx8IF9lbGVtZW50O1xuXHRcdHRoaXMudHJpZ2dlcldpdGgobmFtZSwgdGhpc09iaiwgYXJncyk7IC8vIEVtaXR0ZXIncyBtZXRob2RcblxuXHRcdGlmICh0Lm9wdGlvbnNbbmFtZV0pIHtcblx0XHRcdHJldHVybiB0Lm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpc09iaiwgYXJncyk7XG5cdFx0fVxuXHR9XG5cblx0dC5pbml0aWFsaXplKCk7XG59XG5cbjs7XG4vKlxuT3B0aW9ucyBiaW5kaW5nL3RyaWdnZXJpbmcgc3lzdGVtLlxuKi9cbkNhbGVuZGFyLm1peGluKHtcblxuXHQvLyBBIG1hcCBvZiBvcHRpb24gbmFtZXMgdG8gYXJyYXlzIG9mIGhhbmRsZXIgb2JqZWN0cy4gSW5pdGlhbGl6ZWQgdG8ge30gaW4gQ2FsZW5kYXIuXG5cdC8vIEZvcm1hdCBmb3IgYSBoYW5kbGVyIG9iamVjdDpcblx0Ly8ge1xuXHQvLyAgIGZ1bmMgLy8gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVwb24gY2hhbmdlXG5cdC8vICAgbmFtZXMgLy8gb3B0aW9uIG5hbWVzIHdob3NlIHZhbHVlcyBzaG91bGQgYmUgZ2l2ZW4gdG8gZnVuY1xuXHQvLyB9XG5cdG9wdGlvbkhhbmRsZXJzOiBudWxsLCBcblxuXHQvLyBDYWxscyBoYW5kbGVyRnVuYyBpbW1lZGlhdGVseSwgYW5kIHdoZW4gdGhlIGdpdmVuIG9wdGlvbiBoYXMgY2hhbmdlZC5cblx0Ly8gaGFuZGxlckZ1bmMgd2lsbCBiZSBnaXZlbiB0aGUgb3B0aW9uIHZhbHVlLlxuXHRiaW5kT3B0aW9uOiBmdW5jdGlvbihvcHRpb25OYW1lLCBoYW5kbGVyRnVuYykge1xuXHRcdHRoaXMuYmluZE9wdGlvbnMoWyBvcHRpb25OYW1lIF0sIGhhbmRsZXJGdW5jKTtcblx0fSxcblxuXHQvLyBDYWxscyBoYW5kbGVyRnVuYyBpbW1lZGlhdGVseSwgYW5kIHdoZW4gYW55IG9mIHRoZSBnaXZlbiBvcHRpb25zIGNoYW5nZS5cblx0Ly8gaGFuZGxlckZ1bmMgd2lsbCBiZSBnaXZlbiBlYWNoIG9wdGlvbiB2YWx1ZSBhcyBvcmRlcmVkIGZ1bmN0aW9uIGFyZ3VtZW50cy5cblx0YmluZE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbk5hbWVzLCBoYW5kbGVyRnVuYykge1xuXHRcdHZhciBoYW5kbGVyT2JqID0geyBmdW5jOiBoYW5kbGVyRnVuYywgbmFtZXM6IG9wdGlvbk5hbWVzIH07XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgb3B0aW9uTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMucmVnaXN0ZXJPcHRpb25IYW5kbGVyT2JqKG9wdGlvbk5hbWVzW2ldLCBoYW5kbGVyT2JqKTtcblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXJPcHRpb25IYW5kbGVyT2JqKGhhbmRsZXJPYmopO1xuXHR9LFxuXG5cdC8vIFB1dHMgdGhlIGdpdmVuIGhhbmRsZXIgb2JqZWN0IGludG8gdGhlIGludGVybmFsIGhhc2hcblx0cmVnaXN0ZXJPcHRpb25IYW5kbGVyT2JqOiBmdW5jdGlvbihvcHRpb25OYW1lLCBoYW5kbGVyT2JqKSB7XG5cdFx0KHRoaXMub3B0aW9uSGFuZGxlcnNbb3B0aW9uTmFtZV0gfHwgKHRoaXMub3B0aW9uSGFuZGxlcnNbb3B0aW9uTmFtZV0gPSBbXSkpXG5cdFx0XHQucHVzaChoYW5kbGVyT2JqKTtcblx0fSxcblxuXHQvLyBSZXBvcnRzIHRoYXQgdGhlIGdpdmVuIG9wdGlvbiBoYXMgY2hhbmdlZCwgYW5kIGNhbGxzIGFsbCBhcHByb3ByaWF0ZSBoYW5kbGVycy5cblx0dHJpZ2dlck9wdGlvbkhhbmRsZXJzOiBmdW5jdGlvbihvcHRpb25OYW1lKSB7XG5cdFx0dmFyIGhhbmRsZXJPYmpzID0gdGhpcy5vcHRpb25IYW5kbGVyc1tvcHRpb25OYW1lXSB8fCBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBoYW5kbGVyT2Jqcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy50cmlnZ2VyT3B0aW9uSGFuZGxlck9iaihoYW5kbGVyT2Jqc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbGxzIHRoZSBjYWxsYmFjayBmb3IgYSBzcGVjaWZpYyBoYW5kbGVyIG9iamVjdCwgcGFzc2luZyBpbiB0aGUgYXBwcm9wcmlhdGUgYXJndW1lbnRzLlxuXHR0cmlnZ2VyT3B0aW9uSGFuZGxlck9iajogZnVuY3Rpb24oaGFuZGxlck9iaikge1xuXHRcdHZhciBvcHRpb25OYW1lcyA9IGhhbmRsZXJPYmoubmFtZXM7XG5cdFx0dmFyIG9wdGlvblZhbHVlcyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IG9wdGlvbk5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRvcHRpb25WYWx1ZXMucHVzaCh0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZXNbaV1dKTtcblx0XHR9XG5cblx0XHRoYW5kbGVyT2JqLmZ1bmMuYXBwbHkodGhpcywgb3B0aW9uVmFsdWVzKTsgLy8gbWFpbnRhaW4gdGhlIENhbGVuZGFyJ3MgYHRoaXNgIGNvbnRleHRcblx0fVxuXG59KTtcblxuOztcblxuQ2FsZW5kYXIuZGVmYXVsdHMgPSB7XG5cblx0dGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsIC8vIGVuIGRhc2hcblx0bW9udGhZZWFyRm9ybWF0OiAnTU1NTSBZWVlZJywgLy8gcmVxdWlyZWQgZm9yIGVuLiBvdGhlciBsYW5ndWFnZXMgcmVseSBvbiBkYXRlcGlja2VyIGNvbXB1dGFibGUgb3B0aW9uXG5cblx0ZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAyOjAwOjAwJyxcblx0ZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5czogMSB9LFxuXHRmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuXHRuZXh0RGF5VGhyZXNob2xkOiAnMDk6MDA6MDAnLCAvLyA5YW1cblxuXHQvLyBkaXNwbGF5XG5cdGRlZmF1bHRWaWV3OiAnbW9udGgnLFxuXHRhc3BlY3RSYXRpbzogMS4zNSxcblx0aGVhZGVyOiB7XG5cdFx0bGVmdDogJ3RpdGxlJyxcblx0XHRjZW50ZXI6ICcnLFxuXHRcdHJpZ2h0OiAndG9kYXkgcHJldixuZXh0J1xuXHR9LFxuXHR3ZWVrZW5kczogdHJ1ZSxcblx0d2Vla051bWJlcnM6IGZhbHNlLFxuXG5cdHdlZWtOdW1iZXJUaXRsZTogJ1cnLFxuXHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG5cdFxuXHQvL2VkaXRhYmxlOiBmYWxzZSxcblxuXHQvL25vd0luZGljYXRvcjogZmFsc2UsXG5cblx0c2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcblx0XG5cdC8vIGV2ZW50IGFqYXhcblx0bGF6eUZldGNoaW5nOiB0cnVlLFxuXHRzdGFydFBhcmFtOiAnc3RhcnQnLFxuXHRlbmRQYXJhbTogJ2VuZCcsXG5cdHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXG5cblx0dGltZXpvbmU6IGZhbHNlLFxuXG5cdC8vYWxsRGF5RGVmYXVsdDogdW5kZWZpbmVkLFxuXG5cdC8vIGxvY2FsZVxuXHRpc1JUTDogZmFsc2UsXG5cdGJ1dHRvblRleHQ6IHtcblx0XHRwcmV2OiBcInByZXZcIixcblx0XHRuZXh0OiBcIm5leHRcIixcblx0XHRwcmV2WWVhcjogXCJwcmV2IHllYXJcIixcblx0XHRuZXh0WWVhcjogXCJuZXh0IHllYXJcIixcblx0XHR5ZWFyOiAneWVhcicsIC8vIFRPRE86IGxvY2FsZSBmaWxlcyBuZWVkIHRvIHNwZWNpZnkgdGhpc1xuXHRcdHRvZGF5OiAndG9kYXknLFxuXHRcdG1vbnRoOiAnbW9udGgnLFxuXHRcdHdlZWs6ICd3ZWVrJyxcblx0XHRkYXk6ICdkYXknXG5cdH0sXG5cblx0YnV0dG9uSWNvbnM6IHtcblx0XHRwcmV2OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxuXHRcdG5leHQ6ICdyaWdodC1zaW5nbGUtYXJyb3cnLFxuXHRcdHByZXZZZWFyOiAnbGVmdC1kb3VibGUtYXJyb3cnLFxuXHRcdG5leHRZZWFyOiAncmlnaHQtZG91YmxlLWFycm93J1xuXHR9LFxuXHRcblx0Ly8ganF1ZXJ5LXVpIHRoZW1pbmdcblx0dGhlbWU6IGZhbHNlLFxuXHR0aGVtZUJ1dHRvbkljb25zOiB7XG5cdFx0cHJldjogJ2NpcmNsZS10cmlhbmdsZS13Jyxcblx0XHRuZXh0OiAnY2lyY2xlLXRyaWFuZ2xlLWUnLFxuXHRcdHByZXZZZWFyOiAnc2Vlay1wcmV2Jyxcblx0XHRuZXh0WWVhcjogJ3NlZWstbmV4dCdcblx0fSxcblxuXHQvL2V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmYWxzZSxcblx0ZHJhZ09wYWNpdHk6IC43NSxcblx0ZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXG5cdGRyYWdTY3JvbGw6IHRydWUsXG5cdFxuXHQvL3NlbGVjdGFibGU6IGZhbHNlLFxuXHR1bnNlbGVjdEF1dG86IHRydWUsXG5cdFxuXHRkcm9wQWNjZXB0OiAnKicsXG5cblx0ZXZlbnRPcmRlcjogJ3RpdGxlJyxcblxuXHRldmVudExpbWl0OiBmYWxzZSxcblx0ZXZlbnRMaW1pdFRleHQ6ICdtb3JlJyxcblx0ZXZlbnRMaW1pdENsaWNrOiAncG9wb3ZlcicsXG5cdGRheVBvcG92ZXJGb3JtYXQ6ICdMTCcsXG5cdFxuXHRoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXG5cdHdpbmRvd1Jlc2l6ZURlbGF5OiAyMDAsIC8vIG1pbGxpc2Vjb25kcyBiZWZvcmUgYW4gdXBkYXRlU2l6ZSBoYXBwZW5zXG5cblx0bG9uZ1ByZXNzRGVsYXk6IDEwMDBcblx0XG59O1xuXG5cbkNhbGVuZGFyLmVuZ2xpc2hEZWZhdWx0cyA9IHsgLy8gdXNlZCBieSBsYW5nLmpzXG5cdGRheVBvcG92ZXJGb3JtYXQ6ICdkZGRkLCBNTU1NIEQnXG59O1xuXG5cbkNhbGVuZGFyLnJ0bERlZmF1bHRzID0geyAvLyByaWdodC10by1sZWZ0IGRlZmF1bHRzXG5cdGhlYWRlcjogeyAvLyBUT0RPOiBzbWFydGVyIHNvbHV0aW9uIChmaXJzdC9jZW50ZXIvbGFzdCA/KVxuXHRcdGxlZnQ6ICduZXh0LHByZXYgdG9kYXknLFxuXHRcdGNlbnRlcjogJycsXG5cdFx0cmlnaHQ6ICd0aXRsZSdcblx0fSxcblx0YnV0dG9uSWNvbnM6IHtcblx0XHRwcmV2OiAncmlnaHQtc2luZ2xlLWFycm93Jyxcblx0XHRuZXh0OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxuXHRcdHByZXZZZWFyOiAncmlnaHQtZG91YmxlLWFycm93Jyxcblx0XHRuZXh0WWVhcjogJ2xlZnQtZG91YmxlLWFycm93J1xuXHR9LFxuXHR0aGVtZUJ1dHRvbkljb25zOiB7XG5cdFx0cHJldjogJ2NpcmNsZS10cmlhbmdsZS1lJyxcblx0XHRuZXh0OiAnY2lyY2xlLXRyaWFuZ2xlLXcnLFxuXHRcdG5leHRZZWFyOiAnc2Vlay1wcmV2Jyxcblx0XHRwcmV2WWVhcjogJ3NlZWstbmV4dCdcblx0fVxufTtcblxuOztcblxudmFyIGxhbmdPcHRpb25IYXNoID0gRkMubGFuZ3MgPSB7fTsgLy8gaW5pdGlhbGl6ZSBhbmQgZXhwb3NlXG5cblxuLy8gVE9ETzogZG9jdW1lbnQgdGhlIHN0cnVjdHVyZSBhbmQgb3JkZXJpbmcgb2YgYSBGdWxsQ2FsZW5kYXIgbGFuZyBmaWxlXG4vLyBUT0RPOiByZW5hbWUgZXZlcnl0aGluZyBcImxhbmdcIiB0byBcImxvY2FsZVwiLCBsaWtlIHdoYXQgdGhlIG1vbWVudCBwcm9qZWN0IGRpZFxuXG5cbi8vIEluaXRpYWxpemUgalF1ZXJ5IFVJIGRhdGVwaWNrZXIgdHJhbnNsYXRpb25zIHdoaWxlIHVzaW5nIHNvbWUgb2YgdGhlIHRyYW5zbGF0aW9uc1xuLy8gV2lsbCBzZXQgdGhpcyBhcyB0aGUgZGVmYXVsdCBsYW5ndWFnZSBmb3IgZGF0ZXBpY2tlci5cbkZDLmRhdGVwaWNrZXJMYW5nID0gZnVuY3Rpb24obGFuZ0NvZGUsIGRwTGFuZ0NvZGUsIGRwT3B0aW9ucykge1xuXG5cdC8vIGdldCB0aGUgRnVsbENhbGVuZGFyIGludGVybmFsIG9wdGlvbiBoYXNoIGZvciB0aGlzIGxhbmd1YWdlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XG5cdHZhciBmY09wdGlvbnMgPSBsYW5nT3B0aW9uSGFzaFtsYW5nQ29kZV0gfHwgKGxhbmdPcHRpb25IYXNoW2xhbmdDb2RlXSA9IHt9KTtcblxuXHQvLyB0cmFuc2ZlciBzb21lIHNpbXBsZSBvcHRpb25zIGZyb20gZGF0ZXBpY2tlciB0byBmY1xuXHRmY09wdGlvbnMuaXNSVEwgPSBkcE9wdGlvbnMuaXNSVEw7XG5cdGZjT3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgPSBkcE9wdGlvbnMud2Vla0hlYWRlcjtcblxuXHQvLyBjb21wdXRlIHNvbWUgbW9yZSBjb21wbGV4IG9wdGlvbnMgZnJvbSBkYXRlcGlja2VyXG5cdCQuZWFjaChkcENvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG5cdFx0ZmNPcHRpb25zW25hbWVdID0gZnVuYyhkcE9wdGlvbnMpO1xuXHR9KTtcblxuXHQvLyBpcyBqUXVlcnkgVUkgRGF0ZXBpY2tlciBpcyBvbiB0aGUgcGFnZT9cblx0aWYgKCQuZGF0ZXBpY2tlcikge1xuXG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIGxhbmd1YWdlIGRhdGEuXG5cdFx0Ly8gRnVsbENhbGVuZGFyIGFuZCBNb21lbnRKUyB1c2UgbGFuZ3VhZ2UgY29kZXMgbGlrZSBcInB0LWJyXCIgYnV0IERhdGVwaWNrZXJcblx0XHQvLyBkb2VzIGl0IGxpa2UgXCJwdC1CUlwiIG9yIGlmIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgbGFuZ3VhZ2UsIG1heWJlIGp1c3QgXCJwdFwiLlxuXHRcdC8vIE1ha2UgYW4gYWxpYXMgc28gdGhlIGxhbmd1YWdlIGNhbiBiZSByZWZlcmVuY2VkIGVpdGhlciB3YXkuXG5cdFx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsW2RwTGFuZ0NvZGVdID1cblx0XHRcdCQuZGF0ZXBpY2tlci5yZWdpb25hbFtsYW5nQ29kZV0gPSAvLyBhbGlhc1xuXHRcdFx0XHRkcE9wdGlvbnM7XG5cblx0XHQvLyBBbGlhcyAnZW4nIHRvIHRoZSBkZWZhdWx0IGxhbmd1YWdlIGRhdGEuIERvIHRoaXMgZXZlcnkgdGltZS5cblx0XHQkLmRhdGVwaWNrZXIucmVnaW9uYWwuZW4gPSAkLmRhdGVwaWNrZXIucmVnaW9uYWxbJyddO1xuXG5cdFx0Ly8gU2V0IGFzIERhdGVwaWNrZXIncyBnbG9iYWwgZGVmYXVsdHMuXG5cdFx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKGRwT3B0aW9ucyk7XG5cdH1cbn07XG5cblxuLy8gU2V0cyBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgdHJhbnNsYXRpb25zLiBXaWxsIHNldCB0aGUgbGFuZ3VhZ2UgYXMgdGhlIGdsb2JhbCBkZWZhdWx0LlxuRkMubGFuZyA9IGZ1bmN0aW9uKGxhbmdDb2RlLCBuZXdGY09wdGlvbnMpIHtcblx0dmFyIGZjT3B0aW9ucztcblx0dmFyIG1vbU9wdGlvbnM7XG5cblx0Ly8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbGFuZ3VhZ2UuIGNyZWF0ZSBpZiBuZWNlc3Nhcnlcblx0ZmNPcHRpb25zID0gbGFuZ09wdGlvbkhhc2hbbGFuZ0NvZGVdIHx8IChsYW5nT3B0aW9uSGFzaFtsYW5nQ29kZV0gPSB7fSk7XG5cblx0Ly8gcHJvdmlkZWQgbmV3IG9wdGlvbnMgZm9yIHRoaXMgbGFuZ3VhZ2U/IG1lcmdlIHRoZW0gaW5cblx0aWYgKG5ld0ZjT3B0aW9ucykge1xuXHRcdGZjT3B0aW9ucyA9IGxhbmdPcHRpb25IYXNoW2xhbmdDb2RlXSA9IG1lcmdlT3B0aW9ucyhbIGZjT3B0aW9ucywgbmV3RmNPcHRpb25zIF0pO1xuXHR9XG5cblx0Ly8gY29tcHV0ZSBsYW5ndWFnZSBvcHRpb25zIHRoYXQgd2VyZW4ndCBkZWZpbmVkLlxuXHQvLyBhbHdheXMgZG8gdGhpcy4gbmV3RmNPcHRpb25zIGNhbiBiZSB1bmRlZmluZWQgd2hlbiBpbml0aWFsaXppbmcgZnJvbSBpMThuIGZpbGUsXG5cdC8vIHNvIG5vIHdheSB0byB0ZWxsIGlmIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gb3IgYSBkZWZhdWx0LXNldHRpbmcuXG5cdG1vbU9wdGlvbnMgPSBnZXRNb21lbnRMb2NhbGVEYXRhKGxhbmdDb2RlKTsgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cblx0JC5lYWNoKG1vbUNvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG5cdFx0aWYgKGZjT3B0aW9uc1tuYW1lXSA9PSBudWxsKSB7XG5cdFx0XHRmY09wdGlvbnNbbmFtZV0gPSBmdW5jKG1vbU9wdGlvbnMsIGZjT3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBzZXQgaXQgYXMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgZm9yIEZ1bGxDYWxlbmRhclxuXHRDYWxlbmRhci5kZWZhdWx0cy5sYW5nID0gbGFuZ0NvZGU7XG59O1xuXG5cbi8vIE5PVEU6IGNhbid0IGd1YXJhbnRlZSBhbnkgb2YgdGhlc2UgY29tcHV0YXRpb25zIHdpbGwgcnVuIGJlY2F1c2Ugbm90IGV2ZXJ5IGxhbmd1YWdlIGhhcyBkYXRlcGlja2VyXG4vLyBjb25maWdzLCBzbyBtYWtlIHN1cmUgdGhlcmUgYXJlIEVuZ2xpc2ggZmFsbGJhY2tzIGZvciB0aGVzZSBpbiB0aGUgZGVmYXVsdHMgZmlsZS5cbnZhciBkcENvbXB1dGFibGVPcHRpb25zID0ge1xuXG5cdGJ1dHRvblRleHQ6IGZ1bmN0aW9uKGRwT3B0aW9ucykge1xuXHRcdHJldHVybiB7XG5cdFx0XHQvLyB0aGUgdHJhbnNsYXRpb25zIHNvbWV0aW1lcyB3cm9uZ2x5IGNvbnRhaW4gSFRNTCBlbnRpdGllc1xuXHRcdFx0cHJldjogc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLnByZXZUZXh0KSxcblx0XHRcdG5leHQ6IHN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5uZXh0VGV4dCksXG5cdFx0XHR0b2RheTogc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLmN1cnJlbnRUZXh0KVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcIk1NTU0gWVlZWVwiIC0+IFwiU2VwdGVtYmVyIDIwMTRcIlxuXHRtb250aFllYXJGb3JtYXQ6IGZ1bmN0aW9uKGRwT3B0aW9ucykge1xuXHRcdHJldHVybiBkcE9wdGlvbnMuc2hvd01vbnRoQWZ0ZXJZZWFyID9cblx0XHRcdCdZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddIE1NTU0nIDpcblx0XHRcdCdNTU1NIFlZWVlbJyArIGRwT3B0aW9ucy55ZWFyU3VmZml4ICsgJ10nO1xuXHR9XG5cbn07XG5cbnZhciBtb21Db21wdXRhYmxlT3B0aW9ucyA9IHtcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiZGRkIE0vRFwiIC0+IFwiRnJpIDkvMTVcIlxuXHRkYXlPZk1vbnRoRm9ybWF0OiBmdW5jdGlvbihtb21PcHRpb25zLCBmY09wdGlvbnMpIHtcblx0XHR2YXIgZm9ybWF0ID0gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnbCcpOyAvLyBmb3IgdGhlIGZvcm1hdCBsaWtlIFwiTS9EL1lZWVlcIlxuXG5cdFx0Ly8gc3RyaXAgdGhlIHllYXIgb2ZmIHRoZSBlZGdlLCBhcyB3ZWxsIGFzIG90aGVyIG1pc2Mgbm9uLXdoaXRlc3BhY2UgY2hhcnNcblx0XHRmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXlkrW15cXHdcXHNdKnxbXlxcd1xcc10qWSskL2csICcnKTtcblxuXHRcdGlmIChmY09wdGlvbnMuaXNSVEwpIHtcblx0XHRcdGZvcm1hdCArPSAnIGRkZCc7IC8vIGZvciBSVEwsIGFkZCBkYXktb2Ytd2VlayB0byBlbmRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3JtYXQgPSAnZGRkICcgKyBmb3JtYXQ7IC8vIGZvciBMVFIsIGFkZCBkYXktb2Ytd2VlayB0byBiZWdpbm5pbmdcblx0XHR9XG5cdFx0cmV0dXJuIGZvcm1hdDtcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbWFcIiAtPiBcIjY6MDBwbVwiXG5cdG1lZGl1bVRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHsgLy8gY2FuJ3QgYmUgY2FsbGVkIGB0aW1lRm9ybWF0YCBiZWNhdXNlIGNvbGxpZGVzIHdpdGggb3B0aW9uXG5cdFx0cmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcblx0XHRcdC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaCg6bW0pYVwiIC0+IFwiNnBtXCIgLyBcIjY6MzBwbVwiXG5cdHNtYWxsVGltZUZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucykge1xuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgnOm1tJywgJyg6bW0pJylcblx0XHRcdC5yZXBsYWNlKC8oXFxXbW0pJC8sICcoJDEpJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxhbmdzXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKXRcIiAtPiBcIjZwXCIgLyBcIjY6MzBwXCJcblx0ZXh0cmFTbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcoOm1tKScpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsYW5nc1xuXHRcdFx0LnJlcGxhY2UoL1xccyphJC9pLCAndCcpOyAvLyBjb252ZXJ0IHRvIEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZSBvbmUtbGV0dGVyLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImhhXCIgLyBcIkhcIiAtPiBcIjZwbVwiIC8gXCIxOFwiXG5cdGhvdXJGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcnKVxuXHRcdFx0LnJlcGxhY2UoLyhcXFdtbSkkLywgJycpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsYW5nc1xuXHRcdFx0LnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoOm1tXCIgLT4gXCI2OjMwXCIgKHdpdGggbm8gQU0vUE0pXG5cdG5vTWVyaWRpZW1UaW1lRm9ybWF0OiBmdW5jdGlvbihtb21PcHRpb25zKSB7XG5cdFx0cmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcblx0XHRcdC5yZXBsYWNlKC9cXHMqYSQvaSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgQU0vUE1cblx0fVxuXG59O1xuXG5cbi8vIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgY29tcHV0ZWQgb2ZmIGxpdmUgY2FsZW5kYXIgb3B0aW9ucyAoY29uc2lkZXJzIG92ZXJyaWRlIG9wdGlvbnMpXG4vLyBUT0RPOiBiZXN0IHBsYWNlIGZvciB0aGlzPyByZWxhdGVkIHRvIGxhbmc/XG4vLyBUT0RPOiBmbGlwcGluZyB0ZXh0IGJhc2VkIG9uIGlzUlRMIGlzIGEgYmFkIGlkZWEgYmVjYXVzZSB0aGUgQ1NTIGBkaXJlY3Rpb25gIG1pZ2h0IHdhbnQgdG8gaGFuZGxlIGl0XG52YXIgaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHtcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiTW8gMTZcIlxuXHRzbWFsbERheURhdGVGb3JtYXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5pc1JUTCA/XG5cdFx0XHQnRCBkZCcgOlxuXHRcdFx0J2RkIEQnO1xuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXayA1XCJcblx0d2Vla0Zvcm1hdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLmlzUlRMID9cblx0XHRcdCd3WyAnICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxuXHRcdFx0J1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnIF13Jztcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2s1XCJcblx0c21hbGxXZWVrRm9ybWF0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xuXHRcdFx0J3dbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcblx0XHRcdCdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ113Jztcblx0fVxuXG59O1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMob3B0aW9ucykge1xuXHQkLmVhY2goaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGlmIChvcHRpb25zW25hbWVdID09IG51bGwpIHtcblx0XHRcdG9wdGlvbnNbbmFtZV0gPSBmdW5jKG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59XG5cblxuLy8gUmV0dXJucyBtb21lbnQncyBpbnRlcm5hbCBsb2NhbGUgZGF0YS4gSWYgZG9lc24ndCBleGlzdCwgcmV0dXJucyBFbmdsaXNoLlxuLy8gV29ya3Mgd2l0aCBtb21lbnQtcHJlLTIuOFxuZnVuY3Rpb24gZ2V0TW9tZW50TG9jYWxlRGF0YShsYW5nQ29kZSkge1xuXHR2YXIgZnVuYyA9IG1vbWVudC5sb2NhbGVEYXRhIHx8IG1vbWVudC5sYW5nRGF0YTtcblx0cmV0dXJuIGZ1bmMuY2FsbChtb21lbnQsIGxhbmdDb2RlKSB8fFxuXHRcdGZ1bmMuY2FsbChtb21lbnQsICdlbicpOyAvLyB0aGUgbmV3ZXIgbG9jYWxEYXRhIGNvdWxkIHJldHVybiBudWxsLCBzbyBmYWxsIGJhY2sgdG8gZW5cbn1cblxuXG4vLyBJbml0aWFsaXplIEVuZ2xpc2ggYnkgZm9yY2luZyBjb21wdXRhdGlvbiBvZiBtb21lbnQtZGVyaXZlZCBvcHRpb25zLlxuLy8gQWxzbywgc2V0cyBpdCBhcyB0aGUgZGVmYXVsdC5cbkZDLmxhbmcoJ2VuJywgQ2FsZW5kYXIuZW5nbGlzaERlZmF1bHRzKTtcblxuOztcblxuLyogVG9wIHRvb2xiYXIgYXJlYSB3aXRoIGJ1dHRvbnMgYW5kIHRpdGxlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFRPRE86IHJlbmFtZSBhbGwgaGVhZGVyLXJlbGF0ZWQgdGhpbmdzIHRvIFwidG9vbGJhclwiXG5cbmZ1bmN0aW9uIEhlYWRlcihjYWxlbmRhcikge1xuXHR2YXIgdCA9IHRoaXM7XG5cdFxuXHQvLyBleHBvcnRzXG5cdHQucmVuZGVyID0gcmVuZGVyO1xuXHR0LnJlbW92ZUVsZW1lbnQgPSByZW1vdmVFbGVtZW50O1xuXHR0LnVwZGF0ZVRpdGxlID0gdXBkYXRlVGl0bGU7XG5cdHQuYWN0aXZhdGVCdXR0b24gPSBhY3RpdmF0ZUJ1dHRvbjtcblx0dC5kZWFjdGl2YXRlQnV0dG9uID0gZGVhY3RpdmF0ZUJ1dHRvbjtcblx0dC5kaXNhYmxlQnV0dG9uID0gZGlzYWJsZUJ1dHRvbjtcblx0dC5lbmFibGVCdXR0b24gPSBlbmFibGVCdXR0b247XG5cdHQuZ2V0Vmlld3NXaXRoQnV0dG9ucyA9IGdldFZpZXdzV2l0aEJ1dHRvbnM7XG5cdHQuZWwgPSBudWxsOyAvLyBtaXJyb3JzIGxvY2FsIGBlbGBcblx0XG5cdC8vIGxvY2Fsc1xuXHR2YXIgZWw7XG5cdHZhciB2aWV3c1dpdGhCdXR0b25zID0gW107XG5cdHZhciB0bTtcblxuXG5cdC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgd2lsbCByZXJlbmRlclxuXHRmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBjYWxlbmRhci5vcHRpb25zO1xuXHRcdHZhciBzZWN0aW9ucyA9IG9wdGlvbnMuaGVhZGVyO1xuXG5cdFx0dG0gPSBvcHRpb25zLnRoZW1lID8gJ3VpJyA6ICdmYyc7XG5cblx0XHRpZiAoc2VjdGlvbnMpIHtcblx0XHRcdGlmICghZWwpIHtcblx0XHRcdFx0ZWwgPSB0aGlzLmVsID0gJChcIjxkaXYgY2xhc3M9J2ZjLXRvb2xiYXInLz5cIik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZWwuZW1wdHkoKTtcblx0XHRcdH1cblx0XHRcdGVsLmFwcGVuZChyZW5kZXJTZWN0aW9uKCdsZWZ0JykpXG5cdFx0XHRcdC5hcHBlbmQocmVuZGVyU2VjdGlvbigncmlnaHQnKSlcblx0XHRcdFx0LmFwcGVuZChyZW5kZXJTZWN0aW9uKCdjZW50ZXInKSlcblx0XHRcdFx0LmFwcGVuZCgnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZUVsZW1lbnQoKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiByZW1vdmVFbGVtZW50KCkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwucmVtb3ZlKCk7XG5cdFx0XHRlbCA9IHQuZWwgPSBudWxsO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24ocG9zaXRpb24pIHtcblx0XHR2YXIgc2VjdGlvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBwb3NpdGlvbiArICdcIi8+Jyk7XG5cdFx0dmFyIG9wdGlvbnMgPSBjYWxlbmRhci5vcHRpb25zO1xuXHRcdHZhciBidXR0b25TdHIgPSBvcHRpb25zLmhlYWRlcltwb3NpdGlvbl07XG5cblx0XHRpZiAoYnV0dG9uU3RyKSB7XG5cdFx0XHQkLmVhY2goYnV0dG9uU3RyLnNwbGl0KCcgJyksIGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIGdyb3VwQ2hpbGRyZW4gPSAkKCk7XG5cdFx0XHRcdHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGdyb3VwRWw7XG5cblx0XHRcdFx0JC5lYWNoKHRoaXMuc3BsaXQoJywnKSwgZnVuY3Rpb24oaiwgYnV0dG9uTmFtZSkge1xuXHRcdFx0XHRcdHZhciBjdXN0b21CdXR0b25Qcm9wcztcblx0XHRcdFx0XHR2YXIgdmlld1NwZWM7XG5cdFx0XHRcdFx0dmFyIGJ1dHRvbkNsaWNrO1xuXHRcdFx0XHRcdHZhciBvdmVycmlkZVRleHQ7IC8vIHRleHQgZXhwbGljaXRseSBzZXQgYnkgY2FsZW5kYXIncyBjb25zdHJ1Y3RvciBvcHRpb25zLiBvdmVyY29tZXMgaWNvbnNcblx0XHRcdFx0XHR2YXIgZGVmYXVsdFRleHQ7XG5cdFx0XHRcdFx0dmFyIHRoZW1lSWNvbjtcblx0XHRcdFx0XHR2YXIgbm9ybWFsSWNvbjtcblx0XHRcdFx0XHR2YXIgaW5uZXJIdG1sO1xuXHRcdFx0XHRcdHZhciBjbGFzc2VzO1xuXHRcdFx0XHRcdHZhciBidXR0b247IC8vIHRoZSBlbGVtZW50XG5cblx0XHRcdFx0XHRpZiAoYnV0dG9uTmFtZSA9PSAndGl0bGUnKSB7XG5cdFx0XHRcdFx0XHRncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoJCgnPGgyPiZuYnNwOzwvaDI+JykpOyAvLyB3ZSBhbHdheXMgd2FudCBpdCB0byB0YWtlIHVwIGhlaWdodFxuXHRcdFx0XHRcdFx0aXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSAob3B0aW9ucy5jdXN0b21CdXR0b25zIHx8IHt9KVtidXR0b25OYW1lXSkpIHtcblx0XHRcdFx0XHRcdFx0YnV0dG9uQ2xpY2sgPSBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChidXR0b25bMF0sIGV2KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdG92ZXJyaWRlVGV4dCA9ICcnOyAvLyBpY29ucyB3aWxsIG92ZXJyaWRlIHRleHRcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoKHZpZXdTcGVjID0gY2FsZW5kYXIuZ2V0Vmlld1NwZWMoYnV0dG9uTmFtZSkpKSB7XG5cdFx0XHRcdFx0XHRcdGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsZW5kYXIuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0dmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xuXHRcdFx0XHRcdFx0XHRvdmVycmlkZVRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGU7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRUZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChjYWxlbmRhcltidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyIG1ldGhvZFxuXHRcdFx0XHRcdFx0XHRidXR0b25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGVuZGFyW2J1dHRvbk5hbWVdKCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdG92ZXJyaWRlVGV4dCA9IChjYWxlbmRhci5vdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fSlbYnV0dG9uTmFtZV07XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRUZXh0ID0gb3B0aW9ucy5idXR0b25UZXh0W2J1dHRvbk5hbWVdOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChidXR0b25DbGljaykge1xuXG5cdFx0XHRcdFx0XHRcdHRoZW1lSWNvbiA9XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQnV0dG9uUHJvcHMgP1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQnV0dG9uUHJvcHMudGhlbWVJY29uIDpcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMudGhlbWVCdXR0b25JY29uc1tidXR0b25OYW1lXTtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxJY29uID1cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcyA/XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcy5pY29uIDpcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMuYnV0dG9uSWNvbnNbYnV0dG9uTmFtZV07XG5cblx0XHRcdFx0XHRcdFx0aWYgKG92ZXJyaWRlVGV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IGh0bWxFc2NhcGUob3ZlcnJpZGVUZXh0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmICh0aGVtZUljb24gJiYgb3B0aW9ucy50aGVtZSkge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IFwiPHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1cIiArIHRoZW1lSWNvbiArIFwiJz48L3NwYW4+XCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAobm9ybWFsSWNvbiAmJiAhb3B0aW9ucy50aGVtZSkge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IFwiPHNwYW4gY2xhc3M9J2ZjLWljb24gZmMtaWNvbi1cIiArIG5vcm1hbEljb24gKyBcIic+PC9zcGFuPlwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IGh0bWxFc2NhcGUoZGVmYXVsdFRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Y2xhc3NlcyA9IFtcblx0XHRcdFx0XHRcdFx0XHQnZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicsXG5cdFx0XHRcdFx0XHRcdFx0dG0gKyAnLWJ1dHRvbicsXG5cdFx0XHRcdFx0XHRcdFx0dG0gKyAnLXN0YXRlLWRlZmF1bHQnXG5cdFx0XHRcdFx0XHRcdF07XG5cblx0XHRcdFx0XHRcdFx0YnV0dG9uID0gJCggLy8gdHlwZT1cImJ1dHRvblwiIHNvIHRoYXQgaXQgZG9lc24ndCBzdWJtaXQgYSBmb3JtXG5cdFx0XHRcdFx0XHRcdFx0JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sICtcblx0XHRcdFx0XHRcdFx0XHQnPC9idXR0b24+J1xuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHQuY2xpY2soZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGRvbid0IHByb2Nlc3MgY2xpY2tzIGZvciBkaXNhYmxlZCBidXR0b25zXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWJ1dHRvbi5oYXNDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKSkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvbkNsaWNrKGV2KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciB0aGUgY2xpY2sgYWN0aW9uLCBpZiB0aGUgYnV0dG9uIGJlY29tZXMgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaXQgc2hvdWxkIG5ldmVyIGhhdmUgYSBob3ZlciBjbGFzcywgc28gcmVtb3ZlIGl0IG5vdy5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvbi5oYXNDbGFzcyh0bSArICctc3RhdGUtYWN0aXZlJykgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b24uaGFzQ2xhc3ModG0gKyAnLXN0YXRlLWRpc2FibGVkJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uLnJlbW92ZUNsYXNzKHRtICsgJy1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQubW91c2Vkb3duKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlICpkb3duKiBlZmZlY3QgKG1vdXNlIHByZXNzZWQgaW4pLlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm5vdCgnLicgKyB0bSArICctc3RhdGUtYWN0aXZlJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm5vdCgnLicgKyB0bSArICctc3RhdGUtZGlzYWJsZWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWRvd24nKTtcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5tb3VzZXVwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdW5kbyB0aGUgKmRvd24qIGVmZmVjdFxuXHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uLnJlbW92ZUNsYXNzKHRtICsgJy1zdGF0ZS1kb3duJyk7XG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQuaG92ZXIoXG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlICpob3ZlciogZWZmZWN0LlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lm5vdCgnLicgKyB0bSArICctc3RhdGUtYWN0aXZlJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKHRtICsgJy1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB1bmRvIHRoZSAqaG92ZXIqIGVmZmVjdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWhvdmVyJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWRvd24nKTsgLy8gaWYgbW91c2VsZWF2ZSBoYXBwZW5zIGJlZm9yZSBtb3VzZXVwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoYnV0dG9uKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChpc09ubHlCdXR0b25zKSB7XG5cdFx0XHRcdFx0Z3JvdXBDaGlsZHJlblxuXHRcdFx0XHRcdFx0LmZpcnN0KCkuYWRkQ2xhc3ModG0gKyAnLWNvcm5lci1sZWZ0JykuZW5kKClcblx0XHRcdFx0XHRcdC5sYXN0KCkuYWRkQ2xhc3ModG0gKyAnLWNvcm5lci1yaWdodCcpLmVuZCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGdyb3VwQ2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGdyb3VwRWwgPSAkKCc8ZGl2Lz4nKTtcblx0XHRcdFx0XHRpZiAoaXNPbmx5QnV0dG9ucykge1xuXHRcdFx0XHRcdFx0Z3JvdXBFbC5hZGRDbGFzcygnZmMtYnV0dG9uLWdyb3VwJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdyb3VwRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pO1xuXHRcdFx0XHRcdHNlY3Rpb25FbC5hcHBlbmQoZ3JvdXBFbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c2VjdGlvbkVsLmFwcGVuZChncm91cENoaWxkcmVuKTsgLy8gMSBvciAwIGNoaWxkcmVuXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWN0aW9uRWw7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiB1cGRhdGVUaXRsZSh0ZXh0KSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCdoMicpLnRleHQodGV4dCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gYWN0aXZhdGVCdXR0b24oYnV0dG9uTmFtZSkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxuXHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWFjdGl2ZScpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGRlYWN0aXZhdGVCdXR0b24oYnV0dG9uTmFtZSkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWFjdGl2ZScpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGRpc2FibGVCdXR0b24oYnV0dG9uTmFtZSkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxuXHRcdFx0XHQucHJvcCgnZGlzYWJsZWQnLCB0cnVlKVxuXHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWRpc2FibGVkJyk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZW5hYmxlQnV0dG9uKGJ1dHRvbk5hbWUpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcblx0XHRcdFx0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldFZpZXdzV2l0aEJ1dHRvbnMoKSB7XG5cdFx0cmV0dXJuIHZpZXdzV2l0aEJ1dHRvbnM7XG5cdH1cblxufVxuXG47O1xuXG5GQy5zb3VyY2VOb3JtYWxpemVycyA9IFtdO1xuRkMuc291cmNlRmV0Y2hlcnMgPSBbXTtcblxudmFyIGFqYXhEZWZhdWx0cyA9IHtcblx0ZGF0YVR5cGU6ICdqc29uJyxcblx0Y2FjaGU6IGZhbHNlXG59O1xuXG52YXIgZXZlbnRHVUlEID0gMTtcblxuXG5mdW5jdGlvbiBFdmVudE1hbmFnZXIoKSB7IC8vIGFzc3VtZWQgdG8gYmUgYSBjYWxlbmRhclxuXHR2YXIgdCA9IHRoaXM7XG5cdFxuXHRcblx0Ly8gZXhwb3J0c1xuXHR0LmlzRmV0Y2hOZWVkZWQgPSBpc0ZldGNoTmVlZGVkO1xuXHR0LmZldGNoRXZlbnRzID0gZmV0Y2hFdmVudHM7XG5cdHQuZmV0Y2hFdmVudFNvdXJjZXMgPSBmZXRjaEV2ZW50U291cmNlcztcblx0dC5nZXRFdmVudFNvdXJjZXMgPSBnZXRFdmVudFNvdXJjZXM7XG5cdHQuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZ2V0RXZlbnRTb3VyY2VCeUlkO1xuXHR0LmdldEV2ZW50U291cmNlc0J5TWF0Y2hBcnJheSA9IGdldEV2ZW50U291cmNlc0J5TWF0Y2hBcnJheTtcblx0dC5nZXRFdmVudFNvdXJjZXNCeU1hdGNoID0gZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaDtcblx0dC5hZGRFdmVudFNvdXJjZSA9IGFkZEV2ZW50U291cmNlO1xuXHR0LnJlbW92ZUV2ZW50U291cmNlID0gcmVtb3ZlRXZlbnRTb3VyY2U7XG5cdHQucmVtb3ZlRXZlbnRTb3VyY2VzID0gcmVtb3ZlRXZlbnRTb3VyY2VzO1xuXHR0LnVwZGF0ZUV2ZW50ID0gdXBkYXRlRXZlbnQ7XG5cdHQucmVuZGVyRXZlbnQgPSByZW5kZXJFdmVudDtcblx0dC5yZW1vdmVFdmVudHMgPSByZW1vdmVFdmVudHM7XG5cdHQuY2xpZW50RXZlbnRzID0gY2xpZW50RXZlbnRzO1xuXHR0Lm11dGF0ZUV2ZW50ID0gbXV0YXRlRXZlbnQ7XG5cdHQubm9ybWFsaXplRXZlbnREYXRlcyA9IG5vcm1hbGl6ZUV2ZW50RGF0ZXM7XG5cdHQubm9ybWFsaXplRXZlbnRUaW1lcyA9IG5vcm1hbGl6ZUV2ZW50VGltZXM7XG5cdFxuXHRcblx0Ly8gaW1wb3J0c1xuXHR2YXIgcmVwb3J0RXZlbnRzID0gdC5yZXBvcnRFdmVudHM7XG5cdFxuXHRcblx0Ly8gbG9jYWxzXG5cdHZhciBzdGlja3lTb3VyY2UgPSB7IGV2ZW50czogW10gfTtcblx0dmFyIHNvdXJjZXMgPSBbIHN0aWNreVNvdXJjZSBdO1xuXHR2YXIgcmFuZ2VTdGFydCwgcmFuZ2VFbmQ7XG5cdHZhciBwZW5kaW5nU291cmNlQ250ID0gMDsgLy8gb3V0c3RhbmRpbmcgZmV0Y2ggcmVxdWVzdHMsIG1heCBvbmUgcGVyIHNvdXJjZVxuXHR2YXIgY2FjaGUgPSBbXTsgLy8gaG9sZHMgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZXhwYW5kZWRcblxuXG5cdCQuZWFjaChcblx0XHQodC5vcHRpb25zLmV2ZW50cyA/IFsgdC5vcHRpb25zLmV2ZW50cyBdIDogW10pLmNvbmNhdCh0Lm9wdGlvbnMuZXZlbnRTb3VyY2VzIHx8IFtdKSxcblx0XHRmdW5jdGlvbihpLCBzb3VyY2VJbnB1dCkge1xuXHRcdFx0dmFyIHNvdXJjZSA9IGJ1aWxkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpO1xuXHRcdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG5cdFxuXHRcblx0XG5cdC8qIEZldGNoaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIHN0YXJ0IGFuZCBlbmQgYXJlIGFzc3VtZWQgdG8gYmUgdW56b25lZFxuXHRmdW5jdGlvbiBpc0ZldGNoTmVlZGVkKHN0YXJ0LCBlbmQpIHtcblx0XHRyZXR1cm4gIXJhbmdlU3RhcnQgfHwgLy8gbm90aGluZyBoYXMgYmVlbiBmZXRjaGVkIHlldD9cblx0XHRcdHN0YXJ0IDwgcmFuZ2VTdGFydCB8fCBlbmQgPiByYW5nZUVuZDsgLy8gaXMgcGFydCBvZiB0aGUgbmV3IHJhbmdlIG91dHNpZGUgb2YgdGhlIG9sZCByYW5nZT9cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGZldGNoRXZlbnRzKHN0YXJ0LCBlbmQpIHtcblx0XHRyYW5nZVN0YXJ0ID0gc3RhcnQ7XG5cdFx0cmFuZ2VFbmQgPSBlbmQ7XG5cdFx0ZmV0Y2hFdmVudFNvdXJjZXMoc291cmNlcywgJ3Jlc2V0Jyk7XG5cdH1cblxuXG5cdC8vIGV4cGVjdHMgYW4gYXJyYXkgb2YgZXZlbnQgc291cmNlIG9iamVjdHMgKHRoZSBvcmlnaW5hbHMsIG5vdCBjb3BpZXMpXG5cdC8vIGBzcGVjaWFsRmV0Y2hUeXBlYCBpcyBhbiBvcHRpbWl6YXRpb24gcGFyYW1ldGVyIHRoYXQgYWZmZWN0cyBwdXJnaW5nIG9mIHRoZSBldmVudCBjYWNoZS5cblx0ZnVuY3Rpb24gZmV0Y2hFdmVudFNvdXJjZXMoc3BlY2lmaWNTb3VyY2VzLCBzcGVjaWFsRmV0Y2hUeXBlKSB7XG5cdFx0dmFyIGksIHNvdXJjZTtcblxuXHRcdGlmIChzcGVjaWFsRmV0Y2hUeXBlID09PSAncmVzZXQnKSB7XG5cdFx0XHRjYWNoZSA9IFtdO1xuXHRcdH1cblx0XHRlbHNlIGlmIChzcGVjaWFsRmV0Y2hUeXBlICE9PSAnYWRkJykge1xuXHRcdFx0Y2FjaGUgPSBleGNsdWRlRXZlbnRzQnlTb3VyY2VzKGNhY2hlLCBzcGVjaWZpY1NvdXJjZXMpO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGVjaWZpY1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNvdXJjZSA9IHNwZWNpZmljU291cmNlc1tpXTtcblxuXHRcdFx0Ly8gYWxyZWFkeS1wZW5kaW5nIHNvdXJjZXMgaGF2ZSBhbHJlYWR5IGJlZW4gYWNjb3VudGVkIGZvciBpbiBwZW5kaW5nU291cmNlQ250XG5cdFx0XHRpZiAoc291cmNlLl9zdGF0dXMgIT09ICdwZW5kaW5nJykge1xuXHRcdFx0XHRwZW5kaW5nU291cmNlQ250Kys7XG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZS5fZmV0Y2hJZCA9IChzb3VyY2UuX2ZldGNoSWQgfHwgMCkgKyAxO1xuXHRcdFx0c291cmNlLl9zdGF0dXMgPSAncGVuZGluZyc7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwZWNpZmljU291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c291cmNlID0gc3BlY2lmaWNTb3VyY2VzW2ldO1xuXG5cdFx0XHR0cnlGZXRjaEV2ZW50U291cmNlKHNvdXJjZSwgc291cmNlLl9mZXRjaElkKTtcblx0XHR9XG5cdH1cblxuXG5cdC8vIGZldGNoZXMgYW4gZXZlbnQgc291cmNlIGFuZCBwcm9jZXNzZXMgaXRzIHJlc3VsdCBPTkxZIGlmIGl0IGlzIHN0aWxsIHRoZSBjdXJyZW50IGZldGNoLlxuXHQvLyBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGluY3JlbWVudGluZyBwZW5kaW5nU291cmNlQ250IGZpcnN0LlxuXHRmdW5jdGlvbiB0cnlGZXRjaEV2ZW50U291cmNlKHNvdXJjZSwgZmV0Y2hJZCkge1xuXHRcdF9mZXRjaEV2ZW50U291cmNlKHNvdXJjZSwgZnVuY3Rpb24oZXZlbnRJbnB1dHMpIHtcblx0XHRcdHZhciBpc0FycmF5U291cmNlID0gJC5pc0FycmF5KHNvdXJjZS5ldmVudHMpO1xuXHRcdFx0dmFyIGksIGV2ZW50SW5wdXQ7XG5cdFx0XHR2YXIgYWJzdHJhY3RFdmVudDtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHQvLyBpcyB0aGlzIHRoZSBzb3VyY2UncyBtb3N0IHJlY2VudCBmZXRjaD9cblx0XHRcdFx0Ly8gaWYgbm90LCByZWx5IG9uIGFuIHVwY29taW5nIGZldGNoIG9mIHRoaXMgc291cmNlIHRvIGRlY3JlbWVudCBwZW5kaW5nU291cmNlQ250XG5cdFx0XHRcdGZldGNoSWQgPT09IHNvdXJjZS5fZmV0Y2hJZCAmJlxuXHRcdFx0XHQvLyBldmVudCBzb3VyY2Ugbm8gbG9uZ2VyIHZhbGlkP1xuXHRcdFx0XHRzb3VyY2UuX3N0YXR1cyAhPT0gJ3JlamVjdGVkJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHNvdXJjZS5fc3RhdHVzID0gJ3Jlc29sdmVkJztcblxuXHRcdFx0XHRpZiAoZXZlbnRJbnB1dHMpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGV2ZW50SW5wdXQgPSBldmVudElucHV0c1tpXTtcblxuXHRcdFx0XHRcdFx0aWYgKGlzQXJyYXlTb3VyY2UpIHsgLy8gYXJyYXkgc291cmNlcyBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0IHRvIEV2ZW50IE9iamVjdHNcblx0XHRcdFx0XHRcdFx0YWJzdHJhY3RFdmVudCA9IGV2ZW50SW5wdXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0YWJzdHJhY3RFdmVudCA9IGJ1aWxkRXZlbnRGcm9tSW5wdXQoZXZlbnRJbnB1dCwgc291cmNlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGFic3RyYWN0RXZlbnQpIHsgLy8gbm90IGZhbHNlIChhbiBpbnZhbGlkIGV2ZW50KVxuXHRcdFx0XHRcdFx0XHRjYWNoZS5wdXNoLmFwcGx5KFxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlLFxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZEV2ZW50KGFic3RyYWN0RXZlbnQpIC8vIGFkZCBpbmRpdmlkdWFsIGV4cGFuZGVkIGV2ZW50cyB0byB0aGUgY2FjaGVcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWNyZW1lbnRQZW5kaW5nU291cmNlQ250KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlamVjdEV2ZW50U291cmNlKHNvdXJjZSkge1xuXHRcdHZhciB3YXNQZW5kaW5nID0gc291cmNlLl9zdGF0dXMgPT09ICdwZW5kaW5nJztcblxuXHRcdHNvdXJjZS5fc3RhdHVzID0gJ3JlamVjdGVkJztcblxuXHRcdGlmICh3YXNQZW5kaW5nKSB7XG5cdFx0XHRkZWNyZW1lbnRQZW5kaW5nU291cmNlQ250KCk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBkZWNyZW1lbnRQZW5kaW5nU291cmNlQ250KCkge1xuXHRcdHBlbmRpbmdTb3VyY2VDbnQtLTtcblx0XHRpZiAoIXBlbmRpbmdTb3VyY2VDbnQpIHtcblx0XHRcdHJlcG9ydEV2ZW50cyhjYWNoZSk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBjYWxsYmFjaykge1xuXHRcdHZhciBpO1xuXHRcdHZhciBmZXRjaGVycyA9IEZDLnNvdXJjZUZldGNoZXJzO1xuXHRcdHZhciByZXM7XG5cblx0XHRmb3IgKGk9MDsgaTxmZXRjaGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmVzID0gZmV0Y2hlcnNbaV0uY2FsbChcblx0XHRcdFx0dCwgLy8gdGhpcywgdGhlIENhbGVuZGFyIG9iamVjdFxuXHRcdFx0XHRzb3VyY2UsXG5cdFx0XHRcdHJhbmdlU3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0cmFuZ2VFbmQuY2xvbmUoKSxcblx0XHRcdFx0dC5vcHRpb25zLnRpbWV6b25lLFxuXHRcdFx0XHRjYWxsYmFja1xuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHJlcyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyB0aGUgZmV0Y2hlciBpcyBpbiBjaGFyZ2UuIG1hZGUgaXRzIG93biBhc3luYyByZXF1ZXN0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiByZXMgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly8gdGhlIGZldGNoZXIgcmV0dXJuZWQgYSBuZXcgc291cmNlLiBwcm9jZXNzIGl0XG5cdFx0XHRcdF9mZXRjaEV2ZW50U291cmNlKHJlcywgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGV2ZW50cyA9IHNvdXJjZS5ldmVudHM7XG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbihldmVudHMpKSB7XG5cdFx0XHRcdHQucHVzaExvYWRpbmcoKTtcblx0XHRcdFx0ZXZlbnRzLmNhbGwoXG5cdFx0XHRcdFx0dCwgLy8gdGhpcywgdGhlIENhbGVuZGFyIG9iamVjdFxuXHRcdFx0XHRcdHJhbmdlU3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0XHRyYW5nZUVuZC5jbG9uZSgpLFxuXHRcdFx0XHRcdHQub3B0aW9ucy50aW1lem9uZSxcblx0XHRcdFx0XHRmdW5jdGlvbihldmVudHMpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50cyk7XG5cdFx0XHRcdFx0XHR0LnBvcExvYWRpbmcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgkLmlzQXJyYXkoZXZlbnRzKSkge1xuXHRcdFx0XHRjYWxsYmFjayhldmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHR2YXIgdXJsID0gc291cmNlLnVybDtcblx0XHRcdGlmICh1cmwpIHtcblx0XHRcdFx0dmFyIHN1Y2Nlc3MgPSBzb3VyY2Uuc3VjY2Vzcztcblx0XHRcdFx0dmFyIGVycm9yID0gc291cmNlLmVycm9yO1xuXHRcdFx0XHR2YXIgY29tcGxldGUgPSBzb3VyY2UuY29tcGxldGU7XG5cblx0XHRcdFx0Ly8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUICQuYWpheCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcblx0XHRcdFx0dmFyIGN1c3RvbURhdGE7XG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oc291cmNlLmRhdGEpKSB7XG5cdFx0XHRcdFx0Ly8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XG5cdFx0XHRcdFx0Y3VzdG9tRGF0YSA9IHNvdXJjZS5kYXRhKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG5cdFx0XHRcdFx0Y3VzdG9tRGF0YSA9IHNvdXJjZS5kYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXNlIGEgY29weSBvZiB0aGUgY3VzdG9tIGRhdGEgc28gd2UgY2FuIG1vZGlmeSB0aGUgcGFyYW1ldGVyc1xuXHRcdFx0XHQvLyBhbmQgbm90IGFmZmVjdCB0aGUgcGFzc2VkLWluIG9iamVjdC5cblx0XHRcdFx0dmFyIGRhdGEgPSAkLmV4dGVuZCh7fSwgY3VzdG9tRGF0YSB8fCB7fSk7XG5cblx0XHRcdFx0dmFyIHN0YXJ0UGFyYW0gPSBmaXJzdERlZmluZWQoc291cmNlLnN0YXJ0UGFyYW0sIHQub3B0aW9ucy5zdGFydFBhcmFtKTtcblx0XHRcdFx0dmFyIGVuZFBhcmFtID0gZmlyc3REZWZpbmVkKHNvdXJjZS5lbmRQYXJhbSwgdC5vcHRpb25zLmVuZFBhcmFtKTtcblx0XHRcdFx0dmFyIHRpbWV6b25lUGFyYW0gPSBmaXJzdERlZmluZWQoc291cmNlLnRpbWV6b25lUGFyYW0sIHQub3B0aW9ucy50aW1lem9uZVBhcmFtKTtcblxuXHRcdFx0XHRpZiAoc3RhcnRQYXJhbSkge1xuXHRcdFx0XHRcdGRhdGFbc3RhcnRQYXJhbV0gPSByYW5nZVN0YXJ0LmZvcm1hdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmRQYXJhbSkge1xuXHRcdFx0XHRcdGRhdGFbZW5kUGFyYW1dID0gcmFuZ2VFbmQuZm9ybWF0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHQub3B0aW9ucy50aW1lem9uZSAmJiB0Lm9wdGlvbnMudGltZXpvbmUgIT0gJ2xvY2FsJykge1xuXHRcdFx0XHRcdGRhdGFbdGltZXpvbmVQYXJhbV0gPSB0Lm9wdGlvbnMudGltZXpvbmU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0LnB1c2hMb2FkaW5nKCk7XG5cdFx0XHRcdCQuYWpheCgkLmV4dGVuZCh7fSwgYWpheERlZmF1bHRzLCBzb3VyY2UsIHtcblx0XHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdFx0XHRcdFx0ZXZlbnRzID0gZXZlbnRzIHx8IFtdO1xuXHRcdFx0XHRcdFx0dmFyIHJlcyA9IGFwcGx5QWxsKHN1Y2Nlc3MsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRpZiAoJC5pc0FycmF5KHJlcykpIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRzID0gcmVzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnRzKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGFwcGx5QWxsKGVycm9yLCB0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGFwcGx5QWxsKGNvbXBsZXRlLCB0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0dC5wb3BMb2FkaW5nKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyogU291cmNlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRmdW5jdGlvbiBhZGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCkge1xuXHRcdHZhciBzb3VyY2UgPSBidWlsZEV2ZW50U291cmNlKHNvdXJjZUlucHV0KTtcblx0XHRpZiAoc291cmNlKSB7XG5cdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHRcdGZldGNoRXZlbnRTb3VyY2VzKFsgc291cmNlIF0sICdhZGQnKTsgLy8gd2lsbCBldmVudHVhbGx5IGNhbGwgcmVwb3J0RXZlbnRzXG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBidWlsZEV2ZW50U291cmNlKHNvdXJjZUlucHV0KSB7IC8vIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiBpbnZhbGlkIHNvdXJjZVxuXHRcdHZhciBub3JtYWxpemVycyA9IEZDLnNvdXJjZU5vcm1hbGl6ZXJzO1xuXHRcdHZhciBzb3VyY2U7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoJC5pc0Z1bmN0aW9uKHNvdXJjZUlucHV0KSB8fCAkLmlzQXJyYXkoc291cmNlSW5wdXQpKSB7XG5cdFx0XHRzb3VyY2UgPSB7IGV2ZW50czogc291cmNlSW5wdXQgfTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0c291cmNlID0geyB1cmw6IHNvdXJjZUlucHV0IH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHNvdXJjZSA9ICQuZXh0ZW5kKHt9LCBzb3VyY2VJbnB1dCk7IC8vIHNoYWxsb3cgY29weVxuXHRcdH1cblxuXHRcdGlmIChzb3VyY2UpIHtcblxuXHRcdFx0Ly8gVE9ETzogcmVwZWF0IGNvZGUsIHNhbWUgY29kZSBmb3IgZXZlbnQgY2xhc3NOYW1lc1xuXHRcdFx0aWYgKHNvdXJjZS5jbGFzc05hbWUpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHNvdXJjZS5jbGFzc05hbWUgPSBzb3VyY2UuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCBhc3N1bWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c291cmNlLmNsYXNzTmFtZSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgYXJyYXkgc291cmNlcywgd2UgY29udmVydCB0byBzdGFuZGFyZCBFdmVudCBPYmplY3RzIHVwIGZyb250XG5cdFx0XHRpZiAoJC5pc0FycmF5KHNvdXJjZS5ldmVudHMpKSB7XG5cdFx0XHRcdHNvdXJjZS5vcmlnQXJyYXkgPSBzb3VyY2UuZXZlbnRzOyAvLyBmb3IgcmVtb3ZlRXZlbnRTb3VyY2Vcblx0XHRcdFx0c291cmNlLmV2ZW50cyA9ICQubWFwKHNvdXJjZS5ldmVudHMsIGZ1bmN0aW9uKGV2ZW50SW5wdXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVpbGRFdmVudEZyb21JbnB1dChldmVudElucHV0LCBzb3VyY2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpPTA7IGk8bm9ybWFsaXplcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bm9ybWFsaXplcnNbaV0uY2FsbCh0LCBzb3VyY2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc291cmNlO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnRTb3VyY2UobWF0Y2hJbnB1dCkge1xuXHRcdHJlbW92ZVNwZWNpZmljRXZlbnRTb3VyY2VzKFxuXHRcdFx0Z2V0RXZlbnRTb3VyY2VzQnlNYXRjaChtYXRjaElucHV0KVxuXHRcdCk7XG5cdH1cblxuXG5cdC8vIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmVtb3ZlcyBhbGwuXG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50U291cmNlcyhtYXRjaElucHV0cykge1xuXHRcdGlmIChtYXRjaElucHV0cyA9PSBudWxsKSB7XG5cdFx0XHRyZW1vdmVTcGVjaWZpY0V2ZW50U291cmNlcyhzb3VyY2VzLCB0cnVlKTsgLy8gaXNBbGw9dHJ1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZVNwZWNpZmljRXZlbnRTb3VyY2VzKFxuXHRcdFx0XHRnZXRFdmVudFNvdXJjZXNCeU1hdGNoQXJyYXkobWF0Y2hJbnB1dHMpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVtb3ZlU3BlY2lmaWNFdmVudFNvdXJjZXModGFyZ2V0U291cmNlcywgaXNBbGwpIHtcblx0XHR2YXIgaTtcblxuXHRcdC8vIGNhbmNlbCBwZW5kaW5nIHJlcXVlc3RzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldFNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlamVjdEV2ZW50U291cmNlKHRhcmdldFNvdXJjZXNbaV0pO1xuXHRcdH1cblxuXHRcdGlmIChpc0FsbCkgeyAvLyBhbiBvcHRpbWl6YXRpb25cblx0XHRcdHNvdXJjZXMgPSBbXTtcblx0XHRcdGNhY2hlID0gW107XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gcmVtb3ZlIGZyb20gcGVyc2lzdGVkIHNvdXJjZSBsaXN0XG5cdFx0XHRzb3VyY2VzID0gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0U291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChzb3VyY2UgPT09IHRhcmdldFNvdXJjZXNbaV0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZXhjbHVkZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gaW5jbHVkZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNhY2hlID0gZXhjbHVkZUV2ZW50c0J5U291cmNlcyhjYWNoZSwgdGFyZ2V0U291cmNlcyk7XG5cdFx0fVxuXG5cdFx0cmVwb3J0RXZlbnRzKGNhY2hlKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VzKCkge1xuXHRcdHJldHVybiBzb3VyY2VzLnNsaWNlKDEpOyAvLyByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIHNvdXJjZXMgd2l0aCBzdGlja3lTb3VyY2UgcmVtb3ZlZFxuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcblx0XHRyZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5pZCAmJiBzb3VyY2UuaWQgPT09IGlkO1xuXHRcdH0pWzBdO1xuXHR9XG5cblxuXHQvLyBsaWtlIGdldEV2ZW50U291cmNlc0J5TWF0Y2gsIGJ1dCBhY2NlcHRzIG11bHRwbGUgbWF0Y2ggY3JpdGVyaWEgKGxpa2UgbXVsdGlwbGUgSURzKVxuXHRmdW5jdGlvbiBnZXRFdmVudFNvdXJjZXNCeU1hdGNoQXJyYXkobWF0Y2hJbnB1dHMpIHtcblxuXHRcdC8vIGNvZXJjZSBpbnRvIGFuIGFycmF5XG5cdFx0aWYgKCFtYXRjaElucHV0cykge1xuXHRcdFx0bWF0Y2hJbnB1dHMgPSBbXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoISQuaXNBcnJheShtYXRjaElucHV0cykpIHtcblx0XHRcdG1hdGNoSW5wdXRzID0gWyBtYXRjaElucHV0cyBdO1xuXHRcdH1cblxuXHRcdHZhciBtYXRjaGluZ1NvdXJjZXMgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIHJlc29sdmUgcmF3IGlucHV0cyB0byByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3RzXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1hdGNoSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXRjaGluZ1NvdXJjZXMucHVzaC5hcHBseSggLy8gYXBwZW5kXG5cdFx0XHRcdG1hdGNoaW5nU291cmNlcyxcblx0XHRcdFx0Z2V0RXZlbnRTb3VyY2VzQnlNYXRjaChtYXRjaElucHV0c1tpXSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoaW5nU291cmNlcztcblx0fVxuXG5cblx0Ly8gbWF0Y2hJbnB1dCBjYW4gZWl0aGVyIGJ5IGEgcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0LCBhbiBJRCwgb3IgdGhlIGZ1bmN0aW9uL1VSTCBmb3IgdGhlIHNvdXJjZS5cblx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBzb3VyY2Ugb2JqZWN0cy5cblx0ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaChtYXRjaElucHV0KSB7XG5cdFx0dmFyIGksIHNvdXJjZTtcblxuXHRcdC8vIGdpdmVuIGFuIHByb3BlciBldmVudCBzb3VyY2Ugb2JqZWN0XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoc291cmNlID09PSBtYXRjaElucHV0KSB7XG5cdFx0XHRcdHJldHVybiBbIHNvdXJjZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuIElEIG1hdGNoXG5cdFx0c291cmNlID0gZ2V0RXZlbnRTb3VyY2VCeUlkKG1hdGNoSW5wdXQpO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiBbIHNvdXJjZSBdO1xuXHRcdH1cblxuXHRcdHJldHVybiAkLmdyZXAoc291cmNlcywgZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gaXNTb3VyY2VzRXF1aXZhbGVudChtYXRjaElucHV0LCBzb3VyY2UpO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpc1NvdXJjZXNFcXVpdmFsZW50KHNvdXJjZTEsIHNvdXJjZTIpIHtcblx0XHRyZXR1cm4gc291cmNlMSAmJiBzb3VyY2UyICYmIGdldFNvdXJjZVByaW1pdGl2ZShzb3VyY2UxKSA9PSBnZXRTb3VyY2VQcmltaXRpdmUoc291cmNlMik7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldFNvdXJjZVByaW1pdGl2ZShzb3VyY2UpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0KHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSA/IC8vIGEgbm9ybWFsaXplZCBldmVudCBzb3VyY2U/XG5cdFx0XHRcdChzb3VyY2Uub3JpZ0FycmF5IHx8IHNvdXJjZS5nb29nbGVDYWxlbmRhcklkIHx8IHNvdXJjZS51cmwgfHwgc291cmNlLmV2ZW50cykgOiAvLyBnZXQgdGhlIHByaW1pdGl2ZVxuXHRcdFx0XHRudWxsXG5cdFx0KSB8fFxuXHRcdHNvdXJjZTsgLy8gdGhlIGdpdmVuIGFyZ3VtZW50ICppcyogdGhlIHByaW1pdGl2ZVxuXHR9XG5cblxuXHQvLyB1dGlsXG5cdC8vIHJldHVybnMgYSBmaWx0ZXJlZCBhcnJheSB3aXRob3V0IGV2ZW50cyB0aGF0IGFyZSBwYXJ0IG9mIGFueSBvZiB0aGUgZ2l2ZW4gc291cmNlc1xuXHRmdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VzKHNwZWNpZmljRXZlbnRzLCBzcGVjaWZpY1NvdXJjZXMpIHtcblx0XHRyZXR1cm4gJC5ncmVwKHNwZWNpZmljRXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gc3BlY2lmaWNTb3VyY2VzW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBleGNsdWRlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlOyAvLyBrZWVwXG5cdFx0fSk7XG5cdH1cblx0XG5cdFxuXHRcblx0LyogTWFuaXB1bGF0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIE9ubHkgZXZlciBjYWxsZWQgZnJvbSB0aGUgZXh0ZXJuYWxseS1mYWNpbmcgQVBJXG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KGV2ZW50KSB7XG5cblx0XHQvLyBtYXNzYWdlIHN0YXJ0L2VuZCB2YWx1ZXMsIGV2ZW4gaWYgZGF0ZSBzdHJpbmcgdmFsdWVzXG5cdFx0ZXZlbnQuc3RhcnQgPSB0Lm1vbWVudChldmVudC5zdGFydCk7XG5cdFx0aWYgKGV2ZW50LmVuZCkge1xuXHRcdFx0ZXZlbnQuZW5kID0gdC5tb21lbnQoZXZlbnQuZW5kKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRldmVudC5lbmQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG11dGF0ZUV2ZW50KGV2ZW50LCBnZXRNaXNjRXZlbnRQcm9wcyhldmVudCkpOyAvLyB3aWxsIGhhbmRsZSBzdGFydC9lbmQvYWxsRGF5IG5vcm1hbGl6YXRpb25cblx0XHRyZXBvcnRFdmVudHMoY2FjaGUpOyAvLyByZXBvcnRzIGV2ZW50IG1vZGlmaWNhdGlvbnMgKHNvIHdlIGNhbiByZWRyYXcpXG5cdH1cblxuXG5cdC8vIFJldHVybnMgYSBoYXNoIG9mIG1pc2MgZXZlbnQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBjb3BpZWQgb3ZlciB0byByZWxhdGVkIGV2ZW50cy5cblx0ZnVuY3Rpb24gZ2V0TWlzY0V2ZW50UHJvcHMoZXZlbnQpIHtcblx0XHR2YXIgcHJvcHMgPSB7fTtcblxuXHRcdCQuZWFjaChldmVudCwgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cdFx0XHRpZiAoaXNNaXNjRXZlbnRQcm9wTmFtZShuYW1lKSkge1xuXHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQgJiYgaXNBdG9taWModmFsKSkgeyAvLyBhIGRlZmluZWQgbm9uLW9iamVjdFxuXHRcdFx0XHRcdHByb3BzW25hbWVdID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcHJvcHM7XG5cdH1cblxuXHQvLyBub24tZGF0ZS1yZWxhdGVkLCBub24taWQtcmVsYXRlZCwgbm9uLXNlY3JldFxuXHRmdW5jdGlvbiBpc01pc2NFdmVudFByb3BOYW1lKG5hbWUpIHtcblx0XHRyZXR1cm4gIS9eX3xeKGlkfGFsbERheXxzdGFydHxlbmQpJC8udGVzdChuYW1lKTtcblx0fVxuXG5cdFxuXHQvLyByZXR1cm5zIHRoZSBleHBhbmRlZCBldmVudHMgdGhhdCB3ZXJlIGNyZWF0ZWRcblx0ZnVuY3Rpb24gcmVuZGVyRXZlbnQoZXZlbnRJbnB1dCwgc3RpY2spIHtcblx0XHR2YXIgYWJzdHJhY3RFdmVudCA9IGJ1aWxkRXZlbnRGcm9tSW5wdXQoZXZlbnRJbnB1dCk7XG5cdFx0dmFyIGV2ZW50cztcblx0XHR2YXIgaSwgZXZlbnQ7XG5cblx0XHRpZiAoYWJzdHJhY3RFdmVudCkgeyAvLyBub3QgZmFsc2UgKGEgdmFsaWQgaW5wdXQpXG5cdFx0XHRldmVudHMgPSBleHBhbmRFdmVudChhYnN0cmFjdEV2ZW50KTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRldmVudCA9IGV2ZW50c1tpXTtcblxuXHRcdFx0XHRpZiAoIWV2ZW50LnNvdXJjZSkge1xuXHRcdFx0XHRcdGlmIChzdGljaykge1xuXHRcdFx0XHRcdFx0c3RpY2t5U291cmNlLmV2ZW50cy5wdXNoKGV2ZW50KTtcblx0XHRcdFx0XHRcdGV2ZW50LnNvdXJjZSA9IHN0aWNreVNvdXJjZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FjaGUucHVzaChldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmVwb3J0RXZlbnRzKGNhY2hlKTtcblxuXHRcdFx0cmV0dXJuIGV2ZW50cztcblx0XHR9XG5cblx0XHRyZXR1cm4gW107XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiByZW1vdmVFdmVudHMoZmlsdGVyKSB7XG5cdFx0dmFyIGV2ZW50SUQ7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoZmlsdGVyID09IG51bGwpIHsgLy8gbnVsbCBvciB1bmRlZmluZWQuIHJlbW92ZSBhbGwgZXZlbnRzXG5cdFx0XHRmaWx0ZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07IC8vIHdpbGwgYWx3YXlzIG1hdGNoXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCEkLmlzRnVuY3Rpb24oZmlsdGVyKSkgeyAvLyBhbiBldmVudCBJRFxuXHRcdFx0ZXZlbnRJRCA9IGZpbHRlciArICcnO1xuXHRcdFx0ZmlsdGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIGV2ZW50Ll9pZCA9PSBldmVudElEO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBQdXJnZSBldmVudChzKSBmcm9tIG91ciBsb2NhbCBjYWNoZVxuXHRcdGNhY2hlID0gJC5ncmVwKGNhY2hlLCBmaWx0ZXIsIHRydWUpOyAvLyBpbnZlcnNlPXRydWVcblxuXHRcdC8vIFJlbW92ZSBldmVudHMgZnJvbSBhcnJheSBzb3VyY2VzLlxuXHRcdC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGV5IGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gb2ZmaWNpYWwgRXZlbnQgT2JqZWN0cyB1cCBmcm9udC5cblx0XHQvLyAoYW5kIGFzIGEgcmVzdWx0LCBldmVudC5faWQgaGFzIGJlZW4gY2FsY3VsYXRlZCkuXG5cdFx0Zm9yIChpPTA7IGk8c291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCQuaXNBcnJheShzb3VyY2VzW2ldLmV2ZW50cykpIHtcblx0XHRcdFx0c291cmNlc1tpXS5ldmVudHMgPSAkLmdyZXAoc291cmNlc1tpXS5ldmVudHMsIGZpbHRlciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmVwb3J0RXZlbnRzKGNhY2hlKTtcblx0fVxuXG5cdFxuXHRmdW5jdGlvbiBjbGllbnRFdmVudHMoZmlsdGVyKSB7XG5cdFx0aWYgKCQuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG5cdFx0XHRyZXR1cm4gJC5ncmVwKGNhY2hlLCBmaWx0ZXIpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkgeyAvLyBub3QgbnVsbCwgbm90IHVuZGVmaW5lZC4gYW4gZXZlbnQgSURcblx0XHRcdGZpbHRlciArPSAnJztcblx0XHRcdHJldHVybiAkLmdyZXAoY2FjaGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIGUuX2lkID09IGZpbHRlcjtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7IC8vIGVsc2UsIHJldHVybiBhbGxcblx0fVxuXG5cblx0Ly8gTWFrZXMgc3VyZSBhbGwgYXJyYXkgZXZlbnQgc291cmNlcyBoYXZlIHRoZWlyIGludGVybmFsIGV2ZW50IG9iamVjdHNcblx0Ly8gY29udmVydGVkIG92ZXIgdG8gdGhlIENhbGVuZGFyJ3MgY3VycmVudCB0aW1lem9uZS5cblx0dC5yZXpvbmVBcnJheUV2ZW50U291cmNlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpO1xuXHRcdHZhciBldmVudHM7XG5cdFx0dmFyIGo7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXZlbnRzID0gc291cmNlc1tpXS5ldmVudHM7XG5cdFx0XHRpZiAoJC5pc0FycmF5KGV2ZW50cykpIHtcblxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0cmV6b25lRXZlbnREYXRlcyhldmVudHNbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlem9uZUV2ZW50RGF0ZXMoZXZlbnQpIHtcblx0XHRldmVudC5zdGFydCA9IHQubW9tZW50KGV2ZW50LnN0YXJ0KTtcblx0XHRpZiAoZXZlbnQuZW5kKSB7XG5cdFx0XHRldmVudC5lbmQgPSB0Lm1vbWVudChldmVudC5lbmQpO1xuXHRcdH1cblx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTtcblx0fVxuXHRcblx0XG5cdC8qIEV2ZW50IE5vcm1hbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2l2ZW4gYSByYXcgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHByb3BlcnRpZXMsIHJldHVybnMgYW4gXCJhYnN0cmFjdFwiIEV2ZW50IG9iamVjdC5cblx0Ly8gQW4gXCJhYnN0cmFjdFwiIGV2ZW50IGlzIGFuIGV2ZW50IHRoYXQsIGlmIHJlY3VycmluZywgd2lsbCBub3QgaGF2ZSBiZWVuIGV4cGFuZGVkIHlldC5cblx0Ly8gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIGlucHV0IGlzIGludmFsaWQuXG5cdC8vIGBzb3VyY2VgIGlzIG9wdGlvbmFsXG5cdGZ1bmN0aW9uIGJ1aWxkRXZlbnRGcm9tSW5wdXQoaW5wdXQsIHNvdXJjZSkge1xuXHRcdHZhciBvdXQgPSB7fTtcblx0XHR2YXIgc3RhcnQsIGVuZDtcblx0XHR2YXIgYWxsRGF5O1xuXG5cdFx0aWYgKHQub3B0aW9ucy5ldmVudERhdGFUcmFuc2Zvcm0pIHtcblx0XHRcdGlucHV0ID0gdC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybShpbnB1dCk7XG5cdFx0fVxuXHRcdGlmIChzb3VyY2UgJiYgc291cmNlLmV2ZW50RGF0YVRyYW5zZm9ybSkge1xuXHRcdFx0aW5wdXQgPSBzb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtKGlucHV0KTtcblx0XHR9XG5cblx0XHQvLyBDb3B5IGFsbCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIHJlc3VsdGluZyBvYmplY3QuXG5cdFx0Ly8gVGhlIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIG92ZXIgYWZ0ZXJ3YXJkcy5cblx0XHQkLmV4dGVuZChvdXQsIGlucHV0KTtcblxuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdG91dC5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0fVxuXG5cdFx0b3V0Ll9pZCA9IGlucHV0Ll9pZCB8fCAoaW5wdXQuaWQgPT09IHVuZGVmaW5lZCA/ICdfZmMnICsgZXZlbnRHVUlEKysgOiBpbnB1dC5pZCArICcnKTtcblxuXHRcdGlmIChpbnB1dC5jbGFzc05hbWUpIHtcblx0XHRcdGlmICh0eXBlb2YgaW5wdXQuY2xhc3NOYW1lID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG91dC5jbGFzc05hbWUgPSBpbnB1dC5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBhc3N1bWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHRcdG91dC5jbGFzc05hbWUgPSBpbnB1dC5jbGFzc05hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0b3V0LmNsYXNzTmFtZSA9IFtdO1xuXHRcdH1cblxuXHRcdHN0YXJ0ID0gaW5wdXQuc3RhcnQgfHwgaW5wdXQuZGF0ZTsgLy8gXCJkYXRlXCIgaXMgYW4gYWxpYXMgZm9yIFwic3RhcnRcIlxuXHRcdGVuZCA9IGlucHV0LmVuZDtcblxuXHRcdC8vIHBhcnNlIGFzIGEgdGltZSAoRHVyYXRpb24pIGlmIGFwcGxpY2FibGVcblx0XHRpZiAoaXNUaW1lU3RyaW5nKHN0YXJ0KSkge1xuXHRcdFx0c3RhcnQgPSBtb21lbnQuZHVyYXRpb24oc3RhcnQpO1xuXHRcdH1cblx0XHRpZiAoaXNUaW1lU3RyaW5nKGVuZCkpIHtcblx0XHRcdGVuZCA9IG1vbWVudC5kdXJhdGlvbihlbmQpO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC5kb3cgfHwgbW9tZW50LmlzRHVyYXRpb24oc3RhcnQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGVuZCkpIHtcblxuXHRcdFx0Ly8gdGhlIGV2ZW50IGlzIFwiYWJzdHJhY3RcIiAocmVjdXJyaW5nKSBzbyBkb24ndCBjYWxjdWxhdGUgZXhhY3Qgc3RhcnQvZW5kIGRhdGVzIGp1c3QgeWV0XG5cdFx0XHRvdXQuc3RhcnQgPSBzdGFydCA/IG1vbWVudC5kdXJhdGlvbihzdGFydCkgOiBudWxsOyAvLyB3aWxsIGJlIGEgRHVyYXRpb24gb3IgbnVsbFxuXHRcdFx0b3V0LmVuZCA9IGVuZCA/IG1vbWVudC5kdXJhdGlvbihlbmQpIDogbnVsbDsgLy8gd2lsbCBiZSBhIER1cmF0aW9uIG9yIG51bGxcblx0XHRcdG91dC5fcmVjdXJyaW5nID0gdHJ1ZTsgLy8gb3VyIGludGVybmFsIG1hcmtlclxuXHRcdH1cblx0XHRlbHNlIHtcblxuXHRcdFx0aWYgKHN0YXJ0KSB7XG5cdFx0XHRcdHN0YXJ0ID0gdC5tb21lbnQoc3RhcnQpO1xuXHRcdFx0XHRpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZW5kKSB7XG5cdFx0XHRcdGVuZCA9IHQubW9tZW50KGVuZCk7XG5cdFx0XHRcdGlmICghZW5kLmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdGVuZCA9IG51bGw7IC8vIGxldCBkZWZhdWx0cyB0YWtlIG92ZXJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRhbGxEYXkgPSBpbnB1dC5hbGxEYXk7XG5cdFx0XHRpZiAoYWxsRGF5ID09PSB1bmRlZmluZWQpIHsgLy8gc3RpbGwgdW5kZWZpbmVkPyBmYWxsYmFjayB0byBkZWZhdWx0XG5cdFx0XHRcdGFsbERheSA9IGZpcnN0RGVmaW5lZChcblx0XHRcdFx0XHRzb3VyY2UgPyBzb3VyY2UuYWxsRGF5RGVmYXVsdCA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0Lm9wdGlvbnMuYWxsRGF5RGVmYXVsdFxuXHRcdFx0XHQpO1xuXHRcdFx0XHQvLyBzdGlsbCB1bmRlZmluZWQ/IG5vcm1hbGl6ZUV2ZW50RGF0ZXMgd2lsbCBjYWxjdWxhdGUgaXRcblx0XHRcdH1cblxuXHRcdFx0YXNzaWduRGF0ZXNUb0V2ZW50KHN0YXJ0LCBlbmQsIGFsbERheSwgb3V0KTtcblx0XHR9XG5cblx0XHR0Lm5vcm1hbGl6ZUV2ZW50KG91dCk7IC8vIGhvb2sgZm9yIGV4dGVybmFsIHVzZS4gYSBwcm90b3R5cGUgbWV0aG9kXG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblxuXHQvLyBOb3JtYWxpemVzIGFuZCBhc3NpZ25zIHRoZSBnaXZlbiBkYXRlcyB0byB0aGUgZ2l2ZW4gcGFydGlhbGx5LWZvcm1lZCBldmVudCBvYmplY3QuXG5cdC8vIE5PVEU6IG11dGF0ZXMgdGhlIGdpdmVuIHN0YXJ0L2VuZCBtb21lbnRzLiBkb2VzIG5vdCBtYWtlIGEgY29weS5cblx0ZnVuY3Rpb24gYXNzaWduRGF0ZXNUb0V2ZW50KHN0YXJ0LCBlbmQsIGFsbERheSwgZXZlbnQpIHtcblx0XHRldmVudC5zdGFydCA9IHN0YXJ0O1xuXHRcdGV2ZW50LmVuZCA9IGVuZDtcblx0XHRldmVudC5hbGxEYXkgPSBhbGxEYXk7XG5cdFx0bm9ybWFsaXplRXZlbnREYXRlcyhldmVudCk7XG5cdFx0YmFja3VwRXZlbnREYXRlcyhldmVudCk7XG5cdH1cblxuXG5cdC8vIEVuc3VyZXMgcHJvcGVyIHZhbHVlcyBmb3IgYWxsRGF5L3N0YXJ0L2VuZC4gQWNjZXB0cyBhbiBFdmVudCBvYmplY3QsIG9yIGEgcGxhaW4gb2JqZWN0IHdpdGggZXZlbnQtaXNoIHByb3BlcnRpZXMuXG5cdC8vIE5PVEU6IFdpbGwgbW9kaWZ5IHRoZSBnaXZlbiBvYmplY3QuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50RGF0ZXMoZXZlbnRQcm9wcykge1xuXG5cdFx0bm9ybWFsaXplRXZlbnRUaW1lcyhldmVudFByb3BzKTtcblxuXHRcdGlmIChldmVudFByb3BzLmVuZCAmJiAhZXZlbnRQcm9wcy5lbmQuaXNBZnRlcihldmVudFByb3BzLnN0YXJ0KSkge1xuXHRcdFx0ZXZlbnRQcm9wcy5lbmQgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICghZXZlbnRQcm9wcy5lbmQpIHtcblx0XHRcdGlmICh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uKSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kID0gdC5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnRQcm9wcy5hbGxEYXksIGV2ZW50UHJvcHMuc3RhcnQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vIEVuc3VyZXMgdGhlIGFsbERheSBwcm9wZXJ0eSBleGlzdHMgYW5kIHRoZSB0aW1lbGluZXNzIG9mIHRoZSBzdGFydC9lbmQgZGF0ZXMgYXJlIGNvbnNpc3RlbnRcblx0ZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRUaW1lcyhldmVudFByb3BzKSB7XG5cdFx0aWYgKGV2ZW50UHJvcHMuYWxsRGF5ID09IG51bGwpIHtcblx0XHRcdGV2ZW50UHJvcHMuYWxsRGF5ID0gIShldmVudFByb3BzLnN0YXJ0Lmhhc1RpbWUoKSB8fCAoZXZlbnRQcm9wcy5lbmQgJiYgZXZlbnRQcm9wcy5lbmQuaGFzVGltZSgpKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50UHJvcHMuYWxsRGF5KSB7XG5cdFx0XHRldmVudFByb3BzLnN0YXJ0LnN0cmlwVGltZSgpO1xuXHRcdFx0aWYgKGV2ZW50UHJvcHMuZW5kKSB7XG5cdFx0XHRcdC8vIFRPRE86IGNvbnNpZGVyIG5leHREYXlUaHJlc2hvbGQgaGVyZT8gSWYgc28sIHdpbGwgcmVxdWlyZSBhIGxvdCBvZiB0ZXN0aW5nIGFuZCBhZGp1c3RtZW50XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kLnN0cmlwVGltZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICghZXZlbnRQcm9wcy5zdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdFx0ZXZlbnRQcm9wcy5zdGFydCA9IHQuYXBwbHlUaW1lem9uZShldmVudFByb3BzLnN0YXJ0LnRpbWUoMCkpOyAvLyB3aWxsIGFzc2lnbiBhIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHRcdGlmIChldmVudFByb3BzLmVuZCAmJiAhZXZlbnRQcm9wcy5lbmQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kID0gdC5hcHBseVRpbWV6b25lKGV2ZW50UHJvcHMuZW5kLnRpbWUoMCkpOyAvLyB3aWxsIGFzc2lnbiBhIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vIElmIHRoZSBnaXZlbiBldmVudCBpcyBhIHJlY3VycmluZyBldmVudCwgYnJlYWsgaXQgZG93biBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWwgaW5zdGFuY2VzLlxuXHQvLyBJZiBub3QgYSByZWN1cnJpbmcgZXZlbnQsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBzaW5nbGUgb3JpZ2luYWwgZXZlbnQuXG5cdC8vIElmIGdpdmVuIGEgZmFsc3kgaW5wdXQgKHByb2JhYmx5IGJlY2F1c2Ugb2YgYSBmYWlsZWQgYnVpbGRFdmVudEZyb21JbnB1dCBjYWxsKSwgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cblx0Ly8gSEFDSzogY2FuIG92ZXJyaWRlIHRoZSByZWN1cnJpbmcgd2luZG93IGJ5IHByb3ZpZGluZyBjdXN0b20gcmFuZ2VTdGFydC9yYW5nZUVuZCAoZm9yIGJ1c2luZXNzSG91cnMpLlxuXHRmdW5jdGlvbiBleHBhbmRFdmVudChhYnN0cmFjdEV2ZW50LCBfcmFuZ2VTdGFydCwgX3JhbmdlRW5kKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFtdO1xuXHRcdHZhciBkb3dIYXNoO1xuXHRcdHZhciBkb3c7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIGRhdGU7XG5cdFx0dmFyIHN0YXJ0VGltZSwgZW5kVGltZTtcblx0XHR2YXIgc3RhcnQsIGVuZDtcblx0XHR2YXIgZXZlbnQ7XG5cblx0XHRfcmFuZ2VTdGFydCA9IF9yYW5nZVN0YXJ0IHx8IHJhbmdlU3RhcnQ7XG5cdFx0X3JhbmdlRW5kID0gX3JhbmdlRW5kIHx8IHJhbmdlRW5kO1xuXG5cdFx0aWYgKGFic3RyYWN0RXZlbnQpIHtcblx0XHRcdGlmIChhYnN0cmFjdEV2ZW50Ll9yZWN1cnJpbmcpIHtcblxuXHRcdFx0XHQvLyBtYWtlIGEgYm9vbGVhbiBoYXNoIGFzIHRvIHdoZXRoZXIgdGhlIGV2ZW50IG9jY3VycyBvbiBlYWNoIGRheS1vZi13ZWVrXG5cdFx0XHRcdGlmICgoZG93ID0gYWJzdHJhY3RFdmVudC5kb3cpKSB7XG5cdFx0XHRcdFx0ZG93SGFzaCA9IHt9O1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb3cubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGRvd0hhc2hbZG93W2ldXSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IGRheSBpbiB0aGUgY3VycmVudCByYW5nZVxuXHRcdFx0XHRkYXRlID0gX3JhbmdlU3RhcnQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gaG9sZHMgdGhlIGRhdGUgb2YgdGhlIGN1cnJlbnQgZGF5XG5cdFx0XHRcdHdoaWxlIChkYXRlLmlzQmVmb3JlKF9yYW5nZUVuZCkpIHtcblxuXHRcdFx0XHRcdGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RhdGUuZGF5KCldKSB7IC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcblxuXHRcdFx0XHRcdFx0c3RhcnRUaW1lID0gYWJzdHJhY3RFdmVudC5zdGFydDsgLy8gdGhlIHN0b3JlZCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMgYXJlIHRpbWVzIChEdXJhdGlvbnMpXG5cdFx0XHRcdFx0XHRlbmRUaW1lID0gYWJzdHJhY3RFdmVudC5lbmQ7IC8vIFwiXG5cdFx0XHRcdFx0XHRzdGFydCA9IGRhdGUuY2xvbmUoKTtcblx0XHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cblx0XHRcdFx0XHRcdGlmIChzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdFx0c3RhcnQgPSBzdGFydC50aW1lKHN0YXJ0VGltZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZW5kVGltZSkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBkYXRlLmNsb25lKCkudGltZShlbmRUaW1lKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXZlbnQgPSAkLmV4dGVuZCh7fSwgYWJzdHJhY3RFdmVudCk7IC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbFxuXHRcdFx0XHRcdFx0YXNzaWduRGF0ZXNUb0V2ZW50KFxuXHRcdFx0XHRcdFx0XHRzdGFydCwgZW5kLFxuXHRcdFx0XHRcdFx0XHQhc3RhcnRUaW1lICYmICFlbmRUaW1lLCAvLyBhbGxEYXk/XG5cdFx0XHRcdFx0XHRcdGV2ZW50XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0ZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRhdGUuYWRkKDEsICdkYXlzJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRldmVudHMucHVzaChhYnN0cmFjdEV2ZW50KTsgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCBldmVudC4gd2lsbCBiZSBhIG9uZS1pdGVtIGFycmF5XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fVxuXG5cblxuXHQvKiBFdmVudCBNb2RpZmljYXRpb24gTWF0aFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBNb2RpZmllcyBhbiBldmVudCBhbmQgYWxsIHJlbGF0ZWQgZXZlbnRzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuXHQvLyBTcGVjaWFsIGRhdGUtZGlmZmluZyBsb2dpYyBpcyB1c2VkIGZvciBtYW5pcHVsYXRpb24gb2YgZGF0ZXMuXG5cdC8vIElmIGBwcm9wc2AgZG9lcyBub3QgY29udGFpbiBzdGFydC9lbmQgZGF0ZXMsIHRoZSB1cGRhdGVkIHZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSB0aGUgZXZlbnQncyBjdXJyZW50IHN0YXJ0L2VuZC5cblx0Ly8gQWxsIGRhdGUgY29tcGFyaXNvbnMgYXJlIGRvbmUgYWdhaW5zdCB0aGUgZXZlbnQncyBwcmlzdGluZSBfc3RhcnQgYW5kIF9lbmQgZGF0ZXMuXG5cdC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggZGVsdGEgaW5mb3JtYXRpb24gYW5kIGEgZnVuY3Rpb24gdG8gdW5kbyBhbGwgb3BlcmF0aW9ucy5cblx0Ly8gRm9yIG1ha2luZyBjb21wdXRhdGlvbnMgaW4gYSBncmFudWxhcml0eSBncmVhdGVyIHRoYW4gZGF5L3RpbWUsIHNwZWNpZnkgbGFyZ2VVbml0LlxuXHQvLyBOT1RFOiBUaGUgZ2l2ZW4gYG5ld1Byb3BzYCBtaWdodCBiZSBtdXRhdGVkIGZvciBub3JtYWxpemF0aW9uIHB1cnBvc2VzLlxuXHRmdW5jdGlvbiBtdXRhdGVFdmVudChldmVudCwgbmV3UHJvcHMsIGxhcmdlVW5pdCkge1xuXHRcdHZhciBtaXNjUHJvcHMgPSB7fTtcblx0XHR2YXIgb2xkUHJvcHM7XG5cdFx0dmFyIGNsZWFyRW5kO1xuXHRcdHZhciBzdGFydERlbHRhO1xuXHRcdHZhciBlbmREZWx0YTtcblx0XHR2YXIgZHVyYXRpb25EZWx0YTtcblx0XHR2YXIgdW5kb0Z1bmM7XG5cblx0XHQvLyBkaWZmcyB0aGUgZGF0ZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHdheSwgcmV0dXJuaW5nIGEgZHVyYXRpb25cblx0XHRmdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTEsIGRhdGUwKSB7IC8vIGRhdGUxIC0gZGF0ZTBcblx0XHRcdGlmIChsYXJnZVVuaXQpIHtcblx0XHRcdFx0cmV0dXJuIGRpZmZCeVVuaXQoZGF0ZTEsIGRhdGUwLCBsYXJnZVVuaXQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobmV3UHJvcHMuYWxsRGF5KSB7XG5cdFx0XHRcdHJldHVybiBkaWZmRGF5KGRhdGUxLCBkYXRlMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGRpZmZEYXlUaW1lKGRhdGUxLCBkYXRlMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bmV3UHJvcHMgPSBuZXdQcm9wcyB8fCB7fTtcblxuXHRcdC8vIG5vcm1hbGl6ZSBuZXcgZGF0ZS1yZWxhdGVkIHByb3BlcnRpZXNcblx0XHRpZiAoIW5ld1Byb3BzLnN0YXJ0KSB7XG5cdFx0XHRuZXdQcm9wcy5zdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCk7XG5cdFx0fVxuXHRcdGlmIChuZXdQcm9wcy5lbmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bmV3UHJvcHMuZW5kID0gZXZlbnQuZW5kID8gZXZlbnQuZW5kLmNsb25lKCkgOiBudWxsO1xuXHRcdH1cblx0XHRpZiAobmV3UHJvcHMuYWxsRGF5ID09IG51bGwpIHsgLy8gaXMgbnVsbCBvciB1bmRlZmluZWQ/XG5cdFx0XHRuZXdQcm9wcy5hbGxEYXkgPSBldmVudC5hbGxEYXk7XG5cdFx0fVxuXHRcdG5vcm1hbGl6ZUV2ZW50RGF0ZXMobmV3UHJvcHMpO1xuXG5cdFx0Ly8gY3JlYXRlIG5vcm1hbGl6ZWQgdmVyc2lvbnMgb2YgdGhlIG9yaWdpbmFsIHByb3BzIHRvIGNvbXBhcmUgYWdhaW5zdFxuXHRcdC8vIG5lZWQgYSByZWFsIGVuZCB2YWx1ZSwgZm9yIGRpZmZpbmdcblx0XHRvbGRQcm9wcyA9IHtcblx0XHRcdHN0YXJ0OiBldmVudC5fc3RhcnQuY2xvbmUoKSxcblx0XHRcdGVuZDogZXZlbnQuX2VuZCA/IGV2ZW50Ll9lbmQuY2xvbmUoKSA6IHQuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50Ll9hbGxEYXksIGV2ZW50Ll9zdGFydCksXG5cdFx0XHRhbGxEYXk6IG5ld1Byb3BzLmFsbERheSAvLyBub3JtYWxpemUgdGhlIGRhdGVzIGluIHRoZSBzYW1lIHJlZ2FyZCBhcyB0aGUgbmV3IHByb3BlcnRpZXNcblx0XHR9O1xuXHRcdG5vcm1hbGl6ZUV2ZW50RGF0ZXMob2xkUHJvcHMpO1xuXG5cdFx0Ly8gbmVlZCB0byBjbGVhciB0aGUgZW5kIGRhdGUgaWYgZXhwbGljaXRseSBjaGFuZ2VkIHRvIG51bGxcblx0XHRjbGVhckVuZCA9IGV2ZW50Ll9lbmQgIT09IG51bGwgJiYgbmV3UHJvcHMuZW5kID09PSBudWxsO1xuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgZGVsdGEgZm9yIG1vdmluZyB0aGUgc3RhcnQgZGF0ZVxuXHRcdHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMobmV3UHJvcHMuc3RhcnQsIG9sZFByb3BzLnN0YXJ0KTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGRlbHRhIGZvciBtb3ZpbmcgdGhlIGVuZCBkYXRlXG5cdFx0aWYgKG5ld1Byb3BzLmVuZCkge1xuXHRcdFx0ZW5kRGVsdGEgPSBkaWZmRGF0ZXMobmV3UHJvcHMuZW5kLCBvbGRQcm9wcy5lbmQpO1xuXHRcdFx0ZHVyYXRpb25EZWx0YSA9IGVuZERlbHRhLnN1YnRyYWN0KHN0YXJ0RGVsdGEpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGR1cmF0aW9uRGVsdGEgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIGdhdGhlciBhbGwgbm9uLWRhdGUtcmVsYXRlZCBwcm9wZXJ0aWVzXG5cdFx0JC5lYWNoKG5ld1Byb3BzLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRcdGlmIChpc01pc2NFdmVudFByb3BOYW1lKG5hbWUpKSB7XG5cdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG1pc2NQcm9wc1tuYW1lXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gYXBwbHkgdGhlIG9wZXJhdGlvbnMgdG8gdGhlIGV2ZW50IGFuZCBhbGwgcmVsYXRlZCBldmVudHNcblx0XHR1bmRvRnVuYyA9IG11dGF0ZUV2ZW50cyhcblx0XHRcdGNsaWVudEV2ZW50cyhldmVudC5faWQpLCAvLyBnZXQgZXZlbnRzIHdpdGggdGhpcyBJRFxuXHRcdFx0Y2xlYXJFbmQsXG5cdFx0XHRuZXdQcm9wcy5hbGxEYXksXG5cdFx0XHRzdGFydERlbHRhLFxuXHRcdFx0ZHVyYXRpb25EZWx0YSxcblx0XHRcdG1pc2NQcm9wc1xuXHRcdCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0ZURlbHRhOiBzdGFydERlbHRhLFxuXHRcdFx0ZHVyYXRpb25EZWx0YTogZHVyYXRpb25EZWx0YSxcblx0XHRcdHVuZG86IHVuZG9GdW5jXG5cdFx0fTtcblx0fVxuXG5cblx0Ly8gTW9kaWZpZXMgYW4gYXJyYXkgb2YgZXZlbnRzIGluIHRoZSBmb2xsb3dpbmcgd2F5cyAob3BlcmF0aW9ucyBhcmUgaW4gb3JkZXIpOlxuXHQvLyAtIGNsZWFyIHRoZSBldmVudCdzIGBlbmRgXG5cdC8vIC0gY29udmVydCB0aGUgZXZlbnQgdG8gYWxsRGF5XG5cdC8vIC0gYWRkIGBkYXRlRGVsdGFgIHRvIHRoZSBzdGFydCBhbmQgZW5kXG5cdC8vIC0gYWRkIGBkdXJhdGlvbkRlbHRhYCB0byB0aGUgZXZlbnQncyBkdXJhdGlvblxuXHQvLyAtIGFzc2lnbiBgbWlzY1Byb3BzYCB0byB0aGUgZXZlbnRcblx0Ly9cblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byB1bmRvIGFsbCB0aGUgb3BlcmF0aW9ucy5cblx0Ly9cblx0Ly8gVE9ETzogZG9uJ3QgdXNlIHNvIG1hbnkgY2xvc3VyZXMuIHBvc3NpYmxlIG1lbW9yeSBpc3N1ZXMgd2hlbiBsb3RzIG9mIGV2ZW50cyB3aXRoIHNhbWUgSUQuXG5cdC8vXG5cdGZ1bmN0aW9uIG11dGF0ZUV2ZW50cyhldmVudHMsIGNsZWFyRW5kLCBhbGxEYXksIGRhdGVEZWx0YSwgZHVyYXRpb25EZWx0YSwgbWlzY1Byb3BzKSB7XG5cdFx0dmFyIGlzQW1iaWdUaW1lem9uZSA9IHQuZ2V0SXNBbWJpZ1RpbWV6b25lKCk7XG5cdFx0dmFyIHVuZG9GdW5jdGlvbnMgPSBbXTtcblxuXHRcdC8vIG5vcm1hbGl6ZSB6ZXJvLWxlbmd0aCBkZWx0YXMgdG8gYmUgbnVsbFxuXHRcdGlmIChkYXRlRGVsdGEgJiYgIWRhdGVEZWx0YS52YWx1ZU9mKCkpIHsgZGF0ZURlbHRhID0gbnVsbDsgfVxuXHRcdGlmIChkdXJhdGlvbkRlbHRhICYmICFkdXJhdGlvbkRlbHRhLnZhbHVlT2YoKSkgeyBkdXJhdGlvbkRlbHRhID0gbnVsbDsgfVxuXG5cdFx0JC5lYWNoKGV2ZW50cywgZnVuY3Rpb24oaSwgZXZlbnQpIHtcblx0XHRcdHZhciBvbGRQcm9wcztcblx0XHRcdHZhciBuZXdQcm9wcztcblxuXHRcdFx0Ly8gYnVpbGQgYW4gb2JqZWN0IGhvbGRpbmcgYWxsIHRoZSBvbGQgdmFsdWVzLCBib3RoIGRhdGUtcmVsYXRlZCBhbmQgbWlzYy5cblx0XHRcdC8vIGZvciB0aGUgdW5kbyBmdW5jdGlvbi5cblx0XHRcdG9sZFByb3BzID0ge1xuXHRcdFx0XHRzdGFydDogZXZlbnQuc3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0ZW5kOiBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGwsXG5cdFx0XHRcdGFsbERheTogZXZlbnQuYWxsRGF5XG5cdFx0XHR9O1xuXHRcdFx0JC5lYWNoKG1pc2NQcm9wcywgZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRvbGRQcm9wc1tuYW1lXSA9IGV2ZW50W25hbWVdO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIG5ldyBkYXRlLXJlbGF0ZWQgcHJvcGVydGllcy4gd29yayBvZmYgdGhlIG9yaWdpbmFsIGRhdGUgc25hcHNob3QuXG5cdFx0XHQvLyBvayB0byB1c2UgcmVmZXJlbmNlcyBiZWNhdXNlIHRoZXkgd2lsbCBiZSB0aHJvd24gYXdheSB3aGVuIGJhY2t1cEV2ZW50RGF0ZXMgaXMgY2FsbGVkLlxuXHRcdFx0bmV3UHJvcHMgPSB7XG5cdFx0XHRcdHN0YXJ0OiBldmVudC5fc3RhcnQsXG5cdFx0XHRcdGVuZDogZXZlbnQuX2VuZCxcblx0XHRcdFx0YWxsRGF5OiBhbGxEYXkgLy8gbm9ybWFsaXplIHRoZSBkYXRlcyBpbiB0aGUgc2FtZSByZWdhcmQgYXMgdGhlIG5ldyBwcm9wZXJ0aWVzXG5cdFx0XHR9O1xuXHRcdFx0bm9ybWFsaXplRXZlbnREYXRlcyhuZXdQcm9wcyk7IC8vIG1hc3NhZ2VzIHN0YXJ0L2VuZC9hbGxEYXlcblxuXHRcdFx0Ly8gc3RyaXAgb3IgZW5zdXJlIHRoZSBlbmQgZGF0ZVxuXHRcdFx0aWYgKGNsZWFyRW5kKSB7XG5cdFx0XHRcdG5ld1Byb3BzLmVuZCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChkdXJhdGlvbkRlbHRhICYmICFuZXdQcm9wcy5lbmQpIHsgLy8gdGhlIGR1cmF0aW9uIHRyYW5zbGF0aW9uIHJlcXVpcmVzIGFuIGVuZCBkYXRlXG5cdFx0XHRcdG5ld1Byb3BzLmVuZCA9IHQuZ2V0RGVmYXVsdEV2ZW50RW5kKG5ld1Byb3BzLmFsbERheSwgbmV3UHJvcHMuc3RhcnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0ZURlbHRhKSB7XG5cdFx0XHRcdG5ld1Byb3BzLnN0YXJ0LmFkZChkYXRlRGVsdGEpO1xuXHRcdFx0XHRpZiAobmV3UHJvcHMuZW5kKSB7XG5cdFx0XHRcdFx0bmV3UHJvcHMuZW5kLmFkZChkYXRlRGVsdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkdXJhdGlvbkRlbHRhKSB7XG5cdFx0XHRcdG5ld1Byb3BzLmVuZC5hZGQoZHVyYXRpb25EZWx0YSk7IC8vIGVuZCBhbHJlYWR5IGVuc3VyZWQgYWJvdmVcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIGRhdGVzIGhhdmUgY2hhbmdlZCwgYW5kIHdlIGtub3cgaXQgaXMgaW1wb3NzaWJsZSB0byByZWNvbXB1dGUgdGhlXG5cdFx0XHQvLyB0aW1lem9uZSBvZmZzZXRzLCBzdHJpcCB0aGUgem9uZS5cblx0XHRcdGlmIChcblx0XHRcdFx0aXNBbWJpZ1RpbWV6b25lICYmXG5cdFx0XHRcdCFuZXdQcm9wcy5hbGxEYXkgJiZcblx0XHRcdFx0KGRhdGVEZWx0YSB8fCBkdXJhdGlvbkRlbHRhKVxuXHRcdFx0KSB7XG5cdFx0XHRcdG5ld1Byb3BzLnN0YXJ0LnN0cmlwWm9uZSgpO1xuXHRcdFx0XHRpZiAobmV3UHJvcHMuZW5kKSB7XG5cdFx0XHRcdFx0bmV3UHJvcHMuZW5kLnN0cmlwWm9uZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQuZXh0ZW5kKGV2ZW50LCBtaXNjUHJvcHMsIG5ld1Byb3BzKTsgLy8gY29weSBvdmVyIG1pc2MgcHJvcHMsIHRoZW4gZGF0ZS1yZWxhdGVkIHByb3BzXG5cdFx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTsgLy8gcmVnZW5lcmF0ZSBpbnRlcm5hbCBfc3RhcnQvX2VuZC9fYWxsRGF5XG5cblx0XHRcdHVuZG9GdW5jdGlvbnMucHVzaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JC5leHRlbmQoZXZlbnQsIG9sZFByb3BzKTtcblx0XHRcdFx0YmFja3VwRXZlbnREYXRlcyhldmVudCk7IC8vIHJlZ2VuZXJhdGUgaW50ZXJuYWwgX3N0YXJ0L19lbmQvX2FsbERheVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHVuZG9GdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dW5kb0Z1bmN0aW9uc1tpXSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR0LmdldEJ1c2luZXNzSG91cnNFdmVudHMgPSBnZXRCdXNpbmVzc0hvdXJzRXZlbnRzO1xuXG5cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBldmVudHMgYXMgdG8gd2hlbiB0aGUgYnVzaW5lc3MgaG91cnMgb2NjdXIgaW4gdGhlIGdpdmVuIHZpZXcuXG5cdC8vIEFidXNlIG9mIG91ciBldmVudCBzeXN0ZW0gOihcblx0ZnVuY3Rpb24gZ2V0QnVzaW5lc3NIb3Vyc0V2ZW50cyh3aG9sZURheSkge1xuXHRcdHZhciBvcHRpb25WYWwgPSB0Lm9wdGlvbnMuYnVzaW5lc3NIb3Vycztcblx0XHR2YXIgZGVmYXVsdFZhbCA9IHtcblx0XHRcdGNsYXNzTmFtZTogJ2ZjLW5vbmJ1c2luZXNzJyxcblx0XHRcdHN0YXJ0OiAnMDk6MDAnLFxuXHRcdFx0ZW5kOiAnMTc6MDAnLFxuXHRcdFx0ZG93OiBbIDEsIDIsIDMsIDQsIDUgXSwgLy8gbW9uZGF5IC0gZnJpZGF5XG5cdFx0XHRyZW5kZXJpbmc6ICdpbnZlcnNlLWJhY2tncm91bmQnXG5cdFx0fTtcblx0XHR2YXIgdmlldyA9IHQuZ2V0VmlldygpO1xuXHRcdHZhciBldmVudElucHV0O1xuXG5cdFx0aWYgKG9wdGlvblZhbCkgeyAvLyBgdHJ1ZWAgKHdoaWNoIG1lYW5zIFwidXNlIHRoZSBkZWZhdWx0c1wiKSBvciBhbiBvdmVycmlkZSBvYmplY3Rcblx0XHRcdGV2ZW50SW5wdXQgPSAkLmV4dGVuZChcblx0XHRcdFx0e30sIC8vIGNvcHkgdG8gYSBuZXcgb2JqZWN0IGluIGVpdGhlciBjYXNlXG5cdFx0XHRcdGRlZmF1bHRWYWwsXG5cdFx0XHRcdHR5cGVvZiBvcHRpb25WYWwgPT09ICdvYmplY3QnID8gb3B0aW9uVmFsIDoge30gLy8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChldmVudElucHV0KSB7XG5cblx0XHRcdC8vIGlmIGEgd2hvbGUtZGF5IHNlcmllcyBpcyByZXF1ZXN0ZWQsIGNsZWFyIHRoZSBzdGFydC9lbmQgdGltZXNcblx0XHRcdGlmICh3aG9sZURheSkge1xuXHRcdFx0XHRldmVudElucHV0LnN0YXJ0ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnRJbnB1dC5lbmQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kRXZlbnQoXG5cdFx0XHRcdGJ1aWxkRXZlbnRGcm9tSW5wdXQoZXZlbnRJbnB1dCksXG5cdFx0XHRcdHZpZXcuc3RhcnQsXG5cdFx0XHRcdHZpZXcuZW5kXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cblx0LyogT3ZlcmxhcHBpbmcgLyBDb25zdHJhaW5pbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHQuaXNFdmVudFNwYW5BbGxvd2VkID0gaXNFdmVudFNwYW5BbGxvd2VkO1xuXHR0LmlzRXh0ZXJuYWxTcGFuQWxsb3dlZCA9IGlzRXh0ZXJuYWxTcGFuQWxsb3dlZDtcblx0dC5pc1NlbGVjdGlvblNwYW5BbGxvd2VkID0gaXNTZWxlY3Rpb25TcGFuQWxsb3dlZDtcblxuXG5cdC8vIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGNhbiBiZSByZWxvY2F0ZWQgdG8gdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKVxuXHRmdW5jdGlvbiBpc0V2ZW50U3BhbkFsbG93ZWQoc3BhbiwgZXZlbnQpIHtcblx0XHR2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IHt9O1xuXHRcdHZhciBjb25zdHJhaW50ID0gZmlyc3REZWZpbmVkKFxuXHRcdFx0ZXZlbnQuY29uc3RyYWludCxcblx0XHRcdHNvdXJjZS5jb25zdHJhaW50LFxuXHRcdFx0dC5vcHRpb25zLmV2ZW50Q29uc3RyYWludFxuXHRcdCk7XG5cdFx0dmFyIG92ZXJsYXAgPSBmaXJzdERlZmluZWQoXG5cdFx0XHRldmVudC5vdmVybGFwLFxuXHRcdFx0c291cmNlLm92ZXJsYXAsXG5cdFx0XHR0Lm9wdGlvbnMuZXZlbnRPdmVybGFwXG5cdFx0KTtcblx0XHRyZXR1cm4gaXNTcGFuQWxsb3dlZChzcGFuLCBjb25zdHJhaW50LCBvdmVybGFwLCBldmVudCk7XG5cdH1cblxuXG5cdC8vIERldGVybWluZXMgaWYgYW4gZXh0ZXJuYWwgZXZlbnQgY2FuIGJlIHJlbG9jYXRlZCB0byB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpXG5cdGZ1bmN0aW9uIGlzRXh0ZXJuYWxTcGFuQWxsb3dlZChldmVudFNwYW4sIGV2ZW50TG9jYXRpb24sIGV2ZW50UHJvcHMpIHtcblx0XHR2YXIgZXZlbnRJbnB1dDtcblx0XHR2YXIgZXZlbnQ7XG5cblx0XHQvLyBub3RlOiB2ZXJ5IHNpbWlsYXIgbG9naWMgaXMgaW4gVmlldydzIHJlcG9ydEV4dGVybmFsRHJvcFxuXHRcdGlmIChldmVudFByb3BzKSB7XG5cdFx0XHRldmVudElucHV0ID0gJC5leHRlbmQoe30sIGV2ZW50UHJvcHMsIGV2ZW50TG9jYXRpb24pO1xuXHRcdFx0ZXZlbnQgPSBleHBhbmRFdmVudChidWlsZEV2ZW50RnJvbUlucHV0KGV2ZW50SW5wdXQpKVswXTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdHJldHVybiBpc0V2ZW50U3BhbkFsbG93ZWQoZXZlbnRTcGFuLCBldmVudCk7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyB0cmVhdCBpdCBhcyBhIHNlbGVjdGlvblxuXG5cdFx0XHRyZXR1cm4gaXNTZWxlY3Rpb25TcGFuQWxsb3dlZChldmVudFNwYW4pO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gRGV0ZXJtaW5lcyB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGNhbiBiZSBzZWxlY3RlZC5cblx0ZnVuY3Rpb24gaXNTZWxlY3Rpb25TcGFuQWxsb3dlZChzcGFuKSB7XG5cdFx0cmV0dXJuIGlzU3BhbkFsbG93ZWQoc3BhbiwgdC5vcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsIHQub3B0aW9ucy5zZWxlY3RPdmVybGFwKTtcblx0fVxuXG5cblx0Ly8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzcGFuIChjYXVzZWQgYnkgYW4gZXZlbnQgZHJvcC9yZXNpemUgb3IgYSBzZWxlY3Rpb24pIGlzIGFsbG93ZWQgdG8gZXhpc3Rcblx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb25zdHJhaW50L292ZXJsYXAgc2V0dGluZ3MuXG5cdC8vIGBldmVudGAgaXMgbm90IHJlcXVpcmVkIGlmIGNoZWNraW5nIGEgc2VsZWN0aW9uLlxuXHRmdW5jdGlvbiBpc1NwYW5BbGxvd2VkKHNwYW4sIGNvbnN0cmFpbnQsIG92ZXJsYXAsIGV2ZW50KSB7XG5cdFx0dmFyIGNvbnN0cmFpbnRFdmVudHM7XG5cdFx0dmFyIGFueUNvbnRhaW5tZW50O1xuXHRcdHZhciBwZWVyRXZlbnRzO1xuXHRcdHZhciBpLCBwZWVyRXZlbnQ7XG5cdFx0dmFyIHBlZXJPdmVybGFwO1xuXG5cdFx0Ly8gdGhlIHJhbmdlIG11c3QgYmUgZnVsbHkgY29udGFpbmVkIGJ5IGF0IGxlYXN0IG9uZSBvZiBwcm9kdWNlZCBjb25zdHJhaW50IGV2ZW50c1xuXHRcdGlmIChjb25zdHJhaW50ICE9IG51bGwpIHtcblxuXHRcdFx0Ly8gbm90IHRyZWF0ZWQgYXMgYW4gZXZlbnQhIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZVxuXHRcdFx0Ly8gVE9ETzogdXNlIHJhbmdlcyBpbiB0aGUgZnV0dXJlXG5cdFx0XHRjb25zdHJhaW50RXZlbnRzID0gY29uc3RyYWludFRvRXZlbnRzKGNvbnN0cmFpbnQpO1xuXG5cdFx0XHRhbnlDb250YWlubWVudCA9IGZhbHNlO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRFdmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGV2ZW50Q29udGFpbnNSYW5nZShjb25zdHJhaW50RXZlbnRzW2ldLCBzcGFuKSkge1xuXHRcdFx0XHRcdGFueUNvbnRhaW5tZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWFueUNvbnRhaW5tZW50KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwZWVyRXZlbnRzID0gdC5nZXRQZWVyRXZlbnRzKHNwYW4sIGV2ZW50KTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBwZWVyRXZlbnRzLmxlbmd0aDsgaSsrKSAge1xuXHRcdFx0cGVlckV2ZW50ID0gcGVlckV2ZW50c1tpXTtcblxuXHRcdFx0Ly8gdGhlcmUgbmVlZHMgdG8gYmUgYW4gYWN0dWFsIGludGVyc2VjdGlvbiBiZWZvcmUgZGlzYWxsb3dpbmcgYW55dGhpbmdcblx0XHRcdGlmIChldmVudEludGVyc2VjdHNSYW5nZShwZWVyRXZlbnQsIHNwYW4pKSB7XG5cblx0XHRcdFx0Ly8gZXZhbHVhdGUgb3ZlcmxhcCBmb3IgdGhlIGdpdmVuIHJhbmdlIGFuZCBzaG9ydC1jaXJjdWl0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRpZiAob3ZlcmxhcCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGV2ZW50J3Mgb3ZlcmxhcCBpcyBhIHRlc3QgZnVuY3Rpb24sIHBhc3MgdGhlIHBlZXIgZXZlbnQgaW4gcXVlc3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtXG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBvdmVybGFwID09PSAnZnVuY3Rpb24nICYmICFvdmVybGFwKHBlZXJFdmVudCwgZXZlbnQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgd2UgYXJlIGNvbXB1dGluZyBpZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgYWxsb3dhYmxlIGZvciBhbiBldmVudCwgY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Ncblx0XHRcdFx0Ly8gRXZlbnRPYmplY3Qtc3BlY2lmaWMgb3IgU291cmNlLXNwZWNpZmljIGBvdmVybGFwYCBwcm9wZXJ0eVxuXHRcdFx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdFx0XHRwZWVyT3ZlcmxhcCA9IGZpcnN0RGVmaW5lZChcblx0XHRcdFx0XHRcdHBlZXJFdmVudC5vdmVybGFwLFxuXHRcdFx0XHRcdFx0KHBlZXJFdmVudC5zb3VyY2UgfHwge30pLm92ZXJsYXBcblx0XHRcdFx0XHRcdC8vIHdlIGFscmVhZHkgY29uc2lkZXJlZCB0aGUgZ2xvYmFsIGBldmVudE92ZXJsYXBgXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAocGVlck92ZXJsYXAgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGlmIHRoZSBwZWVyIGV2ZW50J3Mgb3ZlcmxhcCBpcyBhIHRlc3QgZnVuY3Rpb24sIHBhc3MgdGhlIHN1YmplY3QgZXZlbnQgYXMgdGhlIGZpcnN0IHBhcmFtXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBwZWVyT3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhcGVlck92ZXJsYXAoZXZlbnQsIHBlZXJFdmVudCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQgaW5wdXQgZnJvbSB0aGUgQVBJLCBwcm9kdWNlcyBhbiBhcnJheSBvZiBldmVudCBvYmplY3RzLiBQb3NzaWJsZSBldmVudCBpbnB1dHM6XG5cdC8vICdidXNpbmVzc0hvdXJzJ1xuXHQvLyBBbiBldmVudCBJRCAobnVtYmVyIG9yIHN0cmluZylcblx0Ly8gQW4gb2JqZWN0IHdpdGggc3BlY2lmaWMgc3RhcnQvZW5kIGRhdGVzIG9yIGEgcmVjdXJyaW5nIGV2ZW50IChsaWtlIHdoYXQgYnVzaW5lc3NIb3VycyBhY2NlcHRzKVxuXHRmdW5jdGlvbiBjb25zdHJhaW50VG9FdmVudHMoY29uc3RyYWludElucHV0KSB7XG5cblx0XHRpZiAoY29uc3RyYWludElucHV0ID09PSAnYnVzaW5lc3NIb3VycycpIHtcblx0XHRcdHJldHVybiBnZXRCdXNpbmVzc0hvdXJzRXZlbnRzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBjb25zdHJhaW50SW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZXhwYW5kRXZlbnQoYnVpbGRFdmVudEZyb21JbnB1dChjb25zdHJhaW50SW5wdXQpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xpZW50RXZlbnRzKGNvbnN0cmFpbnRJbnB1dCk7IC8vIHByb2JhYmx5IGFuIElEXG5cdH1cblxuXG5cdC8vIERvZXMgdGhlIGV2ZW50J3MgZGF0ZSByYW5nZSBmdWxseSBjb250YWluIHRoZSBnaXZlbiByYW5nZT9cblx0Ly8gc3RhcnQvZW5kIGFscmVhZHkgYXNzdW1lZCB0byBoYXZlIHN0cmlwcGVkIHpvbmVzIDooXG5cdGZ1bmN0aW9uIGV2ZW50Q29udGFpbnNSYW5nZShldmVudCwgcmFuZ2UpIHtcblx0XHR2YXIgZXZlbnRTdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCk7XG5cdFx0dmFyIGV2ZW50RW5kID0gdC5nZXRFdmVudEVuZChldmVudCkuc3RyaXBab25lKCk7XG5cblx0XHRyZXR1cm4gcmFuZ2Uuc3RhcnQgPj0gZXZlbnRTdGFydCAmJiByYW5nZS5lbmQgPD0gZXZlbnRFbmQ7XG5cdH1cblxuXG5cdC8vIERvZXMgdGhlIGV2ZW50J3MgZGF0ZSByYW5nZSBpbnRlcnNlY3Qgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2U/XG5cdC8vIHN0YXJ0L2VuZCBhbHJlYWR5IGFzc3VtZWQgdG8gaGF2ZSBzdHJpcHBlZCB6b25lcyA6KFxuXHRmdW5jdGlvbiBldmVudEludGVyc2VjdHNSYW5nZShldmVudCwgcmFuZ2UpIHtcblx0XHR2YXIgZXZlbnRTdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCk7XG5cdFx0dmFyIGV2ZW50RW5kID0gdC5nZXRFdmVudEVuZChldmVudCkuc3RyaXBab25lKCk7XG5cblx0XHRyZXR1cm4gcmFuZ2Uuc3RhcnQgPCBldmVudEVuZCAmJiByYW5nZS5lbmQgPiBldmVudFN0YXJ0O1xuXHR9XG5cblxuXHR0LmdldEV2ZW50Q2FjaGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gY2FjaGU7XG5cdH07XG5cbn1cblxuXG4vLyBob29rIGZvciBleHRlcm5hbCBsaWJzIHRvIG1hbmlwdWxhdGUgZXZlbnQgcHJvcGVydGllcyB1cG9uIGNyZWF0aW9uLlxuLy8gc2hvdWxkIG1hbmlwdWxhdGUgdGhlIGV2ZW50IGluLXBsYWNlLlxuQ2FsZW5kYXIucHJvdG90eXBlLm5vcm1hbGl6ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbn07XG5cblxuLy8gUmV0dXJucyBhIGxpc3Qgb2YgZXZlbnRzIHRoYXQgdGhlIGdpdmVuIGV2ZW50IHNob3VsZCBiZSBjb21wYXJlZCBhZ2FpbnN0IHdoZW4gYmVpbmcgY29uc2lkZXJlZCBmb3IgYSBtb3ZlIHRvXG4vLyB0aGUgc3BlY2lmaWVkIHNwYW4uIEF0dGFjaGVkIHRvIHRoZSBDYWxlbmRhcidzIHByb3RvdHlwZSBiZWNhdXNlIEV2ZW50TWFuYWdlciBpcyBhIG1peGluIGZvciBhIENhbGVuZGFyLlxuQ2FsZW5kYXIucHJvdG90eXBlLmdldFBlZXJFdmVudHMgPSBmdW5jdGlvbihzcGFuLCBldmVudCkge1xuXHR2YXIgY2FjaGUgPSB0aGlzLmdldEV2ZW50Q2FjaGUoKTtcblx0dmFyIHBlZXJFdmVudHMgPSBbXTtcblx0dmFyIGksIG90aGVyRXZlbnQ7XG5cblx0Zm9yIChpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG5cdFx0b3RoZXJFdmVudCA9IGNhY2hlW2ldO1xuXHRcdGlmIChcblx0XHRcdCFldmVudCB8fFxuXHRcdFx0ZXZlbnQuX2lkICE9PSBvdGhlckV2ZW50Ll9pZCAvLyBkb24ndCBjb21wYXJlIHRoZSBldmVudCB0byBpdHNlbGYgb3Igb3RoZXIgcmVsYXRlZCBbcmVwZWF0aW5nXSBldmVudHNcblx0XHQpIHtcblx0XHRcdHBlZXJFdmVudHMucHVzaChvdGhlckV2ZW50KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGVlckV2ZW50cztcbn07XG5cblxuLy8gdXBkYXRlcyB0aGUgXCJiYWNrdXBcIiBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgcHJlc2VydmVkIGluIG9yZGVyIHRvIGNvbXB1dGUgZGlmZnMgbGF0ZXIgb24uXG5mdW5jdGlvbiBiYWNrdXBFdmVudERhdGVzKGV2ZW50KSB7XG5cdGV2ZW50Ll9hbGxEYXkgPSBldmVudC5hbGxEYXk7XG5cdGV2ZW50Ll9zdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCk7XG5cdGV2ZW50Ll9lbmQgPSBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGw7XG59XG5cbjs7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgXCJiYXNpY1wiIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBEYXlHcmlkIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cblxudmFyIEJhc2ljVmlldyA9IEZDLkJhc2ljVmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuXHRzY3JvbGxlcjogbnVsbCxcblxuXHRkYXlHcmlkQ2xhc3M6IERheUdyaWQsIC8vIGNsYXNzIHRoZSBkYXlHcmlkIHdpbGwgYmUgaW5zdGFudGlhdGVkIGZyb20gKG92ZXJyaWRhYmxlIGJ5IHN1YmNsYXNzZXMpXG5cdGRheUdyaWQ6IG51bGwsIC8vIHRoZSBtYWluIHN1YmNvbXBvbmVudCB0aGF0IGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZ1xuXG5cdGRheU51bWJlcnNWaXNpYmxlOiBmYWxzZSwgLy8gZGlzcGxheSBkYXkgbnVtYmVycyBvbiBlYWNoIGRheSBjZWxsP1xuXHR3ZWVrTnVtYmVyc1Zpc2libGU6IGZhbHNlLCAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBhbG9uZyB0aGUgc2lkZT9cblxuXHR3ZWVrTnVtYmVyV2lkdGg6IG51bGwsIC8vIHdpZHRoIG9mIGFsbCB0aGUgd2Vlay1udW1iZXIgY2VsbHMgcnVubmluZyBkb3duIHRoZSBzaWRlXG5cblx0aGVhZENvbnRhaW5lckVsOiBudWxsLCAvLyBkaXYgdGhhdCBob2xkJ3MgdGhlIGRheUdyaWQncyByZW5kZXJlZCBkYXRlIGhlYWRlclxuXHRoZWFkUm93RWw6IG51bGwsIC8vIHRoZSBmYWtlIHJvdyBlbGVtZW50IG9mIHRoZSBkYXktb2Ytd2VlayBoZWFkZXJcblxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZCA9IHRoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHtcblx0XHRcdG92ZXJmbG93WDogJ2hpZGRlbicsXG5cdFx0XHRvdmVyZmxvd1k6ICdhdXRvJ1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbmVlZHMuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3Ncblx0aW5zdGFudGlhdGVEYXlHcmlkOiBmdW5jdGlvbigpIHtcblx0XHQvLyBnZW5lcmF0ZSBhIHN1YmNsYXNzIG9uIHRoZSBmbHkgd2l0aCBCYXNpY1ZpZXctc3BlY2lmaWMgYmVoYXZpb3Jcblx0XHQvLyBUT0RPOiBjYWNoZSB0aGlzIHN1YmNsYXNzXG5cdFx0dmFyIHN1YmNsYXNzID0gdGhpcy5kYXlHcmlkQ2xhc3MuZXh0ZW5kKGJhc2ljRGF5R3JpZE1ldGhvZHMpO1xuXG5cdFx0cmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcblx0fSxcblxuXG5cdC8vIFNldHMgdGhlIGRpc3BsYXkgcmFuZ2UgYW5kIGNvbXB1dGVzIGFsbCBuZWNlc3NhcnkgZGF0ZXNcblx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0Vmlldy5wcm90b3R5cGUuc2V0UmFuZ2UuY2FsbCh0aGlzLCByYW5nZSk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXG5cdFx0dGhpcy5kYXlHcmlkLmJyZWFrT25XZWVrcyA9IC95ZWFyfG1vbnRofHdlZWsvLnRlc3QodGhpcy5pbnRlcnZhbFVuaXQpOyAvLyBkbyBiZWZvcmUgc2V0UmFuZ2Vcblx0XHR0aGlzLmRheUdyaWQuc2V0UmFuZ2UocmFuZ2UpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZSB0aGUgdmFsdWUgdG8gZmVlZCBpbnRvIHNldFJhbmdlLiBPdmVycmlkZXMgc3VwZXJjbGFzcy5cblx0Y29tcHV0ZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHJhbmdlID0gVmlldy5wcm90b3R5cGUuY29tcHV0ZVJhbmdlLmNhbGwodGhpcywgZGF0ZSk7IC8vIGdldCB2YWx1ZSBmcm9tIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG5cdFx0aWYgKC95ZWFyfG1vbnRoLy50ZXN0KHJhbmdlLmludGVydmFsVW5pdCkpIHtcblx0XHRcdHJhbmdlLnN0YXJ0LnN0YXJ0T2YoJ3dlZWsnKTtcblx0XHRcdHJhbmdlLnN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhyYW5nZS5zdGFydCk7XG5cblx0XHRcdC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcblx0XHRcdGlmIChyYW5nZS5lbmQud2Vla2RheSgpKSB7XG5cdFx0XHRcdHJhbmdlLmVuZC5hZGQoMSwgJ3dlZWsnKS5zdGFydE9mKCd3ZWVrJyk7XG5cdFx0XHRcdHJhbmdlLmVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMocmFuZ2UuZW5kLCAtMSwgdHJ1ZSk7IC8vIGV4Y2x1c2l2ZWx5IG1vdmUgYmFja3dhcmRzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJhbmdlO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgdmlldyBpbnRvIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWRcblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5kYXlOdW1iZXJzVmlzaWJsZSA9IHRoaXMuZGF5R3JpZC5yb3dDbnQgPiAxOyAvLyBUT0RPOiBtYWtlIGdyaWQgcmVzcG9uc2libGVcblx0XHR0aGlzLndlZWtOdW1iZXJzVmlzaWJsZSA9IHRoaXMub3B0KCd3ZWVrTnVtYmVycycpO1xuXHRcdHRoaXMuZGF5R3JpZC5udW1iZXJzVmlzaWJsZSA9IHRoaXMuZGF5TnVtYmVyc1Zpc2libGUgfHwgdGhpcy53ZWVrTnVtYmVyc1Zpc2libGU7XG5cblx0XHR0aGlzLmVsLmFkZENsYXNzKCdmYy1iYXNpYy12aWV3JykuaHRtbCh0aGlzLnJlbmRlclNrZWxldG9uSHRtbCgpKTtcblx0XHR0aGlzLnJlbmRlckhlYWQoKTtcblxuXHRcdHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XG5cdFx0dmFyIGRheUdyaWRDb250YWluZXJFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLWRheS1ncmlkLWNvbnRhaW5lcicpO1xuXHRcdHZhciBkYXlHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtZGF5LWdyaWRcIiAvPicpLmFwcGVuZFRvKGRheUdyaWRDb250YWluZXJFbCk7XG5cdFx0dGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQoZGF5R3JpZENvbnRhaW5lckVsKTtcblxuXHRcdHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KGRheUdyaWRFbCk7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbmRlckRhdGVzKHRoaXMuaGFzUmlnaWRSb3dzKCkpO1xuXHR9LFxuXG5cblx0Ly8gcmVuZGVyIHRoZSBkYXktb2Ytd2VlayBoZWFkZXJzXG5cdHJlbmRlckhlYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZENvbnRhaW5lckVsID1cblx0XHRcdHRoaXMuZWwuZmluZCgnLmZjLWhlYWQtY29udGFpbmVyJylcblx0XHRcdFx0Lmh0bWwodGhpcy5kYXlHcmlkLnJlbmRlckhlYWRIdG1sKCkpO1xuXHRcdHRoaXMuaGVhZFJvd0VsID0gdGhpcy5oZWFkQ29udGFpbmVyRWwuZmluZCgnLmZjLXJvdycpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHRoZSBjb250ZW50IG9mIHRoZSB2aWV3LiBTaW5jZSB3ZSBoYXZlbid0IHNlcGFyYXRlZCBza2VsZXRvbiByZW5kZXJpbmcgZnJvbSBkYXRlIHJlbmRlcmluZyxcblx0Ly8gYWx3YXlzIGNvbXBsZXRlbHkga2lsbCB0aGUgZGF5R3JpZCdzIHJlbmRlcmluZy5cblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRGF0ZXMoKTtcblx0XHR0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xuXHRcdHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xuXHR9LFxuXG5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cblx0Ly8gVGhlIGRheS1ncmlkIGNvbXBvbmVudCB3aWxsIHJlbmRlciBpbnNpZGUgb2YgYSBjb250YWluZXIgZGVmaW5lZCBieSB0aGlzIEhUTUwuXG5cdHJlbmRlclNrZWxldG9uSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdCc8dGhlYWQgY2xhc3M9XCJmYy1oZWFkXCI+JyArXG5cdFx0XHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIj48L3RkPicgK1xuXHRcdFx0XHRcdCc8L3RyPicgK1xuXHRcdFx0XHQnPC90aGVhZD4nICtcblx0XHRcdFx0Jzx0Ym9keSBjbGFzcz1cImZjLWJvZHlcIj4nICtcblx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cIicgKyB0aGlzLndpZGdldENvbnRlbnRDbGFzcyArICdcIj48L3RkPicgK1xuXHRcdFx0XHRcdCc8L3RyPicgK1xuXHRcdFx0XHQnPC90Ym9keT4nICtcblx0XHRcdCc8L3RhYmxlPic7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gSFRNTCBhdHRyaWJ1dGUgc3RyaW5nIGZvciBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgd2VlayBudW1iZXIgY29sdW1uLCBpZiBpdCBpcyBrbm93blxuXHR3ZWVrTnVtYmVyU3R5bGVBdHRyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy53ZWVrTnVtYmVyV2lkdGggIT09IG51bGwpIHtcblx0XHRcdHJldHVybiAnc3R5bGU9XCJ3aWR0aDonICsgdGhpcy53ZWVrTnVtYmVyV2lkdGggKyAncHhcIic7XG5cdFx0fVxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIERldGVybWluZXMgd2hldGhlciBlYWNoIHJvdyBzaG91bGQgaGF2ZSBhIGNvbnN0YW50IGhlaWdodFxuXHRoYXNSaWdpZFJvd3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcblx0XHRyZXR1cm4gZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcic7XG5cdH0sXG5cblxuXHQvKiBEaW1lbnNpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xuXHR1cGRhdGVXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMud2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgYWxsIHdlZWsgbnVtYmVyIGNlbGxzIHJ1bm5pbmcgZG93biB0aGUgc2lkZSBoYXZlIHRoZSBzYW1lIHdpZHRoLlxuXHRcdFx0Ly8gUmVjb3JkIHRoZSB3aWR0aCBmb3IgY2VsbHMgY3JlYXRlZCBsYXRlci5cblx0XHRcdHRoaXMud2Vla051bWJlcldpZHRoID0gbWF0Y2hDZWxsV2lkdGhzKFxuXHRcdFx0XHR0aGlzLmVsLmZpbmQoJy5mYy13ZWVrLW51bWJlcicpXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEFkanVzdHMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZXNcblx0c2V0SGVpZ2h0OiBmdW5jdGlvbih0b3RhbEhlaWdodCwgaXNBdXRvKSB7XG5cdFx0dmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xuXHRcdHZhciBzY3JvbGxlckhlaWdodDtcblx0XHR2YXIgc2Nyb2xsYmFyV2lkdGhzO1xuXG5cdFx0Ly8gcmVzZXQgYWxsIGhlaWdodHMgdG8gYmUgbmF0dXJhbFxuXHRcdHRoaXMuc2Nyb2xsZXIuY2xlYXIoKTtcblx0XHR1bmNvbXBlbnNhdGVTY3JvbGwodGhpcy5oZWFkUm93RWwpO1xuXG5cdFx0dGhpcy5kYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcblxuXHRcdC8vIGlzIHRoZSBldmVudCBsaW1pdCBhIGNvbnN0YW50IGxldmVsIG51bWJlcj9cblx0XHRpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgZmlyc3Qgc28gdGhlIGhlaWdodCBjYW4gcmVkaXN0cmlidXRlIGFmdGVyXG5cdFx0fVxuXG5cdFx0Ly8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXG5cdFx0Ly8gKHRvdGFsSGVpZ2h0IGlzIGEgXCJyZWNvbW1lbmRlZFwiIHZhbHVlIGlmIGlzQXV0bylcblx0XHRzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcblx0XHR0aGlzLnNldEdyaWRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQsIGlzQXV0byk7XG5cblx0XHQvLyBpcyB0aGUgZXZlbnQgbGltaXQgZHluYW1pY2FsbHkgY2FsY3VsYXRlZD9cblx0XHRpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgYWZ0ZXIgdGhlIGdyaWQncyByb3cgaGVpZ2h0cyBoYXZlIGJlZW4gc2V0XG5cdFx0fVxuXG5cdFx0aWYgKCFpc0F1dG8pIHsgLy8gc2hvdWxkIHdlIGZvcmNlIGRpbWVuc2lvbnMgb2YgdGhlIHNjcm9sbCBjb250YWluZXI/XG5cblx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcblx0XHRcdHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG5cblx0XHRcdGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHsgLy8gdXNpbmcgc2Nyb2xsYmFycz9cblxuXHRcdFx0XHRjb21wZW5zYXRlU2Nyb2xsKHRoaXMuaGVhZFJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpO1xuXG5cdFx0XHRcdC8vIGRvaW5nIHRoZSBzY3JvbGxiYXIgY29tcGVuc2F0aW9uIG1pZ2h0IGhhdmUgY3JlYXRlZCB0ZXh0IG92ZXJmbG93IHdoaWNoIGNyZWF0ZWQgbW9yZSBoZWlnaHQuIHJlZG9cblx0XHRcdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXG5cdFx0XHR0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcblx0Y29tcHV0ZVNjcm9sbGVySGVpZ2h0OiBmdW5jdGlvbih0b3RhbEhlaWdodCkge1xuXHRcdHJldHVybiB0b3RhbEhlaWdodCAtXG5cdFx0XHRzdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcblx0fSxcblxuXG5cdC8vIFNldHMgdGhlIGhlaWdodCBvZiBqdXN0IHRoZSBEYXlHcmlkIGNvbXBvbmVudCBpbiB0aGlzIHZpZXdcblx0c2V0R3JpZEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBpc0F1dG8pIHtcblx0XHRpZiAoaXNBdXRvKSB7XG5cdFx0XHR1bmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0Vscyk7IC8vIGxldCB0aGUgcm93cyBiZSB0aGVpciBuYXR1cmFsIGhlaWdodCB3aXRoIG5vIGV4cGFuZGluZ1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0VscywgaGVpZ2h0LCB0cnVlKTsgLy8gdHJ1ZSA9IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3Ncblx0XHR9XG5cdH0sXG5cblxuXHQvKiBTY3JvbGxcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHF1ZXJ5U2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKTtcblx0fSxcblxuXG5cdHNldFNjcm9sbDogZnVuY3Rpb24odG9wKSB7XG5cdFx0dGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3AodG9wKTtcblx0fSxcblxuXG5cdC8qIEhpdCBBcmVhc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBmb3J3YXJkIGFsbCBoaXQtcmVsYXRlZCBtZXRob2QgY2FsbHMgdG8gZGF5R3JpZFxuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC5wcmVwYXJlSGl0cygpO1xuXHR9LFxuXG5cblx0cmVsZWFzZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC5yZWxlYXNlSGl0cygpO1xuXHR9LFxuXG5cblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuXHRcdHJldHVybiB0aGlzLmRheUdyaWQucXVlcnlIaXQobGVmdCwgdG9wKTtcblx0fSxcblxuXG5cdGdldEhpdFNwYW46IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHJldHVybiB0aGlzLmRheUdyaWQuZ2V0SGl0U3BhbihoaXQpO1xuXHR9LFxuXG5cblx0Z2V0SGl0RWw6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHJldHVybiB0aGlzLmRheUdyaWQuZ2V0SGl0RWwoaGl0KTtcblx0fSxcblxuXG5cdC8qIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gZXZlbnRzIG9udG8gdGhlIHZpZXcgYW5kIHBvcHVsYXRlcyB0aGUgc2VnbWVudHMgYXJyYXlcblx0cmVuZGVyRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR0aGlzLmRheUdyaWQucmVuZGVyRXZlbnRzKGV2ZW50cyk7XG5cblx0XHR0aGlzLnVwZGF0ZUhlaWdodCgpOyAvLyBtdXN0IGNvbXBlbnNhdGUgZm9yIGV2ZW50cyB0aGF0IG92ZXJmbG93IHRoZSByb3dcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbGwgc2VnbWVudCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIGluIHRoZSB2aWV3XG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5nZXRFdmVudFNlZ3MoKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgZXZlbnQgZWxlbWVudHMgYW5kIGNsZWFycyBpbnRlcm5hbCBzZWdtZW50IGRhdGFcblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckV2ZW50cygpO1xuXG5cdFx0Ly8gd2UgRE9OJ1QgbmVlZCB0byBjYWxsIHVwZGF0ZUhlaWdodCgpIGJlY2F1c2U6XG5cdFx0Ly8gQSkgYSByZW5kZXJFdmVudHMoKSBjYWxsIGFsd2F5cyBoYXBwZW5zIGFmdGVyIHRoaXMsIHdoaWNoIHdpbGwgZXZlbnR1YWxseSBjYWxsIHVwZGF0ZUhlaWdodCgpXG5cdFx0Ly8gQikgaW4gSUU4LCB0aGlzIGNhdXNlcyBhIGZsYXNoIHdoZW5ldmVyIGV2ZW50cyBhcmUgcmVyZW5kZXJlZFxuXHR9LFxuXG5cblx0LyogRHJhZ2dpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGRyb3BMb2NhdGlvbiwgc2VnKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbiwgc2VnKTtcblx0fSxcblxuXG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRHJhZygpO1xuXHR9LFxuXG5cblx0LyogU2VsZWN0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbmRlclNlbGVjdGlvbihzcGFuKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9ucyBvZiBhIHNlbGVjdGlvblxuXHR1bnJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdH1cblxufSk7XG5cblxuLy8gTWV0aG9kcyB0aGF0IHdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEJhc2ljVmlldydzIGRheUdyaWRcbnZhciBiYXNpY0RheUdyaWRNZXRob2RzID0ge1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xuXHRyZW5kZXJIZWFkSW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdGlmICh2aWV3LndlZWtOdW1iZXJzVmlzaWJsZSkge1xuXHRcdFx0cmV0dXJuICcnICtcblx0XHRcdFx0Jzx0aCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdFx0JzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0aHRtbEVzY2FwZSh2aWV3Lm9wdCgnd2Vla051bWJlclRpdGxlJykpICtcblx0XHRcdFx0XHQnPC9zcGFuPicgK1xuXHRcdFx0XHQnPC90aD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIGNvbnRlbnQtc2tlbGV0b24gY2VsbHMgdGhhdCBkaXNwbGF5IHRoZSBkYXkvd2VlayBudW1iZXJzXG5cdHJlbmRlck51bWJlckludHJvSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy53ZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnJyArXG5cdFx0XHRcdCc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdFx0JzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRDZWxsRGF0ZShyb3csIDApLmZvcm1hdCgndycpICtcblx0XHRcdFx0XHQnPC9zcGFuPicgK1xuXHRcdFx0XHQnPC90ZD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBkYXkgYmcgY2VsbHMgZm9yIGVhY2ggZGF5LXJvd1xuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy53ZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiICcgK1xuXHRcdFx0XHR2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGV2ZXJ5IG90aGVyIHR5cGUgb2Ygcm93IGdlbmVyYXRlZCBieSBEYXlHcmlkLlxuXHQvLyBBZmZlY3RzIGhlbHBlci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXG5cdHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy53ZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxufTtcblxuOztcblxuLyogQSBtb250aCB2aWV3IHdpdGggZGF5IGNlbGxzIHJ1bm5pbmcgaW4gcm93cyAob25lLXBlci13ZWVrKSBhbmQgY29sdW1uc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBNb250aFZpZXcgPSBGQy5Nb250aFZpZXcgPSBCYXNpY1ZpZXcuZXh0ZW5kKHtcblxuXHQvLyBQcm9kdWNlcyBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHJhbmdlIHRvIGRpc3BsYXlcblx0Y29tcHV0ZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHJhbmdlID0gQmFzaWNWaWV3LnByb3RvdHlwZS5jb21wdXRlUmFuZ2UuY2FsbCh0aGlzLCBkYXRlKTsgLy8gZ2V0IHZhbHVlIGZyb20gc3VwZXItbWV0aG9kXG5cdFx0dmFyIHJvd0NudDtcblxuXHRcdC8vIGVuc3VyZSA2IHdlZWtzXG5cdFx0aWYgKHRoaXMuaXNGaXhlZFdlZWtzKCkpIHtcblx0XHRcdHJvd0NudCA9IE1hdGguY2VpbChyYW5nZS5lbmQuZGlmZihyYW5nZS5zdGFydCwgJ3dlZWtzJywgdHJ1ZSkpOyAvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG5cdFx0XHRyYW5nZS5lbmQuYWRkKDYgLSByb3dDbnQsICd3ZWVrcycpO1xuXHRcdH1cblxuXHRcdHJldHVybiByYW5nZTtcblx0fSxcblxuXG5cdC8vIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBCYXNpY1ZpZXcgYmVoYXZpb3IgdG8gaGF2ZSBzcGVjaWFsIG11bHRpLXdlZWsgYXV0by1oZWlnaHQgbG9naWNcblx0c2V0R3JpZEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBpc0F1dG8pIHtcblxuXHRcdGlzQXV0byA9IGlzQXV0byB8fCB0aGlzLm9wdCgnd2Vla01vZGUnKSA9PT0gJ3ZhcmlhYmxlJzsgLy8gTEVHQUNZOiB3ZWVrTW9kZSBpcyBkZXByZWNhdGVkXG5cblx0XHQvLyBpZiBhdXRvLCBtYWtlIHRoZSBoZWlnaHQgb2YgZWFjaCByb3cgdGhlIGhlaWdodCB0aGF0IGl0IHdvdWxkIGJlIGlmIHRoZXJlIHdlcmUgNiB3ZWVrc1xuXHRcdGlmIChpc0F1dG8pIHtcblx0XHRcdGhlaWdodCAqPSB0aGlzLnJvd0NudCAvIDY7XG5cdFx0fVxuXG5cdFx0ZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsICFpc0F1dG8pOyAvLyBpZiBhdXRvLCBkb24ndCBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXG5cdH0sXG5cblxuXHRpc0ZpeGVkV2Vla3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3ZWVrTW9kZSA9IHRoaXMub3B0KCd3ZWVrTW9kZScpOyAvLyBMRUdBQ1k6IHdlZWtNb2RlIGlzIGRlcHJlY2F0ZWRcblx0XHRpZiAod2Vla01vZGUpIHtcblx0XHRcdHJldHVybiB3ZWVrTW9kZSA9PT0gJ2ZpeGVkJzsgLy8gaWYgYW55IG90aGVyIHR5cGUgb2Ygd2Vla01vZGUsIGFzc3VtZSBOT1QgZml4ZWRcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5vcHQoJ2ZpeGVkV2Vla0NvdW50Jyk7XG5cdH1cblxufSk7XG5cbjs7XG5cbmZjVmlld3MuYmFzaWMgPSB7XG5cdCdjbGFzcyc6IEJhc2ljVmlld1xufTtcblxuZmNWaWV3cy5iYXNpY0RheSA9IHtcblx0dHlwZTogJ2Jhc2ljJyxcblx0ZHVyYXRpb246IHsgZGF5czogMSB9XG59O1xuXG5mY1ZpZXdzLmJhc2ljV2VlayA9IHtcblx0dHlwZTogJ2Jhc2ljJyxcblx0ZHVyYXRpb246IHsgd2Vla3M6IDEgfVxufTtcblxuZmNWaWV3cy5tb250aCA9IHtcblx0J2NsYXNzJzogTW9udGhWaWV3LFxuXHRkdXJhdGlvbjogeyBtb250aHM6IDEgfSwgLy8gaW1wb3J0YW50IGZvciBwcmV2L25leHRcblx0ZGVmYXVsdHM6IHtcblx0XHRmaXhlZFdlZWtDb3VudDogdHJ1ZVxuXHR9XG59O1xuOztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIGFsbCBhZ2VuZGEtcmVsYXRlZCB2aWV3cy4gRGlzcGxheXMgb25lIG1vcmUgY29sdW1ucyB3aXRoIHRpbWUgc2xvdHMgcnVubmluZyB2ZXJ0aWNhbGx5LlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJcyBhIG1hbmFnZXIgZm9yIHRoZSBUaW1lR3JpZCBzdWJjb21wb25lbnQgYW5kIHBvc3NpYmx5IHRoZSBEYXlHcmlkIHN1YmNvbXBvbmVudCAoaWYgYWxsRGF5U2xvdCBpcyBvbikuXG4vLyBSZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxuXG52YXIgQWdlbmRhVmlldyA9IEZDLkFnZW5kYVZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cblx0c2Nyb2xsZXI6IG51bGwsXG5cblx0dGltZUdyaWRDbGFzczogVGltZUdyaWQsIC8vIGNsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIHRpbWVHcmlkLiBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuXHR0aW1lR3JpZDogbnVsbCwgLy8gdGhlIG1haW4gdGltZS1ncmlkIHN1YmNvbXBvbmVudCBvZiB0aGlzIHZpZXdcblxuXHRkYXlHcmlkQ2xhc3M6IERheUdyaWQsIC8vIGNsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIGRheUdyaWQuIHN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXG5cdGRheUdyaWQ6IG51bGwsIC8vIHRoZSBcImFsbC1kYXlcIiBzdWJjb21wb25lbnQuIGlmIGFsbC1kYXkgaXMgdHVybmVkIG9mZiwgdGhpcyB3aWxsIGJlIG51bGxcblxuXHRheGlzV2lkdGg6IG51bGwsIC8vIHRoZSB3aWR0aCBvZiB0aGUgdGltZSBheGlzIHJ1bm5pbmcgZG93biB0aGUgc2lkZVxuXG5cdGhlYWRDb250YWluZXJFbDogbnVsbCwgLy8gZGl2IHRoYXQgaG9sZCdzIHRoZSB0aW1lR3JpZCdzIHJlbmRlcmVkIGRhdGUgaGVhZGVyXG5cdG5vU2Nyb2xsUm93RWxzOiBudWxsLCAvLyBzZXQgb2YgZmFrZSByb3cgZWxlbWVudHMgdGhhdCBtdXN0IGNvbXBlbnNhdGUgd2hlbiBzY3JvbGxlciBoYXMgc2Nyb2xsYmFyc1xuXG5cdC8vIHdoZW4gdGhlIHRpbWUtZ3JpZCBpc24ndCB0YWxsIGVub3VnaCB0byBvY2N1cHkgdGhlIGdpdmVuIGhlaWdodCwgd2UgcmVuZGVyIGFuIDxocj4gdW5kZXJuZWF0aFxuXHRib3R0b21SdWxlRWw6IG51bGwsXG5cblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkID0gdGhpcy5pbnN0YW50aWF0ZVRpbWVHcmlkKCk7XG5cblx0XHRpZiAodGhpcy5vcHQoJ2FsbERheVNsb3QnKSkgeyAvLyBzaG91bGQgd2UgZGlzcGxheSB0aGUgXCJhbGwtZGF5XCIgYXJlYT9cblx0XHRcdHRoaXMuZGF5R3JpZCA9IHRoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7IC8vIHRoZSBhbGwtZGF5IHN1YmNvbXBvbmVudCBvZiB0aGlzIHZpZXdcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHtcblx0XHRcdG92ZXJmbG93WDogJ2hpZGRlbicsXG5cdFx0XHRvdmVyZmxvd1k6ICdhdXRvJ1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gSW5zdGFudGlhdGVzIHRoZSBUaW1lR3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMudGltZUdyaWRDbGFzc1xuXHRpbnN0YW50aWF0ZVRpbWVHcmlkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3ViY2xhc3MgPSB0aGlzLnRpbWVHcmlkQ2xhc3MuZXh0ZW5kKGFnZW5kYVRpbWVHcmlkTWV0aG9kcyk7XG5cblx0XHRyZXR1cm4gbmV3IHN1YmNsYXNzKHRoaXMpO1xuXHR9LFxuXG5cblx0Ly8gSW5zdGFudGlhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbWlnaHQgbmVlZC4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xuXHRpbnN0YW50aWF0ZURheUdyaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdWJjbGFzcyA9IHRoaXMuZGF5R3JpZENsYXNzLmV4dGVuZChhZ2VuZGFEYXlHcmlkTWV0aG9kcyk7XG5cblx0XHRyZXR1cm4gbmV3IHN1YmNsYXNzKHRoaXMpO1xuXHR9LFxuXG5cblx0LyogUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTZXRzIHRoZSBkaXNwbGF5IHJhbmdlIGFuZCBjb21wdXRlcyBhbGwgbmVjZXNzYXJ5IGRhdGVzXG5cdHNldFJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdFZpZXcucHJvdG90eXBlLnNldFJhbmdlLmNhbGwodGhpcywgcmFuZ2UpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdHRoaXMudGltZUdyaWQuc2V0UmFuZ2UocmFuZ2UpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5zZXRSYW5nZShyYW5nZSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgdmlldyBpbnRvIGB0aGlzLmVsYCwgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBhc3NpZ25lZFxuXHRyZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLmVsLmFkZENsYXNzKCdmYy1hZ2VuZGEtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XG5cdFx0dGhpcy5yZW5kZXJIZWFkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xuXHRcdHZhciB0aW1lR3JpZFdyYXBFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLXRpbWUtZ3JpZC1jb250YWluZXInKTtcblx0XHR2YXIgdGltZUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy10aW1lLWdyaWRcIiAvPicpLmFwcGVuZFRvKHRpbWVHcmlkV3JhcEVsKTtcblx0XHR0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZCh0aW1lR3JpZFdyYXBFbCk7XG5cblx0XHR0aGlzLnRpbWVHcmlkLnNldEVsZW1lbnQodGltZUdyaWRFbCk7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJEYXRlcygpO1xuXG5cdFx0Ly8gdGhlIDxocj4gdGhhdCBzb21ldGltZXMgZGlzcGxheXMgdW5kZXIgdGhlIHRpbWUtZ3JpZFxuXHRcdHRoaXMuYm90dG9tUnVsZUVsID0gJCgnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIi8+Jylcblx0XHRcdC5hcHBlbmRUbyh0aGlzLnRpbWVHcmlkLmVsKTsgLy8gaW5qZWN0IGl0IGludG8gdGhlIHRpbWUtZ3JpZFxuXG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnNldEVsZW1lbnQodGhpcy5lbC5maW5kKCcuZmMtZGF5LWdyaWQnKSk7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVuZGVyRGF0ZXMoKTtcblxuXHRcdFx0Ly8gaGF2ZSB0aGUgZGF5LWdyaWQgZXh0ZW5kIGl0J3MgY29vcmRpbmF0ZSBhcmVhIG92ZXIgdGhlIDxocj4gZGl2aWRpbmcgdGhlIHR3byBncmlkc1xuXHRcdFx0dGhpcy5kYXlHcmlkLmJvdHRvbUNvb3JkUGFkZGluZyA9IHRoaXMuZGF5R3JpZC5lbC5uZXh0KCdocicpLm91dGVySGVpZ2h0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ub1Njcm9sbFJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdzpub3QoLmZjLXNjcm9sbGVyICopJyk7IC8vIGZha2Ugcm93cyBub3Qgd2l0aGluIHRoZSBzY3JvbGxlclxuXHR9LFxuXG5cblx0Ly8gcmVuZGVyIHRoZSBkYXktb2Ytd2VlayBoZWFkZXJzXG5cdHJlbmRlckhlYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZENvbnRhaW5lckVsID1cblx0XHRcdHRoaXMuZWwuZmluZCgnLmZjLWhlYWQtY29udGFpbmVyJylcblx0XHRcdFx0Lmh0bWwodGhpcy50aW1lR3JpZC5yZW5kZXJIZWFkSHRtbCgpKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgY29udGVudCBvZiB0aGUgdmlldy4gU2luY2Ugd2UgaGF2ZW4ndCBzZXBhcmF0ZWQgc2tlbGV0b24gcmVuZGVyaW5nIGZyb20gZGF0ZSByZW5kZXJpbmcsXG5cdC8vIGFsd2F5cyBjb21wbGV0ZWx5IGtpbGwgZWFjaCBncmlkJ3MgcmVuZGVyaW5nLlxuXHR1bnJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyRGF0ZXMoKTtcblx0XHR0aGlzLnRpbWVHcmlkLnJlbW92ZUVsZW1lbnQoKTtcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckRhdGVzKCk7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cblx0Ly8gVGhlIGRheS1ncmlkIGFuZCB0aW1lLWdyaWQgY29tcG9uZW50cyB3aWxsIHJlbmRlciBpbnNpZGUgY29udGFpbmVycyBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cblx0cmVuZGVyU2tlbGV0b25IdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0Jzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcblx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGlzLndpZGdldEhlYWRlckNsYXNzICsgJ1wiPjwvdGQ+JyArXG5cdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdCc8L3RoZWFkPicgK1xuXHRcdFx0XHQnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiJyArIHRoaXMud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0XHQodGhpcy5kYXlHcmlkID9cblx0XHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCIvPicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGlzLndpZGdldEhlYWRlckNsYXNzICsgJ1wiLz4nIDpcblx0XHRcdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdFx0JzwvdGQ+JyArXG5cdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdCc8L3Rib2R5PicgK1xuXHRcdFx0JzwvdGFibGU+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBheGlzLCBpZiBpdCBpcyBrbm93blxuXHRheGlzU3R5bGVBdHRyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5heGlzV2lkdGggIT09IG51bGwpIHtcblx0XHRcdCByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMuYXhpc1dpZHRoICsgJ3B4XCInO1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHRcdH1cblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBOb3cgSW5kaWNhdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lR3JpZC5nZXROb3dJbmRpY2F0b3JVbml0KCk7XG5cdH0sXG5cblxuXHRyZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnJlbmRlck5vd0luZGljYXRvcihkYXRlKTtcblx0fSxcblxuXG5cdHVucmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7XG5cdH0sXG5cblxuXHQvKiBEaW1lbnNpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHR1cGRhdGVTaXplOiBmdW5jdGlvbihpc1Jlc2l6ZSkge1xuXHRcdHRoaXMudGltZUdyaWQudXBkYXRlU2l6ZShpc1Jlc2l6ZSk7XG5cblx0XHRWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgaXNSZXNpemUpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIFJlZnJlc2hlcyB0aGUgaG9yaXpvbnRhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3XG5cdHVwZGF0ZVdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHQvLyBtYWtlIGFsbCBheGlzIGNlbGxzIGxpbmUgdXAsIGFuZCByZWNvcmQgdGhlIHdpZHRoIHNvIG5ld2x5IGNyZWF0ZWQgYXhpcyBjZWxscyB3aWxsIGhhdmUgaXRcblx0XHR0aGlzLmF4aXNXaWR0aCA9IG1hdGNoQ2VsbFdpZHRocyh0aGlzLmVsLmZpbmQoJy5mYy1heGlzJykpO1xuXHR9LFxuXG5cblx0Ly8gQWRqdXN0cyB0aGUgdmVydGljYWwgZGltZW5zaW9ucyBvZiB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0LCBpc0F1dG8pIHtcblx0XHR2YXIgZXZlbnRMaW1pdDtcblx0XHR2YXIgc2Nyb2xsZXJIZWlnaHQ7XG5cdFx0dmFyIHNjcm9sbGJhcldpZHRocztcblxuXHRcdC8vIHJlc2V0IGFsbCBkaW1lbnNpb25zIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHN0YXRlXG5cdFx0dGhpcy5ib3R0b21SdWxlRWwuaGlkZSgpOyAvLyAuc2hvdygpIHdpbGwgYmUgY2FsbGVkIGxhdGVyIGlmIHRoaXMgPGhyPiBpcyBuZWNlc3Nhcnlcblx0XHR0aGlzLnNjcm9sbGVyLmNsZWFyKCk7IC8vIHNldHMgaGVpZ2h0IHRvICdhdXRvJyBhbmQgY2xlYXJzIG92ZXJmbG93XG5cdFx0dW5jb21wZW5zYXRlU2Nyb2xsKHRoaXMubm9TY3JvbGxSb3dFbHMpO1xuXG5cdFx0Ly8gbGltaXQgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUgYWxsLWRheSBhcmVhXG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcblxuXHRcdFx0ZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XG5cdFx0XHRpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0ZXZlbnRMaW1pdCA9IEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUOyAvLyBtYWtlIHN1cmUgXCJhdXRvXCIgZ29lcyB0byBhIHJlYWwgbnVtYmVyXG5cdFx0XHR9XG5cdFx0XHRpZiAoZXZlbnRMaW1pdCkge1xuXHRcdFx0XHR0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xuXG5cdFx0XHRzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcblx0XHRcdHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG5cblx0XHRcdGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHsgLy8gdXNpbmcgc2Nyb2xsYmFycz9cblxuXHRcdFx0XHQvLyBtYWtlIHRoZSBhbGwtZGF5IGFuZCBoZWFkZXIgcm93cyBsaW5lcyB1cFxuXHRcdFx0XHRjb21wZW5zYXRlU2Nyb2xsKHRoaXMubm9TY3JvbGxSb3dFbHMsIHNjcm9sbGJhcldpZHRocyk7XG5cblx0XHRcdFx0Ly8gdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjaGFuZ2VkIHRleHQgZmxvdywgd2hpY2ggbWlnaHQgYWZmZWN0IGhlaWdodCwgc28gcmVjYWxjdWxhdGVcblx0XHRcdFx0Ly8gYW5kIHJlYXBwbHkgdGhlIGRlc2lyZWQgaGVpZ2h0IHRvIHRoZSBzY3JvbGxlci5cblx0XHRcdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXG5cdFx0XHR0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xuXG5cdFx0XHQvLyBpZiB0aGVyZSdzIGFueSBzcGFjZSBiZWxvdyB0aGUgc2xhdHMsIHNob3cgdGhlIGhvcml6b250YWwgcnVsZS5cblx0XHRcdC8vIHRoaXMgd29uJ3QgY2F1c2UgYW55IG5ldyBvdmVyZmxvdywgYmVjYXVzZSBsb2NrT3ZlcmZsb3cgYWxyZWFkeSBjYWxsZWQuXG5cdFx0XHRpZiAodGhpcy50aW1lR3JpZC5nZXRUb3RhbFNsYXRIZWlnaHQoKSA8IHNjcm9sbGVySGVpZ2h0KSB7XG5cdFx0XHRcdHRoaXMuYm90dG9tUnVsZUVsLnNob3coKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXG5cdGNvbXB1dGVTY3JvbGxlckhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQpIHtcblx0XHRyZXR1cm4gdG90YWxIZWlnaHQgLVxuXHRcdFx0c3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXG5cdH0sXG5cblxuXHQvKiBTY3JvbGxcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIHRoZSBpbml0aWFsIHByZS1jb25maWd1cmVkIHNjcm9sbCBzdGF0ZSBwcmlvciB0byBhbGxvd2luZyB0aGUgdXNlciB0byBjaGFuZ2UgaXRcblx0Y29tcHV0ZUluaXRpYWxTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdzY3JvbGxUaW1lJykpO1xuXHRcdHZhciB0b3AgPSB0aGlzLnRpbWVHcmlkLmNvbXB1dGVUaW1lVG9wKHNjcm9sbFRpbWUpO1xuXG5cdFx0Ly8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcblx0XHR0b3AgPSBNYXRoLmNlaWwodG9wKTtcblxuXHRcdGlmICh0b3ApIHtcblx0XHRcdHRvcCsrOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gdG9wO1xuXHR9LFxuXG5cblx0cXVlcnlTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpO1xuXHR9LFxuXG5cblx0c2V0U2Nyb2xsOiBmdW5jdGlvbih0b3ApIHtcblx0XHR0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcCh0b3ApO1xuXHR9LFxuXG5cblx0LyogSGl0IEFyZWFzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIGZvcndhcmQgYWxsIGhpdC1yZWxhdGVkIG1ldGhvZCBjYWxscyB0byB0aGUgZ3JpZHMgKGRheUdyaWQgbWlnaHQgbm90IGJlIGRlZmluZWQpXG5cblxuXHRwcmVwYXJlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5wcmVwYXJlSGl0cygpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5wcmVwYXJlSGl0cygpO1xuXHRcdH1cblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnJlbGVhc2VIaXRzKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbGVhc2VIaXRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuXHRcdHZhciBoaXQgPSB0aGlzLnRpbWVHcmlkLnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XG5cblx0XHRpZiAoIWhpdCAmJiB0aGlzLmRheUdyaWQpIHtcblx0XHRcdGhpdCA9IHRoaXMuZGF5R3JpZC5xdWVyeUhpdChsZWZ0LCB0b3ApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoaXQ7XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHQvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cblx0XHRyZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRTcGFuKGhpdCk7XG5cdH0sXG5cblxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdFx0Ly8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXG5cdFx0cmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0RWwoaGl0KTtcblx0fSxcblxuXG5cdC8qIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBldmVudHMgb250byB0aGUgdmlldyBhbmQgcG9wdWxhdGVzIHRoZSBWaWV3J3Mgc2VnbWVudCBhcnJheVxuXHRyZW5kZXJFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBkYXlFdmVudHMgPSBbXTtcblx0XHR2YXIgdGltZWRFdmVudHMgPSBbXTtcblx0XHR2YXIgZGF5U2VncyA9IFtdO1xuXHRcdHZhciB0aW1lZFNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBzZXBhcmF0ZSB0aGUgZXZlbnRzIGludG8gYWxsLWRheSBhbmQgdGltZWRcblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZXZlbnRzW2ldLmFsbERheSkge1xuXHRcdFx0XHRkYXlFdmVudHMucHVzaChldmVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRpbWVkRXZlbnRzLnB1c2goZXZlbnRzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZW5kZXIgdGhlIGV2ZW50cyBpbiB0aGUgc3ViY29tcG9uZW50c1xuXHRcdHRpbWVkU2VncyA9IHRoaXMudGltZUdyaWQucmVuZGVyRXZlbnRzKHRpbWVkRXZlbnRzKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHRkYXlTZWdzID0gdGhpcy5kYXlHcmlkLnJlbmRlckV2ZW50cyhkYXlFdmVudHMpO1xuXHRcdH1cblxuXHRcdC8vIHRoZSBhbGwtZGF5IGFyZWEgaXMgZmxleGlibGUgYW5kIG1pZ2h0IGhhdmUgYSBsb3Qgb2YgZXZlbnRzLCBzbyBzaGlmdCB0aGUgaGVpZ2h0XG5cdFx0dGhpcy51cGRhdGVIZWlnaHQoKTtcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbGwgc2VnbWVudCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIGluIHRoZSB2aWV3XG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0RXZlbnRTZWdzKCkuY29uY2F0KFxuXHRcdFx0dGhpcy5kYXlHcmlkID8gdGhpcy5kYXlHcmlkLmdldEV2ZW50U2VncygpIDogW11cblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCBldmVudCBlbGVtZW50cyBhbmQgY2xlYXJzIGludGVybmFsIHNlZ21lbnQgZGF0YVxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cblx0XHQvLyB1bnJlbmRlciB0aGUgZXZlbnRzIGluIHRoZSBzdWJjb21wb25lbnRzXG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckV2ZW50cygpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckV2ZW50cygpO1xuXHRcdH1cblxuXHRcdC8vIHdlIERPTidUIG5lZWQgdG8gY2FsbCB1cGRhdGVIZWlnaHQoKSBiZWNhdXNlOlxuXHRcdC8vIEEpIGEgcmVuZGVyRXZlbnRzKCkgY2FsbCBhbHdheXMgaGFwcGVucyBhZnRlciB0aGlzLCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgY2FsbCB1cGRhdGVIZWlnaHQoKVxuXHRcdC8vIEIpIGluIElFOCwgdGhpcyBjYXVzZXMgYSBmbGFzaCB3aGVuZXZlciBldmVudHMgYXJlIHJlcmVuZGVyZWRcblx0fSxcblxuXG5cdC8qIERyYWdnaW5nIChmb3IgZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHRpZiAoZHJvcExvY2F0aW9uLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGltZUdyaWQucmVuZGVyRHJhZyhkcm9wTG9jYXRpb24sIHNlZyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbiwgc2VnKTtcblx0XHR9XG5cdH0sXG5cblxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQudW5yZW5kZXJEcmFnKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRHJhZygpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXG5cdHJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oc3Bhbikge1xuXHRcdGlmIChzcGFuLnN0YXJ0Lmhhc1RpbWUoKSB8fCBzcGFuLmVuZC5oYXNUaW1lKCkpIHtcblx0XHRcdHRoaXMudGltZUdyaWQucmVuZGVyU2VsZWN0aW9uKHNwYW4pO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJTZWxlY3Rpb24oc3Bhbik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb25zIG9mIGEgc2VsZWN0aW9uXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG5cbi8vIE1ldGhvZHMgdGhhdCB3aWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgdGltZUdyaWRcbi8vIFRPRE86IG1vdmUgaW50byBUaW1lR3JpZFxudmFyIGFnZW5kYVRpbWVHcmlkTWV0aG9kcyA9IHtcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIHRoZSBkYXktb2Ygd2VlayBoZWFkZXIgY2VsbHNcblx0cmVuZGVySGVhZEludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHdlZWtUZXh0O1xuXG5cdFx0aWYgKHZpZXcub3B0KCd3ZWVrTnVtYmVycycpKSB7XG5cdFx0XHR3ZWVrVGV4dCA9IHRoaXMuc3RhcnQuZm9ybWF0KHZpZXcub3B0KCdzbWFsbFdlZWtGb3JtYXQnKSk7XG5cblx0XHRcdHJldHVybiAnJyArXG5cdFx0XHRcdCc8dGggY2xhc3M9XCJmYy1heGlzIGZjLXdlZWstbnVtYmVyICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdFx0JzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0aHRtbEVzY2FwZSh3ZWVrVGV4dCkgK1xuXHRcdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHRcdCc8L3RoPic7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICc8dGggY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90aD4nO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBiZyBvZiB0aGUgVGltZUdyaWQgc2xvdCBhcmVhLiBMb25nIHZlcnRpY2FsIGNvbHVtbi5cblx0cmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cblx0Ly8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cblx0cmVuZGVySW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHR9XG5cbn07XG5cblxuLy8gTWV0aG9kcyB0aGF0IHdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyBkYXlHcmlkXG52YXIgYWdlbmRhRGF5R3JpZE1ldGhvZHMgPSB7XG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYWxsLWRheSBjZWxsc1xuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdCc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcblx0XHRcdFx0XHQodmlldy5vcHQoJ2FsbERheUh0bWwnKSB8fCBodG1sRXNjYXBlKHZpZXcub3B0KCdhbGxEYXlUZXh0JykpKSArXG5cdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHQnPC90ZD4nO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxuXHQvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIGhlbHBlci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxuXHRyZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XG5cdH1cblxufTtcblxuOztcblxudmFyIEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUID0gNTtcblxuLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxudmFyIEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TID0gW1xuXHR7IGhvdXJzOiAxIH0sXG5cdHsgbWludXRlczogMzAgfSxcblx0eyBtaW51dGVzOiAxNSB9LFxuXHR7IHNlY29uZHM6IDMwIH0sXG5cdHsgc2Vjb25kczogMTUgfVxuXTtcblxuZmNWaWV3cy5hZ2VuZGEgPSB7XG5cdCdjbGFzcyc6IEFnZW5kYVZpZXcsXG5cdGRlZmF1bHRzOiB7XG5cdFx0YWxsRGF5U2xvdDogdHJ1ZSxcblx0XHRhbGxEYXlUZXh0OiAnYWxsLWRheScsXG5cdFx0c2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxuXHRcdG1pblRpbWU6ICcwMDowMDowMCcsXG5cdFx0bWF4VGltZTogJzI0OjAwOjAwJyxcblx0XHRzbG90RXZlbnRPdmVybGFwOiB0cnVlIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxuXHR9XG59O1xuXG5mY1ZpZXdzLmFnZW5kYURheSA9IHtcblx0dHlwZTogJ2FnZW5kYScsXG5cdGR1cmF0aW9uOiB7IGRheXM6IDEgfVxufTtcblxuZmNWaWV3cy5hZ2VuZGFXZWVrID0ge1xuXHR0eXBlOiAnYWdlbmRhJyxcblx0ZHVyYXRpb246IHsgd2Vla3M6IDEgfVxufTtcbjs7XG5cbnJldHVybiBGQzsgLy8gZXhwb3J0IGZvciBOb2RlL0NvbW1vbkpTXG59KTtcbiJdfQ==

/***/ },

/***/ 507:
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/
(function() {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/*** EXPORTS FROM exports-loader ***/
module.exports = global.fetch;
}.call(global));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(222)))

/***/ },

/***/ 512:
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(81);
module.exports = __webpack_require__(265);


/***/ }

},[512]);